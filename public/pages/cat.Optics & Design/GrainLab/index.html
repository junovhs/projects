<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>GrainLab — 100% Crop (physics‑anchored sweet spot)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { color-scheme: dark; --bg:#0f1115; --panel:#171a21; --muted:#8c95a6; --text:#e8ecf5; --acc:#5dd1ff; --acc2:#b486ff; }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--text); font:14px/1.25 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
  #app { display:grid; grid-template-columns: 360px 1fr; height:100%; }
  #left { background:var(--panel); border-right:1px solid #222733; padding:14px; overflow:auto; }
  #right { display:flex; flex-direction:column; min-width:0; }
  .head { display:flex; align-items:center; gap:10px; }
  .logo { font-weight:700; letter-spacing:0.3px; background:linear-gradient(90deg,var(--acc),var(--acc2)); -webkit-background-clip:text; background-clip:text; color:transparent; }
  .badge { font-size:11px; color:#a7b0c2; padding:2px 6px; border:1px solid #2a3040; border-radius:999px; }
  .group { background:#12151c; border:1px solid #1f2430; border-radius:10px; margin-top:14px; overflow:hidden; }
  .group h2 { margin:0; padding:10px 12px; background:#151a22; border-bottom:1px solid #202636; color:#cbd2e3; font-size:13px; letter-spacing:0.2px; }
  .row { display:flex; align-items:center; gap:10px; padding:10px 12px; }
  .row label { flex:0 0 140px; color:#aab3c4; font-size:12px; }
  .row input[type="range"] { flex:1; }
  .row select { width:150px; background:#0e1219; color:var(--text); border:1px solid #283042; padding:6px 8px; border-radius:6px; }
  .btn { background:#171c27; color:var(--text); border:1px solid #2b3243; padding:8px 10px; border-radius:8px; cursor:pointer; transition:.2s; }
  .btn:hover { background:#1f2533; }
  .btn.primary { background:linear-gradient(180deg,#20293e,#171d2b); border-color:#2d3751; }
  .subtle { color:var(--muted); font-size:12px; }
  .val { width:48px; text-align:right; color:#9aa4b5; font-variant-numeric: tabular-nums; }
  #topbar { display:flex; gap:8px; align-items:center; padding:10px; border-bottom:1px solid #1a2030; background:#0d1016; }
  #status { margin-left:auto; color:#96a0b4; font-size:12px; }
  #stage { position:relative; flex:1; display:flex; align-items:center; justify-content:center; background:
    radial-gradient(1200px 400px at 120% -20%, #1d2340 0%, transparent 60%),
    radial-gradient(800px 300px at -20% 110%, #1c2b38 0%, transparent 55%),
    #0a0d12; overflow:hidden; }
  #wrap { position:relative; box-shadow: 0 10px 80px rgba(0,0,0,0.6); border-radius:12px; overflow:hidden; }
  canvas { display:block; background:#0d1118; }
  #fxbar { position:absolute; left:12px; bottom:12px; display:flex; gap:8px; background:#0b0e14aa; backdrop-filter: blur(6px); padding:8px 10px; border:1px solid #1c2232; border-radius:999px; }
  #fxbar .pill { font-size:12px; color:#c7d0e3; padding:6px 10px; border-radius:999px; border:1px solid #263047; background:linear-gradient(180deg,#0f1522,#0b101a); white-space:nowrap; }

  #mini { width:100%; height:120px; background:#0e1218; border:1px solid #1e2534; border-radius:8px; position:relative; overflow:hidden; }
  #mini .box { position:absolute; border:1px solid #5dd1ff; box-shadow:0 0 0 9999px #5dd1ff22 inset; pointer-events:none; }

  #guide { position:absolute; inset:0; pointer-events:none; display:flex; align-items:center; justify-content:center; color:#cde9ff; font-size:13px; letter-spacing:0.2px; }
  #guide .hint { background:#0b0e14cc; border:1px solid #1c2232; padding:8px 10px; border-radius:10px; }
</style>
</head>
<body>
<div id="app">
  <div id="left">
    <div class="head">
      <div class="logo">GrainLab</div>
      <div class="badge">100% Crop</div>
    </div>

    <div class="group">
      <h2>Source</h2>
      <div class="row">
        <label for="file">Load Image</label>
        <input id="file" type="file" accept="image/*" aria-label="Load image" />
      </div>
      <div class="row">
        <label for="previewSize">Canvas Size</label>
        <select id="previewSize">
          <option value="720">720 × 405</option>
          <option value="960" selected>960 × 540</option>
          <option value="1280">1280 × 720</option>
        </select>
      </div>
      <div class="row" style="flex-direction:column; gap:6px;">
        <div class="subtle">Mini‑map (drag to pan 100% crop)</div>
        <div id="mini" role="img" aria-label="Mini-map for panning 100% crop"><div class="box" id="miniBox"></div></div>
      </div>
      <div class="row" style="gap:8px;flex-wrap:wrap;">
        <button id="exportFull" class="btn primary">Export Full‑res</button>
        <span class="subtle">Canvas shows a 1:1 crop. Drag canvas or mini‑map.</span>
      </div>
    </div>

    <div class="group">
      <h2>Grain</h2>
      <div class="row"><label for="intensity">Intensity</label>
        <input id="intensity" type="range" min="0" max="1" step="0.01" value="0.6" aria-labelledby="intensity" /><span class="val" id="vIntensity">0.60</span>
      </div>
      <div class="row"><label for="grainSize">Size (px @ 100%)</label>
        <input id="grainSize" type="range" min="0.5" max="8" step="0.1" value="2.2" aria-labelledby="grainSize" /><span class="val" id="vGrainSize">2.2</span>
      </div>
      <div class="row"><label for="distribution">Distribution</label>
        <select id="distribution"><option value="uniform">Uniform</option><option value="dynamic" selected>Dynamic</option></select>
      </div>
      <div class="row"><label for="shape">Shape</label>
        <select id="shape"><option value="square">Square</option><option value="circle" selected>Circular</option><option value="irregular">Irregular</option></select>
      </div>
      <div class="row"><label for="periodicity">Periodicity</label>
        <select id="periodicity"><option value="random" selected>Random</option><option value="regular">Regular</option></select>
      </div>
      <div class="row"><label for="subpixel">Subpixel</label>
        <select id="subpixel"><option value="off">Off</option><option value="on" selected>On</option></select>
      </div>
      <div class="row"><label for="lumBias">Luminance Bias</label>
        <input id="lumBias" type="range" min="0" max="1" step="0.01" value="0.6" aria-labelledby="lumBias" /><span class="val" id="vLumBias">0.60</span>
      </div>
      <div class="row"><label for="contrast">Contrast</label>
        <input id="contrast" type="range" min="0" max="2" step="0.01" value="1.2" aria-labelledby="contrast" /><span class="val" id="vContrast">1.20</span>
      </div>
      <div class="row"><label for="opacityDecay">Opacity Decay</label>
        <input id="opacityDecay" type="range" min="0" max="1" step="0.01" value="0.35" aria-labelledby="opacityDecay" /><span class="val" id="vOpacityDecay">0.35</span>
      </div>
    </div>

    <div class="group">
      <h2>Blend</h2>
      <div class="row"><label for="blendMode">Mode</label>
        <select id="blendMode">
          <option value="overlay" selected>Overlay</option>
          <option value="softlight">Soft Light</option>
          <option value="screen">Screen</option>
          <option value="multiply">Multiply</option>
        </select>
      </div>
      <div class="row"><label for="blendOpacity">Opacity</label>
        <input id="blendOpacity" type="range" min="0" max="1" step="0.01" value="0.55" aria-labelledby="blendOpacity" /><span class="val" id="vBlendOpacity">0.55</span>
      </div>
      <div class="row"><label for="sharpPreserve">Sharpness Preserve</label>
        <input id="sharpPreserve" type="range" min="0" max="1" step="0.01" value="0.65" aria-labelledby="sharpPreserve" /><span class="val" id="vSharpPreserve">0.65</span>
      </div>
    </div>

    <div class="group">
      <h2>Presets</h2>
      <div class="row" style="flex-wrap:wrap; gap:8px 8px;">
        <button class="btn" id="presetVintage">Vintage Glow</button>
        <button class="btn" id="presetMinimal">Minimal Grain</button>
        <button class="btn" id="presetGrit">Grit & Soft</button>
      </div>
      <div class="row" style="flex-wrap:wrap; gap:8px 8px;">
        <label for="stock">Stock Preset</label>
        <select id="stock">
          <option value="custom" selected>Custom</option>
          <option value="trix">Kodak Tri‑X 400</option>
          <option value="tmax">Kodak T‑MAX 100</option>
          <option value="v3_500t">Vision3 500T</option>
        </select>
        <label for="push">Push/Pull</label>
        <select id="push">
          <option value="0" selected>Normal (0)</option>
          <option value="1">Push +1</option>
          <option value="2">Push +2</option>
          <option value="-1">Pull −1</option>
        </select>
      </div>
    </div>

    <div class="group">
      <h2>Debug</h2>
      <div class="row"><label>Status</label><div id="dbgStatus" class="subtle" style="flex:1">Idle</div></div>
      <div class="row"><label>Env</label><div id="dbgEnv" class="subtle" style="flex:1">-</div></div>
    </div>
  </div>

  <div id="right">
    <div id="topbar">
      <div class="badge">Worker + OffscreenCanvas</div>
      <div class="badge">WebGL2</div>
      <div id="status">Idle</div>
    </div>
    <div id="stage">
      <div id="wrap">
        <canvas id="view" width="960" height="540"></canvas>
        <div id="guide"><div class="hint">Drag to pan • 100% crop preview • Export = full image</div></div>
        <div id="fxbar">
          <div class="pill">100% crop (accurate grain)</div>
          <div class="pill">Use mini‑map to navigate</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// -------------------- App state --------------------
const $$ = (id)=>document.getElementById(id);
const view = $$('view');
const vctx = view.getContext('2d');

const params = {
  intensity: 0.6,
  grainSize: 2.2,
  distribution: 'dynamic',
  shape: 'circle',
  periodicity: 'random',
  subpixel: 'on',
  lumBias: 0.6,
  contrast: 1.2,
  opacityDecay: 0.35,
  blendMode: 'overlay',
  blendOpacity: 0.55,
  sharpPreserve: 0.65,

  // Physics-anchored sweet-spot additions:
  // RGB correlation matrix (row-major: r1..r9)
  rgbCorr: [1.0,0.7,0.3, 0.7,1.0,0.8, 0.3,0.8,1.0],
  // Mid-tone visibility curve (peak and width in [0..1], gain)
  midPeak: 0.5,
  midWidth: 0.25,
  midGain: 0.8,
  // Temporal seed (for sequences; here manual)
  frameSeed: 0.0,
  // Scanner PSF and flare
  psfSigma: 0.6,
  flare: 0.007,

  // Stock μ/σ for log-normal radius, plus push control (in stops)
  mu: Math.log(2.2), // base link to grainSize as a default starting point (px)
  sigma: 0.45,
  pushStops: 0
};

const STOCKS = {
  trix:   { name:'Kodak Tri‑X 400',   mu: Math.log(3.2), sigma:0.50, rgbCorr:[1,0.72,0.35, 0.72,1,0.82, 0.35,0.82,1], midPeak:0.55, midWidth:0.28, midGain:0.9 },
  tmax:   { name:'Kodak T‑MAX 100',   mu: Math.log(1.8), sigma:0.35, rgbCorr:[1,0.65,0.25, 0.65,1,0.75, 0.25,0.75,1], midPeak:0.52, midWidth:0.22, midGain:0.75 },
  v3_500t:{ name:'Vision3 500T',      mu: Math.log(2.6), sigma:0.42, rgbCorr:[1,0.78,0.40, 0.78,1,0.85, 0.40,0.85,1], midPeak:0.50, midWidth:0.30, midGain:0.85 }
};

let imgFull = null;
let worker = null;
let hasWorkerGL = false;
let lastTask = 0;
let rafPending = false;
let fullW = 0, fullH = 0;
let cropW = 960, cropH = 540;
let cropX = 0, cropY = 0;

function setStatus(s){ $$('status').textContent = s; $$('dbgStatus').textContent=s; }
function setEnv(s){ $$('dbgEnv').textContent = s; }
function fmt(n,p=2){ return Number(n).toFixed(p); }

// -------------------- Worker (WebGL2) --------------------
const workerCode = `
let gl, cvs, vao, progMain, progBlurH, progBlurV, progCopy, fboA, fboB, texA, texB, texIn, w=0,h=0;

const VS=\`#version 300 es
layout(location=0) in vec2 p;
out vec2 uv;
void main(){ uv=(p+1.0)*0.5; gl_Position=vec4(p,0,1); }\`;

const FS_MAIN=\`#version 300 es
precision highp float;
in vec2 uv; out vec4 o;
uniform sampler2D UImg;
uniform vec2 UImgSize;     // full image size
uniform vec2 UCropOrigin;  // top-left in full px
uniform vec2 UCropSize;    // crop size in px (equals target size)
uniform float intensity, grainSize, lumBias, contrast, opacityDecay, blendOpacity, sharpPreserve;
uniform int distribution, shape, periodicity, subpixel, blendMode;
uniform mat3 rgbCorr;
uniform float midPeak, midWidth, midGain;
uniform float frameSeed;

// Randomness helpers (hash + gaussian)
uint hash2(uvec2 v){ v=v*1664525u+1013904223u; v.x^=v.y>>16; v.y^=v.x<<5; v=v*2246822519u; return v.x^v.y; }
float prng(vec2 p){ uvec2 v = uvec2(floatBitsToUint(p.x), floatBitsToUint(p.y)); return float(hash2(v))/4294967295.0; }
float gaussian2(float u1, float u2){ u1=max(u1,1e-6); float r=sqrt(-2.0*log(u1)); float t=6.2831853*u2; return r*cos(t); }

// Simple blue-noise-ish mix: combine hash with small rotated cell jitter
float noiseCell(vec2 cell, float phase){
  vec2 s = cell + vec2(phase, phase*1.37);
  float n = prng(s);
  float n2 = prng(s*vec2(1.37,1.79));
  return (n*0.7 + n2*0.3);
}

float shapeMask(vec2 f, int shp) {
  if (shp==0) return 1.0; // square cell
  if (shp==1){ vec2 d=f-0.5; return (dot(d,d)<=0.25)?1.0:0.0; } // circle
  vec2 d=f-0.5; float ang=atan(d.y,d.x); float rad=length(d);
  float ir=(sin(ang*5.0+rad*10.0)*0.5+0.5)*(1.0-abs(rad-0.5));
  return clamp(ir,0.0,1.0);
}

vec3 blendOverlay(vec3 I, vec3 N){ return mix(2.0*I*N, 1.0-2.0*(1.0-I)*(1.0-N), step(0.5,I)); }
vec3 blendSoftLight(vec3 I, vec3 N){ return (1.0-2.0*N)*I*I + 2.0*N*I; }
vec3 blendScreen(vec3 I, vec3 N){ return 1.0-(1.0-I)*(1.0-N); }
vec3 blendMultiply(vec3 I, vec3 N){ return I*N; }

void main(){
  // Compute full-res pixel for current crop pixel
  vec2 fullPx = UCropOrigin + uv * UCropSize;
  vec2 texUV = fullPx / UImgSize;
  texUV.y = 1.0 - texUV.y; // top-left origin
  vec4 base = texture(UImg, texUV);
  vec3 I = base.rgb;

  // Luminance
  float L = dot(I, vec3(0.2126,0.7152,0.0722));

  // Grain cell coordinates
  float gs = max(0.5, grainSize);
  vec2 cell = floor(fullPx/gs);
  vec2 frac = fract(fullPx/gs);

  // Temporal seed affects micro jitter but keeps spatial stability
  float phase = frameSeed * 0.17;

  // Subpixel jitter
  if (subpixel==1) {
    frac += vec2(prng(fullPx+vec2(11.1,7.7)+phase), prng(fullPx+vec2(23.3,19.1)-phase))*0.15;
    frac = fract(frac);
  }

  // Base random fields per channel (independent phases)
  float r1 = noiseCell(cell + vec2(13.0,  5.0), phase);
  float r2 = noiseCell(cell + vec2(-7.0, 19.0), phase*1.31);
  float r3 = noiseCell(cell + vec2(29.0, -3.0), phase*2.07);

  // Convert to Gaussian-ish
  float g1 = (gaussian2(r1, r2)+1.0)*0.5;
  float g2 = (gaussian2(r2, r3)+1.0)*0.5;
  float g3 = (gaussian2(r3, r1)+1.0)*0.5;

  // Periodicity option
  if (periodicity==1){
    float p1 = (sin(cell.x*3.14159)*cos(cell.y*3.14159)*0.5+0.5);
    g1 = mix(g1, p1, 0.8);
    g2 = mix(g2, p1, 0.8);
    g3 = mix(g3, p1, 0.8);
  }

  // Shape mask in the cell
  float mask = shapeMask(frac, shape);

  // Distribution (luma-aware vs uniform)
  float dist = (distribution==0) ? 1.0 : pow((1.0-L), lumBias);

  // Mid-tone visibility curve (sweet-spot)
  float vis = exp(-0.5 * pow((L - midPeak)/max(1e-3, midWidth), 2.0)) * midGain;

  // Apply correlation matrix across channels
  vec3 z = vec3(g1, g2, g3) * mask;
  vec3 N = rgbCorr * z;

  // Contrast and decay shaping
  N = (N - 0.5) * contrast + 0.5;
  N = N * (1.0 - opacityDecay) + opacityDecay * 0.5;

  // Intensity with luma distribution and mid-tone visibility
  N *= intensity * dist * vis;

  // Blend modes
  vec3 B = I;
  if (blendMode==0) B=blendOverlay(I,N);
  else if (blendMode==1) B=blendSoftLight(I,N);
  else if (blendMode==2) B=blendScreen(I,N);
  else if (blendMode==3) B=blendMultiply(I,N);

  vec3 outC = mix(I, B, blendOpacity);
  outC = mix(I, outC, sharpPreserve);

  o = vec4(outC, 1.0);
}\`;

// Simple separable Gaussian blur passes to emulate scanner PSF
const FS_BLUR_H=\`#version 300 es
precision highp float;
in vec2 uv; out vec4 o;
uniform sampler2D UTex;
uniform vec2 texel;     // 1/width, 1/height
uniform float sigma;
vec3 blur5(vec2 off){
  // 5-tap Gaussian approx (normalized): weights ~ [0.06136, 0.24477, 0.38774, 0.24477, 0.06136]
  vec2 dx = vec2(off.x, 0.0);
  vec3 c0 = texture(UTex, uv - 2.0*dx).rgb * 0.06136;
  vec3 c1 = texture(UTex, uv - 1.0*dx).rgb * 0.24477;
  vec3 c2 = texture(UTex, uv).rgb         * 0.38774;
  vec3 c3 = texture(UTex, uv + 1.0*dx).rgb * 0.24477;
  vec3 c4 = texture(UTex, uv + 2.0*dx).rgb * 0.06136;
  return c0+c1+c2+c3+c4;
}
void main(){
  // Scale taps with sigma by stretching texel offset
  float s = max(0.25, sigma);
  vec2 off = vec2(texel.x*s, texel.y);
  vec3 c = blur5(off);
  o = vec4(c,1.0);
}\`;

const FS_BLUR_V=\`#version 300 es
precision highp float;
in vec2 uv; out vec4 o;
uniform sampler2D UTex;
uniform vec2 texel;
uniform float sigma;
vec3 blur5(vec2 off){
  vec2 dy = vec2(0.0, off.y);
  vec3 c0 = texture(UTex, uv - 2.0*dy).rgb * 0.06136;
  vec3 c1 = texture(UTex, uv - 1.0*dy).rgb * 0.24477;
  vec3 c2 = texture(UTex, uv).rgb         * 0.38774;
  vec3 c3 = texture(UTex, uv + 1.0*dy).rgb * 0.24477;
  vec3 c4 = texture(UTex, uv + 2.0*dy).rgb * 0.06136;
  return c0+c1+c2+c3+c4;
}
void main(){
  float s = max(0.25, sigma);
  vec2 off = vec2(texel.x, texel.y*s);
  vec3 c = blur5(off);
  o = vec4(c,1.0);
}\`;

// True copy shader (one fetch)
const FS_COPY=\`#version 300 es
precision highp float;
in vec2 uv; out vec4 o;
uniform sampler2D UTex;
void main(){ o = texture(UTex, uv); }
\`;

function makeProg(vsSrc, fsSrc){
  const vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vsSrc);
  gl.compileShader(vs);
  if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) throw new Error('VS: '+gl.getShaderInfoLog(vs));

  const fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, fsSrc);
  gl.compileShader(fs);
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) throw new Error('FS: '+gl.getShaderInfoLog(fs));

  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error('Link: '+gl.getProgramInfoLog(prog));
  return prog;
}

function initGL(width,height){
  try{
    cvs = new OffscreenCanvas(width,height);
    gl = cvs.getContext('webgl2', {premultipliedAlpha:false});
  }catch(e){}
  if(!gl){ postMessage({type:'cap', ok:false, reason:'no-webgl2'}); return false; }

  const vbo = gl.createBuffer();
  vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);

  progMain = makeProg(VS, FS_MAIN);
  progBlurH = makeProg(VS, FS_BLUR_H);
  progBlurV = makeProg(VS, FS_BLUR_V);
  progCopy = makeProg(VS, FS_COPY);

  // Ping-pong FBOs for blur
  function makeTex(w,h){
    const t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA8,w,h,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
    return t;
  }
  function makeFbo(tex){
    const f = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, f);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    return f;
  }

  texA = makeTex(width,height);
  texB = makeTex(width,height);
  fboA = makeFbo(texA);
  fboB = makeFbo(texB);

  w=width; h=height;
  postMessage({type:'cap', ok:true});
  return true;
}

function resizeTargets(width,height){
  if (!gl){ if(!initGL(width,height)) return; }
  if (width===w && height===h) return;
  cvs.width = width; cvs.height = height; w=width; h=height;

  // Recreate ping-pong textures/framebuffers
  if (texA) gl.deleteTexture(texA);
  if (texB) gl.deleteTexture(texB);
  if (fboA) gl.deleteFramebuffer(fboA);
  if (fboB) gl.deleteFramebuffer(fboB);
  const makeTex = (W,H)=>{ const t=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA8,W,H,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
    return t; };
  const makeFbo = (tex)=>{ const f=gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER,f);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0); return f; };
  texA = makeTex(width,height); texB = makeTex(width,height);
  fboA = makeFbo(texA); fboB = makeFbo(texB);
}

function uploadImage(bmp){
  if (!bmp || bmp.width===0 || bmp.height===0){ postMessage({type:'failed', reason:'Empty image'}); return; }
  if (texIn) gl.deleteTexture(texIn);
  texIn = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texIn);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bmp);
}

function passMain(p){
  gl.bindFramebuffer(gl.FRAMEBUFFER, fboA);
  gl.viewport(0,0,p.targetW,p.targetH);
  gl.useProgram(progMain);
  gl.bindVertexArray(vao);

  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texIn);
  gl.uniform1i(gl.getUniformLocation(progMain,'UImg'),0);

  gl.uniform2f(gl.getUniformLocation(progMain,'UImgSize'), p.imgW, p.imgH);
  gl.uniform2f(gl.getUniformLocation(progMain,'UCropOrigin'), p.cropX, p.cropY);
  gl.uniform2f(gl.getUniformLocation(progMain,'UCropSize'), p.cropW, p.cropH);

  gl.uniform1f(gl.getUniformLocation(progMain,'intensity'), p.intensity);
  gl.uniform1f(gl.getUniformLocation(progMain,'grainSize'), p.grainSize);
  gl.uniform1f(gl.getUniformLocation(progMain,'lumBias'), p.lumBias);
  gl.uniform1f(gl.getUniformLocation(progMain,'contrast'), p.contrast);
  gl.uniform1f(gl.getUniformLocation(progMain,'opacityDecay'), p.opacityDecay);
  gl.uniform1f(gl.getUniformLocation(progMain,'blendOpacity'), p.blendOpacity);
  gl.uniform1f(gl.getUniformLocation(progMain,'sharpPreserve'), p.sharpPreserve);
  gl.uniform1i(gl.getUniformLocation(progMain,'distribution'), p.distribution);
  gl.uniform1i(gl.getUniformLocation(progMain,'shape'), p.shape);
  gl.uniform1i(gl.getUniformLocation(progMain,'periodicity'), p.periodicity);
  gl.uniform1i(gl.getUniformLocation(progMain,'subpixel'), p.subpixel);
  gl.uniform1i(gl.getUniformLocation(progMain,'blendMode'), p.blendMode);

  // Sweet-spot uniforms
  gl.uniformMatrix3fv(gl.getUniformLocation(progMain,'rgbCorr'), false, new Float32Array(p.rgbCorr));
  gl.uniform1f(gl.getUniformLocation(progMain,'midPeak'), p.midPeak);
  gl.uniform1f(gl.getUniformLocation(progMain,'midWidth'), p.midWidth);
  gl.uniform1f(gl.getUniformLocation(progMain,'midGain'), p.midGain);
  gl.uniform1f(gl.getUniformLocation(progMain,'frameSeed'), p.frameSeed);

  gl.clearColor(0.08,0.09,0.12,1); gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

function passBlur(texSrc, fboDst, dir, sigma, W, H){
  const prog = (dir===0)? progBlurH : progBlurV;
  gl.bindFramebuffer(gl.FRAMEBUFFER, fboDst);
  gl.viewport(0,0,W,H);
  gl.useProgram(prog);
  gl.bindVertexArray(vao);
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texSrc);
  gl.uniform1i(gl.getUniformLocation(prog,'UTex'), 0);
  gl.uniform2f(gl.getUniformLocation(prog,'texel'), 1.0/W, 1.0/H);
  gl.uniform1f(gl.getUniformLocation(prog,'sigma'), sigma);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

function draw(p){
  if (!gl || !progMain || !texIn) return null;
  resizeTargets(p.targetW, p.targetH);

  // Pass 1: main grain render to texA
  passMain(p);

  // Optional scanner PSF blur (cheap): texA -> texB (H), texB -> texA (V)
  if (p.psfSigma > 0.05) {
    passBlur(texA, fboB, 0, p.psfSigma, p.targetW, p.targetH);
    passBlur(texB, fboA, 1, p.psfSigma, p.targetW, p.targetH);
  }

  // Read back final (texA) into transfer bitmap
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0,0,p.targetW,p.targetH);

  // True copy
  gl.useProgram(progCopy);
  gl.bindVertexArray(vao);
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texA);
  gl.uniform1i(gl.getUniformLocation(progCopy,'UTex'), 0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  return cvs.transferToImageBitmap();
}

onmessage = async (e)=>{
  const d = e.data;
  if (d.type==='init'){
    try{
      const tmp = new OffscreenCanvas(2,2);
      const gl2 = tmp.getContext('webgl2');
      postMessage({type:'cap', ok: !!gl2, reason: gl2? '':'no-webgl2'});
    }catch(err){
      postMessage({type:'cap', ok:false, reason:'no-offscreen'});
    }
    postMessage({type:'inited'});
  }
  else if (d.type==='image'){
    if (!gl) initGL(d.w||2, d.h||2);
    uploadImage(d.bmp);
    postMessage({type:'image-ok'});
  }
  else if (d.type==='render'){
    try{
      const out = draw(d.p);
      if (!out){ postMessage({type:'failed', reason:'Draw failed'}); return; }
      postMessage({type:'done', bmp: out, task: d.task}, [out]);
    }catch(err){
      postMessage({type:'failed', reason: String(err)});
    }
  }
};
`;

// Boot worker
function bootWorker(){
  const blob = new Blob([workerCode], {type:'application/javascript'});
  worker = new Worker(URL.createObjectURL(blob), { type:'module' });
  worker.onmessage = (e)=>{
    const d = e.data;
    if (d.type==='inited'){ setStatus('Ready'); }
    else if (d.type==='cap'){ hasWorkerGL = d.ok; setEnv(d.ok? 'Worker: WebGL2 OK' : 'Worker: No WebGL2 ('+d.reason+')'); }
    else if (d.type==='image-ok'){
      setStatus('Image uploaded'); scheduleRender(true); updateMini(); drawGuide();
    }
    else if (d.type==='done'){
      if (d.task !== lastTask) return;
      setStatus('Done');

      // Draw main crop
      vctx.clearRect(0,0,view.width,view.height);
      vctx.drawImage(d.bmp, 0, 0);

      // Add tiny flare in 2D (cheaper than another worker pass)
      if (params.flare > 0.0001){
        vctx.save();
        vctx.globalCompositeOperation = 'screen';
        vctx.globalAlpha = params.flare;
        vctx.fillStyle = '#ffffff';
        vctx.fillRect(0,0,view.width,view.height);
        vctx.restore();
      }

      // Draw dimmed global context (preview-only)
      if (imgFull){
        vctx.save();
        vctx.globalAlpha = 0.10;
        const scale = Math.min(view.width/fullW, view.height/fullH);
        const dw = Math.round(fullW*scale), dh = Math.round(fullH*scale);
        const dx = Math.round((view.width - dw)/2), dy = Math.round((view.height - dh)/2);
        if (!window._ctxPreview || window._ctxPreview.width!==dw || window._ctxPreview.height!==dh){
          const c = document.createElement('canvas'); c.width=dw; c.height=dh;
          const c2 = c.getContext('2d');
          c2.drawImage(imgFull, 0, 0, dw, dh);
          window._ctxPreview = c;
        }
        vctx.drawImage(window._ctxPreview, dx, dy);
        vctx.globalAlpha = 1.0;
        vctx.restore();
        vctx.drawImage(d.bmp, 0, 0); // draw crop on top; do NOT clear
      }
    }
    else if (d.type==='failed'){
      setStatus('Worker error: '+d.reason);
      console.warn('[Worker failed]', d.reason);
    }
  };
  worker.postMessage({type:'init'});
}
bootWorker();

// -------------------- Param packing --------------------
function packParams(){
  // Push/pull scaling for σ and mid visibility (rough heuristic)
  const push = params.pushStops|0;
  const pushGain = 1.0 + 0.25 * push; // +25% per stop
  const midGain = params.midGain * pushGain;
  const rgbCorr = params.rgbCorr;

  return {
    imgW: fullW, imgH: fullH,
    cropX, cropY, cropW, cropH,
    intensity: params.intensity,
    grainSize: params.grainSize,
    distribution: (params.distribution==='uniform'?0:1),
    shape: (params.shape==='square'?0 : params.shape==='circle'?1:2),
    periodicity: (params.periodicity==='regular'?1:0),
    subpixel: (params.subpixel==='on'?1:0),
    lumBias: params.lumBias,
    contrast: params.contrast,
    opacityDecay: params.opacityDecay,
    blendMode: (params.blendMode==='overlay'?0: params.blendMode==='softlight'?1: params.blendMode==='screen'?2:3),
    blendOpacity: params.blendOpacity,
    sharpPreserve: params.sharpPreserve,
    targetW: cropW, targetH: cropH,

    // sweet-spot extras
    rgbCorr,
    midPeak: params.midPeak,
    midWidth: params.midWidth,
    midGain,
    frameSeed: params.frameSeed,
    psfSigma: params.psfSigma
  };
}

function scheduleRender(force=false){
  if(!imgFull) return;
  if(!hasWorkerGL){ renderFallback2D(); return; }
  if (!force && rafPending) return;
  rafPending = true;
  requestAnimationFrame(()=>{ rafPending=false; render(); });
}
function render(){
  const p = packParams();
  lastTask++;
  setStatus('Rendering…');
  worker.postMessage({ type:'render', p, task:lastTask });
}

// Simple main-thread 2D fallback so Safari/iOS shows *something*
function renderFallback2D(){
  const sx = cropX, sy = cropY, sw = cropW, sh = cropH;
  vctx.clearRect(0,0,view.width,view.height);
  vctx.drawImage(imgFull, sx, sy, sw, sh, 0, 0, view.width, view.height);
  setStatus('Preview (no WebGL2/worker)');
}

// -------------------- Crop and canvas --------------------
function clampCrop(){
  if (!fullW || !fullH) return;
  cropW = Math.min(cropW, fullW);
  cropH = Math.min(cropH, fullH);
  cropX = Math.max(0, Math.min(cropX, fullW - cropW));
  cropY = Math.max(0, Math.min(cropY, fullH - cropH));
}

function computeCanvasSizeFromMax(maxD){ return { w: maxD, h: Math.round(maxD*9/16) }; }

// -------------------- Load image --------------------
$$('file').addEventListener('change', async (e)=>{
  const f = e.target.files[0]; if(!f) return;
  const blobURL = URL.createObjectURL(f);
  imgFull = await createImageBitmap(f);
  URL.revokeObjectURL(blobURL);
  fullW = imgFull.width; fullH = imgFull.height;
  window._ctxPreview = null; // reset preview cache

  const up = await createImageBitmap(imgFull);
  worker.postMessage({type:'image', bmp: up, w: view.width, h: view.height}, [up]);

  cropW = view.width; cropH = view.height;
  cropX = Math.max(0, Math.floor((fullW - cropW)/2));
  cropY = Math.max(0, Math.floor((fullH - cropH)/2));
  clampCrop();
  updateMini();
  scheduleRender(true);
});

// -------------------- Canvas size selector --------------------
$$('previewSize').addEventListener('change', ()=>{
  const maxD = parseInt($$('previewSize').value,10);
  const {w,h} = computeCanvasSizeFromMax(maxD);
  view.width = w; view.height = h;
  cropW = w; cropH = h; clampCrop();
  updateMini();
  scheduleRender(true);
});

// -------------------- Controls --------------------
function bindRange(id, key, vid, precision=2){
  const r=$$(id), v=$$(vid);
  const upd=()=>{ params[key]=parseFloat(r.value); v.textContent=Number(r.value).toFixed(precision); scheduleRender(); };
  r.addEventListener('input', upd); r.addEventListener('change', upd); v.textContent=Number(r.value).toFixed(precision);
}
function bindSelect(id, setter){
  const s=$$(id); s.addEventListener('change', ()=>{ setter(s.value); scheduleRender(); });
}
bindRange('intensity','intensity','vIntensity',2);
bindRange('grainSize','grainSize','vGrainSize',1);
bindSelect('distribution', v=>params.distribution=v);
bindSelect('shape', v=>params.shape=v);
bindSelect('periodicity', v=>params.periodicity=v);
bindSelect('subpixel', v=>params.subpixel=v);
bindRange('lumBias','lumBias','vLumBias',2);
bindRange('contrast','contrast','vContrast',2);
bindRange('opacityDecay','opacityDecay','vOpacityDecay',2);
bindSelect('blendMode', v=>params.blendMode=v);
bindRange('blendOpacity','blendOpacity','vBlendOpacity',2);
bindRange('sharpPreserve','sharpPreserve','vSharpPreserve',2);

// Stock + push/pull
$$('stock').addEventListener('change', ()=>{
  const v = $$('stock').value;
  if (v==='custom') return;
  const s = STOCKS[v];
  if (!s) return;
  params.mu = s.mu; params.sigma = s.sigma;
  params.rgbCorr = s.rgbCorr.slice();
  params.midPeak = s.midPeak; params.midWidth = s.midWidth; params.midGain = s.midGain;
  scheduleRender(true);
});
$$('push').addEventListener('change', ()=>{
  params.pushStops = parseInt($$('push').value,10) || 0;
  scheduleRender(true);
});

// Presets (original)
function syncUI(){
  $$('intensity').value=params.intensity; $$('vIntensity').textContent=fmt(params.intensity);
  $$('grainSize').value=params.grainSize; $$('vGrainSize').textContent=fmt(params.grainSize,1);
  $$('distribution').value=params.distribution; $$('shape').value=params.shape;
  $$('periodicity').value=params.periodicity; $$('subpixel').value=params.subpixel;
  $$('lumBias').value=params.lumBias; $$('vLumBias').textContent=fmt(params.lumBias);
  $$('contrast').value=params.contrast; $$('vContrast').textContent=fmt(params.contrast);
  $$('opacityDecay').value=params.opacityDecay; $$('vOpacityDecay').textContent=fmt(params.opacityDecay);
  $$('blendMode').value=params.blendMode; $$('blendOpacity').value=params.blendOpacity; $$('vBlendOpacity').textContent=fmt(params.blendOpacity);
  $$('sharpPreserve').value=params.sharpPreserve; $$('vSharpPreserve').textContent=fmt(params.sharpPreserve);
}
$$('presetVintage').addEventListener('click', ()=>{
  Object.assign(params, {
    intensity:0.82, grainSize:3.4, distribution:'dynamic', shape:'irregular',
    periodicity:'random', subpixel:'on', lumBias:0.72, contrast:1.25, opacityDecay:0.42,
    blendMode:'softlight', blendOpacity:0.64, sharpPreserve:0.6
  }); syncUI(); scheduleRender(true);
});
$$('presetMinimal').addEventListener('click', ()=>{
  Object.assign(params, {
    intensity:0.28, grainSize:1.2, distribution:'uniform', shape:'circle',
    periodicity:'random', subpixel:'off', lumBias:0.5, contrast:1.0, opacityDecay:0.2,
    blendMode:'overlay', blendOpacity:0.35, sharpPreserve:0.85
  }); syncUI(); scheduleRender(true);
});
$$('presetGrit').addEventListener('click', ()=>{
  Object.assign(params, {
    intensity:0.9, grainSize:2.8, distribution:'dynamic', shape:'square',
    periodicity:'regular', subpixel:'on', lumBias:0.65, contrast:1.35, opacityDecay:0.25,
    blendMode:'multiply', blendOpacity:0.55, sharpPreserve:0.72
  }); syncUI(); scheduleRender(true);
});

// -------------------- Export full-res --------------------
$$('exportFull').addEventListener('click', async ()=>{
  if (!imgFull){ setStatus('Load an image first'); return; }
  setStatus('Exporting full-res…');

  const blob = new Blob([workerCode], {type:'application/javascript'});
  const w2 = new Worker(URL.createObjectURL(blob), { type:'module' });

  let timeout = setTimeout(()=>{
    setStatus('Export timeout — browser may block WebGL2 in workers');
    try{ w2.terminate(); }catch(_){ }
  }, 30000);

  w2.onmessage = async (e)=>{
    const d=e.data;
    if (d.type==='cap'){
      if(!d.ok){ clearTimeout(timeout); setStatus('Full-res failed (no WebGL2 in worker)'); w2.terminate(); return; }
      const bmp = await createImageBitmap(imgFull);
      w2.postMessage({type:'image', bmp, w: fullW, h: fullH}, [bmp]);
    }
    else if (d.type==='image-ok'){
      const p = {
        imgW: fullW, imgH: fullH,
        cropX:0, cropY:0, cropW:fullW, cropH:fullH,
        intensity: params.intensity,
        grainSize: params.grainSize,
        distribution: (params.distribution==='uniform'?0:1),
        shape: (params.shape==='square'?0 : params.shape==='circle'?1:2),
        periodicity: (params.periodicity==='regular'?1:0),
        subpixel: (params.subpixel==='on'?1:0),
        lumBias: params.lumBias,
        contrast: params.contrast,
        opacityDecay: params.opacityDecay,
        blendMode: (params.blendMode==='overlay'?0: params.blendMode==='softlight'?1: params.blendMode==='screen'?2:3),
        blendOpacity: params.blendOpacity,
        sharpPreserve: params.sharpPreserve,
        targetW: fullW, targetH: fullH,
        // sweet-spot extras
        rgbCorr: params.rgbCorr,
        midPeak: params.midPeak,
        midWidth: params.midWidth,
        midGain: params.midGain * (1.0 + 0.25*(params.pushStops|0)),
        frameSeed: params.frameSeed,
        psfSigma: params.psfSigma
      };
      w2.postMessage({ type:'render', p, task:1 });
    }
    else if (d.type==='done'){
      clearTimeout(timeout);
      setStatus('Saving…');
      const outBmp = d.bmp;
      const canvas = document.createElement('canvas');
      canvas.width = outBmp.width; canvas.height = outBmp.height;
      const c2d = canvas.getContext('2d');
      c2d.drawImage(outBmp,0,0);

      // Apply tiny flare in 2D for export too
      if (params.flare > 0.0001){
        c2d.globalCompositeOperation = 'screen';
        c2d.globalAlpha = params.flare;
        c2d.fillStyle = '#ffffff';
        c2d.fillRect(0,0,canvas.width,canvas.height);
      }

      // Prefer async blob over DataURL to avoid blocking big images
      canvas.toBlob((blob)=>{
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'grainlab.png';
        a.click();
        setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
      }, 'image/png');

      setStatus('Full-res done');
      w2.terminate();
    }
    else if (d.type==='failed'){
      clearTimeout(timeout);
      setStatus('Export failed: '+d.reason);
      w2.terminate();
    }
  };

  w2.postMessage({type:'init'});
});

// -------------------- Mini‑map --------------------
const mini = $$('mini');
const miniBox = $$('miniBox');
let isDraggingMini = false;
let miniScale = 1, miniW = 0, miniH = 0, miniOffsetX = 0, miniOffsetY = 0;

function updateMini(){
  if (!fullW || !fullH) return;
  const rect = mini.getBoundingClientRect();
  const w = rect.width, h = rect.height;
  const s = Math.min(w/fullW, h/fullH);
  miniScale = s; miniW = fullW*s; miniH = fullH*s;
  miniOffsetX = (w-miniW)*0.5; miniOffsetY = (h-miniH)*0.5;

  const bx = miniOffsetX + cropX*s;
  const by = miniOffsetY + cropY*s;
  const bw = cropW*s;
  const bh = cropH*s;

  miniBox.style.left = bx+'px';
  miniBox.style.top  = by+'px';
  miniBox.style.width  = bw+'px';
  miniBox.style.height = bh+'px';
}

mini.addEventListener('mousedown', (ev)=>{
  isDraggingMini = true; moveMini(ev);
});
window.addEventListener('mousemove', (ev)=>{ if(isDraggingMini) moveMini(ev); });
window.addEventListener('mouseup', ()=>{ isDraggingMini=false; });

// Touch support
mini.addEventListener('touchstart', (e)=>{ isDraggingMini=true; moveMini(e.touches[0]); e.preventDefault(); }, {passive:false});
mini.addEventListener('touchmove',  (e)=>{ if(isDraggingMini) moveMini(e.touches[0]); e.preventDefault(); }, {passive:false});
window.addEventListener('touchend', ()=>{ isDraggingMini=false; });

function moveMini(ev){
  const r = mini.getBoundingClientRect();
  const mx = ev.clientX - r.left;
  const my = ev.clientY - r.top;

  let cx = (mx - miniOffsetX) / miniScale - cropW / 2;
  let cy = (miniOffsetY + miniH - my) / miniScale - cropH / 2; // invert Y for intuitive mapping

  cx = Math.max(0, Math.min(cx, fullW - cropW));
  cy = Math.max(0, Math.min(cy, fullH - cropH));

  cropX = Math.round(cx);
  cropY = Math.round(cy);

  updateMini();
  scheduleRender();
}

// -------------------- Drag-to-pan on main canvas --------------------
let isPanning = false, panStartX=0, panStartY=0, panStartCropX=0, panStartCropY=0;
view.addEventListener('mousedown', (e)=>{
  if (!fullW) return;
  isPanning = true;
  panStartX = e.clientX; panStartY = e.clientY;
  panStartCropX = cropX; panStartCropY = cropY;
  hideGuide();
});
window.addEventListener('mousemove', (e)=>{
  if (!isPanning) return;
  const dx = e.clientX - panStartX;
  const dy = e.clientY - panStartY;
  cropX = panStartCropX - dx; // drag right -> cropX decreases
  cropY = panStartCropY + dy; // drag down -> move down
  clampCrop();
  updateMini();
  scheduleRender();
});
window.addEventListener('mouseup', ()=>{ isPanning=false; });

// Touch panning
view.addEventListener('touchstart', (e)=>{
  if (!fullW) return;
  isPanning = true; const t = e.touches[0];
  panStartX=t.clientX; panStartY=t.clientY; panStartCropX=cropX; panStartCropY=cropY; hideGuide();
}, {passive:true});
window.addEventListener('touchmove', (e)=>{
  if (!isPanning) return;
  const t = e.touches[0]; const dx=t.clientX-panStartX, dy=t.clientY-panStartY;
  cropX = panStartCropX - dx; cropY = panStartCropY + dy; clampCrop(); updateMini(); scheduleRender();
}, {passive:true});
window.addEventListener('touchend', ()=>{ isPanning=false; });

// -------------------- Guide overlay --------------------
function drawGuide(){
  const g = $$('guide');
  g.style.opacity = '1';
  setTimeout(()=>{ g.style.opacity='0'; }, 2500);
}
function hideGuide(){ $$('guide').style.opacity='0'; }

// Keep mini-map in sync on resize
window.addEventListener('resize', ()=>{ updateMini(); });

// -------------------- Init canvas --------------------
(function initCanvas(){
  const {w,h} = computeCanvasSizeFromMax(parseInt($$('previewSize').value,10));
  view.width=w; view.height=h;
  cropW=w; cropH=h;
  vctx.fillStyle='#0d1118'; vctx.fillRect(0,0,view.width,view.height);
  setStatus('Drop an image');
})();
</script>
</body>
</html>
