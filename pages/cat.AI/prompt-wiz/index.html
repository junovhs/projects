<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prompt Engineer – Color-coded Mad Libs</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Noto+Sans:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
:root {
  --bg: #ffffff; --fg: #111111; --muted: #6b7280; --border: #e5e7eb; --ring: #111111; --hl-bg: #f8fafc;
  --c-lighting: #1f2937; --c-mood: #7c3aed; --c-subject: #047857; --c-style: #2563eb; --c-composition: #b45309; --c-effects: #be185d;
}
* { box-sizing: border-box; }
body { background: var(--bg); color: var(--fg); font-family: "Noto Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; line-height: 1.5; margin: 0; }
.site-header { padding: 32px 20px 12px; border-bottom: 1px solid var(--border); }
.site-header h1 { font-family: "Space Mono", monospace; margin: 0 0 6px; font-size: 28px; }
.tagline { margin: 0; color: var(--muted); }

.layout { max-width: 1100px; margin: 0 auto; padding: 20px; display: grid; gap: 20px; }
.controls { display: flex; gap: 10px; align-items: center; }
button { border: 1px solid var(--border); background: #fff; color: var(--fg); padding: 10px 14px; border-radius: 12px; font: inherit; cursor: pointer; transition: transform .06s ease, box-shadow .12s ease; }
button.primary { background: var(--fg); color: #fff; border-color: var(--fg); }
button.ghost { background: transparent; }
button.discreet { padding: 6px 10px; border-radius: 10px; font-size: 12px; }
button:hover { box-shadow: 0 6px 16px rgba(0,0,0,0.08); }

.prompt-list { display: grid; gap: 16px; }

/* Prompt Card */
.prompt-card {
  border: 1px solid var(--border); border-radius: 14px; background: #fff; padding: 12px;
  display: grid; grid-template-columns: 1fr; /* single column layout */
  gap: 12px; position: relative;
}
.card-head { display: flex; justify-content: space-between; align-items: center; padding: 4px 4px 2px; }
.card-actions { display: flex; gap: 8px; align-items: center; }
.card-title { font-size: 14px; color: var(--muted); margin: 0; }

.copy-rail { grid-column: 2 / 3; grid-row: 1 / 4; display: flex; }
.copy-btn {
  background: #111; color: #fff; border: 1px solid #111; border-radius: 12px;
  width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;
}
.copy-btn span { display: block; line-height: 1; font-weight: 700; text-transform: uppercase; letter-spacing: 0.06em; }

.card-body { grid-column: 1 / 2; display: grid; gap: 10px; }

/* Text input */
textarea.prompt-input { width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 10px; font: inherit; resize: vertical; background: var(--bg); color: var(--fg); }

/* Highlight container */
.highlight-view {
  border: 1px dashed var(--border); border-radius: 12px; padding: 14px; min-height: 100px; background: var(--hl-bg);
  white-space: pre-wrap; user-select: none; cursor: text; /* whole-word selection only */
}

/* Category highlight chip look */
.highlight { position: relative; padding: 1px 3px; border-radius: 6px; cursor: help; white-space: pre-wrap; }

/* Locked highlight look */
.highlight.locked { opacity: .5; font-style: italic; background: transparent !important; box-shadow: none !important; }

/* Swap panel */
.swap-panel { display: block; } /* full-width stack, not grid */
.swap-card { border: 1px solid var(--border); border-radius: 12px; padding: 10px; background: #fff; }
.swap-card h3 { display: flex; align-items: center; gap: 8px; margin: 0 0 8px; font-size: 13px; }
.swap-card .dot { width: 10px; height: 10px; border-radius: 999px; }
.swap-item { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin-bottom: 8px; }
.swap-item label { font-size: 12px; color: var(--muted); }
.swap-item .right { display: flex; align-items: center; gap: 8px; }
.swap-item input { padding: 8px; border: 1px solid var(--border); border-radius: 8px; font: inherit; min-width: 120px; }
.swap-item button.x { border-radius: 8px; padding: 6px 8px; font-size: 12px; }

/* Word selection (file-picker style) */
.highlight-view .word { padding: 0 2px; border-radius: 4px; }
.highlight-view .word.selected { background: rgba(17,17,17,.08); box-shadow: inset 0 -2px 0 0 var(--ring); }

/* Tag bubble (chip cloud + custom category + lock) */
.floating-tag {
  position: absolute; z-index: 10; background: #fff; border: 1px solid var(--border); border-radius: 10px;
  padding: 10px; display: grid; gap: 10px; align-items: start; box-shadow: 0 8px 24px rgba(0,0,0,.08); min-width: 300px;
}
.floating-tag .sel { font-size: 12px; color: var(--muted); }
.floating-tag .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
.tag-chip { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border: 1px solid var(--border); border-radius: 999px; background: #fff; font-size: 12px; cursor: pointer; }
.tag-chip .dot { width: 10px; height: 10px; border-radius: 999px; }

.site-footer { padding: 16px 20px 40px; color: var(--muted); text-align: center; border-top: 1px solid var(--border); }
  </style>
</head>
<body>
  <header class="site-header">
    <h1>Prompt Engineer</h1>
    <p class="tagline">Color-coded Mad Libs for image prompt crafting</p>
  </header>

  <main class="layout">
    <section class="controls">
      <button id="addPrompt" class="primary">+ Add New Prompt</button>
    </section>

    <section class="prompt-list" id="promptList"></section>
  </main>

  <footer class="site-footer">
    <p>Tip: Click/drag to select words. Shift = range, Ctrl/⌘ = toggle. Tag via chips or create a custom category. "Lock selection" makes the phrase italic + 50% opacity and immune to swaps.</p>
  </footer>

  <script type="module">
/* =========================
   Category Registry (shared)
   ========================= */
const baseCategories = [
  { key: "Lighting",    color: cssVar("--c-lighting") },
  { key: "Mood",        color: cssVar("--c-mood") },
  { key: "Style",       color: cssVar("--c-style") },
  { key: "Composition", color: cssVar("--c-composition") },
  { key: "Effects",     color: cssVar("--c-effects") },
  { key: "Subject",     color: cssVar("--c-subject") }
];
// mutable registry: {key -> color}
const categoryRegistry = new Map(baseCategories.map(c=>[c.key, c.color]));
const colorPalette = [
  "#2563eb","#7c3aed","#047857","#b45309","#be185d","#10b981","#ef4444","#0ea5e9","#9333ea","#059669",
  "#f59e0b","#1d4ed8","#dc2626","#d946ef","#16a34a","#22c55e"
];
function ensureCategory(key){
  if (categoryRegistry.has(key)) return categoryRegistry.get(key);
  const used = new Set([...categoryRegistry.values()]);
  const next = colorPalette.find(c=>!used.has(c)) || hslFromString(key);
  categoryRegistry.set(key, next);
  return next;
}
function hslFromString(s){
  let h=0; for(let i=0;i<s.length;i++){ h=(h*37 + s.charCodeAt(i))%360; }
  return `hsl(${h}deg 70% 40%)`;
}
function cssVar(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || "#111111";
}
function rgba(c, a){
  if(/^#([0-9a-f]{6})$/i.test(c)){
    const r=parseInt(c.slice(1,3),16), g=parseInt(c.slice(3,5),16), b=parseInt(c.slice(5,7),16);
    return `rgba(${r},${g},${b},${a})`;
  }
  return c;
}

/* =========================
   Prompt Card Component
   ========================= */
class PromptCard {
  constructor(listEl, initialText="") {
    this.root = document.createElement("article");
    this.root.className = "prompt-card";

    // Header
    const head = document.createElement("div");
    head.className = "card-head";
    const title = document.createElement("h3");
    title.className = "card-title";
    title.textContent = "Interactive Highlight (Manual)";
    const actions = document.createElement("div");
    actions.className = "card-actions";

    this.btnEdit = document.createElement("button");
    this.btnEdit.className = "discreet";
    this.btnEdit.textContent = "Edit";

    this.btnExport = document.createElement("button");
    this.btnExport.className = "discreet";
    this.btnExport.textContent = "Export JSON";

    this.btnCopy = document.createElement("button");
    this.btnCopy.className = "discreet";
    this.btnCopy.textContent = "Copy Prompt";
    this.btnCopy.title = "Copy current prompt";

    this.btnRemove = document.createElement("button");
    this.btnRemove.className = "discreet";
    this.btnRemove.textContent = "✕";

    actions.append(this.btnEdit, this.btnCopy, this.btnExport, this.btnRemove);
    head.append(title, actions);

    // Body (grid: main + copy rail)
    const body = document.createElement("div");
    body.className = "card-body";

    this.textarea = document.createElement("textarea");
    this.textarea.className = "prompt-input";
    this.textarea.rows = 8;
    this.textarea.placeholder = "Paste your prompt here…";
    this.textarea.value = initialText;

    this.highlightView = document.createElement("div");
    this.highlightView.className = "highlight-view";
    this.highlightView.setAttribute("aria-live","polite");

    this.swapPanel = document.createElement("div");
    this.swapPanel.className = "swap-panel";

    // Copy rail (full height)
    // const rail = document.createElement("div");
    // rail.className = "copy-rail";
    // this.btnCopy = document.createElement("button");
    // this.btnCopy.className = "copy-btn";
    // this.btnCopy.innerHTML = `<span>Copy</span><span>Prompt</span>`;
    // rail.append(this.btnCopy);

    // Assemble
    body.append(this.textarea, this.highlightView, this.swapPanel);
    this.root.append(head, body);
    listEl.appendChild(this.root);

    // State
    this.originalPrompt = initialText.trim();
    this.foundByCategory = new Map();   // cat -> Set<string>
    this.replacements = new Map();      // term -> replacement
    this.lockedSections = new Set();    // Set<string>
    // Selection state
    this.wordElems = [];
    this.selectedWordIdxs = new Set();
    this.anchorWordIdx = null;
    this.dragState = { active:false, start:null, additive:false, base:new Set() };
    this.selectionDirty=false;

    // Bubble
    this.activeBubbleEl = null;
    this.bubbleOutsideListener = null;
    this.bubbleGuard = false;

    // Wire up events
    this.textarea.addEventListener("input", debounce(()=>{
      this.runParse();
      if (this.isEditing && (this.textarea.value||"").trim().length) {
        this.isEditing = false; this.updateEditUI();
      }
    },300));
    this.btnEdit.addEventListener("click", ()=>this.toggleEdit());
    this.btnCopy.addEventListener("click", ()=>this.copyPrompt());
    this.btnRemove.addEventListener("click", ()=>this.remove());
    this.btnExport.addEventListener("click", ()=>this.exportJSON());

    this.attachWordSelectionHandlers();
    // Start in edit mode to paste text for a new prompt
    this.isEditing = true;
    this.updateEditUI();
    this.runParse();
  }

  /* ---------- Core Flow ---------- */
  runParse(){
    this.originalPrompt = (this.textarea.value||"").trim();
    this.renderSwapPanel();
    this.renderPreview();
  }

  renderPreview(){
    const remixed = this.applyReplacements(this.originalPrompt);
    const previewCat = new Map();
    for (const [cat,set] of this.foundByCategory.entries()){
      previewCat.set(cat, new Set(set));
    }
    for (const [term, repl] of this.replacements.entries()){
      for (const set of previewCat.values()){ if (set.has(term)) set.add(repl); }
    }
    this.renderDOM(remixed, previewCat);
  }

  renderDOM(text, foundMap){
    // clear selection on each render
    this.selectedWordIdxs.clear();
    this.anchorWordIdx = null;

    const segments = this.buildHighlightSpans(text, foundMap);
    this.highlightView.innerHTML = "";

    const { fragment, words } = this.tokenizeSegmentsToWords(segments);
    this.highlightView.appendChild(fragment);

    this.wordElems = words;
    this.updateWordSelectionClasses();
  }

  applyReplacements(text){
    // protect locked sections
    const placeholders=[];
    let out=text;
    Array.from(this.lockedSections).forEach((lock,i)=>{
      const token=`__LOCK_${i}__`;
      placeholders.push({token,lock});
      out=out.replace(new RegExp(escapeRegExp(lock),"g"),token);
    });
    // longest-first replacements
    const terms=[...this.replacements.keys()].sort((a,b)=>b.length-a.length);
    for(const t of terms){
      const repl=this.replacements.get(t);
      const re=new RegExp(`\\b${escapeRegExp(t)}\\b`,"gi");
      out=out.replace(re,match=>{
        if(/^[A-Z][a-z]/.test(match)) return toTitleCase(repl);
        if(match===match.toUpperCase()) return repl.toUpperCase();
        if(match===match.toLowerCase()) return repl.toLowerCase();
        return repl;
      });
    }
    placeholders.forEach(({token,lock})=>{ out=out.replace(new RegExp(token,"g"),lock); });
    return out;
  }

  /* ---------- Rendering Helpers ---------- */
  buildHighlightSpans(text, foundMap){
    // Build locked intervals first
    const lockedMatches = [];
    for (const term of this.lockedSections){
      if (!term) continue;
      // For locked sections, do exact string matching without word boundaries
      // since they can contain punctuation
      const escapedTerm = escapeRegExp(term).replace(/\s+/g, '\\s*');
      const re = new RegExp(escapedTerm, "gi");
      let m; while((m=re.exec(text))!==null){
        lockedMatches.push({ start:m.index, end:m.index+m[0].length, category:"__LOCKED__", locked:true, len:m[0].length });
      }
    }

    // Build category matches
    const catMatches = [];
    for (const [cat,set] of foundMap.entries()){
      for (const term of set){
        if(!term) continue;
        const escapedTerm = escapeRegExp(term).replace(/\s+/g, '\\s+');
        const re=new RegExp(escapedTerm,"gi");
        let m; while((m=re.exec(text))!==null){
          catMatches.push({ start:m.index, end:m.index+m[0].length, category:cat, locked:false, len:m[0].length });
        }
      }
    }

    // Remove any category matches that overlap a locked interval (locked wins)
    const overlaps = (a,b)=> a.start < b.end && b.start < a.end;
    const filteredCat = catMatches.filter(m => !lockedMatches.some(L => overlaps(m,L)));

    // Combine and pick non-overlapping
    const all = lockedMatches.concat(filteredCat);
    all.sort((a,b)=> a.start - b.start || b.len - a.len);

    const picked=[]; let lastEnd=-1;
    for(const m of all){
      if(m.start>=lastEnd){ picked.push(m); lastEnd=m.end; }
    }

    // Build nodes (simple span carriers; tokenization will restyle)
    const nodes=[]; let cursor=0;
    for(const m of picked){
      if(cursor<m.start) nodes.push(document.createTextNode(text.slice(cursor,m.start)));
      const span=document.createElement("span");
      span.className="highlight" + (m.locked ? " locked" : "");
      span.dataset.category=m.category;
      span.textContent=text.slice(m.start,m.end);
      nodes.push(span);
      cursor=m.end;
    }
    if(cursor<text.length) nodes.push(document.createTextNode(text.slice(cursor)));
    return nodes;
  }

  tokenizeSegmentsToWords(segments){
    const frag = document.createDocumentFragment();
    const words = [];
    let idxCounter = 0;

    const makeWord = (segment) => {
      const w = document.createElement("span");
      w.className = "word";
      w.dataset.idx = idxCounter++;
      w.textContent = segment;
      words.push(w);
      return w;
    };

    const processInto = (parent, text) => {
      if (!text) return;
      if (typeof Intl !== "undefined" && "Segmenter" in Intl) {
        const seg = new Intl.Segmenter(undefined, { granularity: "word" });
        for (const { segment, isWordLike } of seg.segment(text)) {
          parent.appendChild(isWordLike ? makeWord(segment) : document.createTextNode(segment));
        }
      } else {
        const re = /([\p{L}\p{M}\p{N}]+(?:['’\-][\p{L}\p{M}\p{N}]+)*)/gu;
        let last = 0, m;
        while ((m = re.exec(text))) {
          if (m.index > last) parent.appendChild(document.createTextNode(text.slice(last, m.index)));
          parent.appendChild(makeWord(m[1]));
          last = re.lastIndex;
        }
        if (last < text.length) parent.appendChild(document.createTextNode(text.slice(last)));
      }
    };

    segments.forEach(node => {
      if (node.nodeType === Node.TEXT_NODE) {
        processInto(frag, node.nodeValue);
      } else if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains("highlight")) {
        const h = document.createElement("span");
        h.className = node.className;
        h.dataset.category = node.dataset.category || "";
        if (!h.classList.contains("locked") && h.dataset.category) {
          const c = ensureCategory(h.dataset.category);
          h.style.background = rgba(c, 0.08);
          h.style.boxShadow = `inset 0 -2px 0 0 ${c}`;
        }
        processInto(h, node.textContent);
        frag.appendChild(h);
      }
    });

    return { fragment: frag, words };
  }

  /* ---------- Word Selection ---------- */
  attachWordSelectionHandlers(){
    // mousedown: start
    this.highlightView.addEventListener("mousedown", (e) => {
      const w = e.target.closest(".word");
      const additive = e.ctrlKey || e.metaKey;
      const shift = e.shiftKey;

      if (!w) {
        if (!additive) {
          this.selectedWordIdxs.clear();
          this.updateWordSelectionClasses();
          this.removeTagBubble();
        }
        return;
      }

      e.preventDefault();
      const idx = +w.dataset.idx;
      this.selectionDirty = true;

      this.dragState.active   = true;
      this.dragState.start    = idx;
      this.dragState.additive = additive;
      this.dragState.base     = new Set(this.selectedWordIdxs);

      if (shift && this.anchorWordIdx !== null) {
        this.selectRange(this.anchorWordIdx, idx, additive);
      } else if (additive) {
        this.toggleIdx(idx);
        this.anchorWordIdx = idx;
      } else {
        this.selectedWordIdxs.clear();
        this.selectedWordIdxs.add(idx);
        this.anchorWordIdx = idx;
      }
      this.updateWordSelectionClasses();
    });

    // drag across
    this.highlightView.addEventListener("mouseover", (e) => {
      if (!this.dragState.active) return;
      const w = e.target.closest(".word");
      if (!w) return;
      const idx = +w.dataset.idx;
      const range = this.buildRangeSet(this.dragState.start, idx);
      this.selectedWordIdxs = this.dragState.additive ? this.unionSets(this.dragState.base, range) : range;
      this.updateWordSelectionClasses();
    });

    // mouse up: end + show bubble
    document.addEventListener("mouseup", (e) => {
      if (this.dragState.active) this.dragState.active = false;
      if (!this.selectionDirty) return;
      this.selectionDirty = false;
      if (this.activeBubbleEl && this.activeBubbleEl.contains(e.target)) return;
      this.maybeShowTagBubble();
    });

    // anchor update
    this.highlightView.addEventListener("click", (e) => {
      const w = e.target.closest(".word");
      if (w) this.anchorWordIdx = +w.dataset.idx;
    });

    // keyboard helpers
    this.root.addEventListener("keydown",(e)=>{
      if (e.key.toLowerCase() === 't') { e.preventDefault(); this.maybeShowTagBubble(); }
      if (e.key === 'Escape') this.removeTagBubble();
    });
  }

  toggleIdx(i){ this.selectedWordIdxs.has(i) ? this.selectedWordIdxs.delete(i) : this.selectedWordIdxs.add(i); }
  buildRangeSet(a,b){ const s=new Set(); const [lo,hi]=a<=b?[a,b]:[b,a]; for(let i=lo;i<=hi;i++) s.add(i); return s; }
  unionSets(a,b){ const s=new Set(a); for(const x of b) s.add(x); return s; }
  updateWordSelectionClasses(){ this.wordElems.forEach((el,i)=>el.classList.toggle("selected", this.selectedWordIdxs.has(i))); }
  selectRange(a,b,add){ const r=this.buildRangeSet(a,b); this.selectedWordIdxs = add ? this.unionSets(this.selectedWordIdxs,r) : r; this.updateWordSelectionClasses(); }

  /* ---------- Tag Bubble (chips + custom category + LOCK) ---------- */
  maybeShowTagBubble(){
    if (!this.selectedWordIdxs.size) return;
    let idxs = [...this.selectedWordIdxs].sort((a,b)=>a-b);

    // Expand to entire tagged phrase if selection is inside a highlight
    const firstWord = this.wordElems[idxs[0]];
    const container = firstWord?.closest(".highlight");
    if (container && container.dataset.category && container.dataset.category !== "__LOCKED__") {
      const all = [...container.querySelectorAll(".word")].map(w=>+w.dataset.idx).sort((a,b)=>a-b);
      if (all.length) {
        idxs = all;
        this.selectedWordIdxs = new Set(all);
        this.updateWordSelectionClasses();
      }
    }

    const text = this.getExactSelectedText(idxs);
    if (!text) return;

    const rect = this.unionClientRect(idxs.map(i=>this.wordElems[i].getBoundingClientRect()));
    this.showTagBubble(text, rect);
  }

  getExactSelectedText(sortedWordIdxs) {
    if (!sortedWordIdxs.length) return "";
    
    // Get the current text being displayed (after replacements)
    const displayText = this.highlightView.textContent || "";
    
    // Find start and end positions in the actual text
    let textPos = 0;
    let startPos = -1;
    let endPos = -1;
    
    // Walk through all words to find positions
    for (let i = 0; i < this.wordElems.length; i++) {
      const wordEl = this.wordElems[i];
      const wordText = wordEl.textContent || "";
      
      // Find this word in the display text starting from textPos
      const wordStart = displayText.indexOf(wordText, textPos);
      if (wordStart === -1) continue;
      
      if (i === sortedWordIdxs[0]) {
        startPos = wordStart;
      }
      if (i === sortedWordIdxs[sortedWordIdxs.length - 1]) {
        endPos = wordStart + wordText.length;
        break;
      }
      
      textPos = wordStart + wordText.length;
    }
    
    if (startPos === -1 || endPos === -1) return "";
    return displayText.slice(startPos, endPos);
  }

  showTagBubble(phrase, rect){
    this.removeTagBubble();
    const b = document.createElement("div");
    b.className = "floating-tag";

    const selLabel = document.createElement("div");
    selLabel.className = "sel";
    selLabel.textContent = `Selection: “${phrase}”`;

    // Chips for existing categories
    const cloudRow = document.createElement("div");
    cloudRow.className = "row";
    for (const [key,color] of categoryRegistry.entries()){
      const chip = document.createElement("button");
      chip.type="button"; chip.className="tag-chip";
      const dot = document.createElement("span"); dot.className="dot"; dot.style.background = color;
      const lbl = document.createElement("span"); lbl.textContent = key;
      chip.append(dot,lbl);
      chip.addEventListener("click", ()=>{
        this.addTag(key, phrase);
        this.removeTagBubble();
      });
      cloudRow.appendChild(chip);
    }

    // Custom category quick create
    const customRow = document.createElement("div");
    customRow.className = "row";
    const customInput = document.createElement("input");
    customInput.type="text"; customInput.placeholder="New category…"; customInput.style.flex="1 1 auto";
    const createBtn = document.createElement("button");
    createBtn.className="discreet"; createBtn.textContent="Create & Tag";

    createBtn.addEventListener("click", ()=>{
      const key = (customInput.value||"").trim();
      if (!key) { customInput.focus(); return; }
      ensureCategory(key);
      this.addTag(key, phrase);
      this.removeTagBubble();
    });
    customInput.addEventListener("keydown",(e)=>{
      if (e.key==="Enter"){ createBtn.click(); }
    });

    // Controls: Lock + Cancel
    const controls = document.createElement("div");
    controls.className = "row";
    const lockBtn = document.createElement("button");
    lockBtn.className = "discreet";
    lockBtn.textContent = "Lock selection";
    lockBtn.title = "Make this phrase immutable (italic + 50% opacity)";
    lockBtn.addEventListener("click", ()=>{
      this.addLock(phrase);      // lock + close + re-render
      this.removeTagBubble();
    });
    const cancel = document.createElement("button");
    cancel.textContent="Cancel"; cancel.type="button"; cancel.className="discreet";
    cancel.addEventListener("click", ()=>this.removeTagBubble());
    controls.append(lockBtn, cancel);

    // Position + mount
    b.style.top  = `${rect.bottom+window.scrollY+6}px`;
    b.style.left = `${rect.left+window.scrollX}px`;
    b.append(selLabel, cloudRow, customRow, controls);
    document.body.appendChild(b);

    this.activeBubbleEl = b;
    this.bubbleGuard = true;
    setTimeout(()=>{ this.bubbleGuard = false; }, 0);
    this.bubbleOutsideListener = (ev)=>{
      if (this.bubbleGuard) return;
      if (!this.activeBubbleEl) return;
      if (!this.activeBubbleEl.contains(ev.target)) this.removeTagBubble();
    };
    document.addEventListener('pointerdown', this.bubbleOutsideListener, true);

    customInput.focus();
  }

  addTag(categoryKey, phrase){
    const key = categoryKey;
    // remove from any existing categories first (reassign)
    for (const [k,set] of this.foundByCategory.entries()){
      if (k !== key && set.has(phrase)) set.delete(phrase);
    }
    const set = this.foundByCategory.get(key) || new Set();
    set.add(phrase); this.foundByCategory.set(key, set);
    if (!this.replacements.has(phrase)) this.replacements.set(phrase, phrase);
    this.renderSwapPanel(); this.renderPreview();
  }

  addLock(phrase){
    const p = (phrase||"").trim().replace(/\s+/g,' ');
    if (!p) return;
    this.lockedSections.add(p);
    // lock means: immune to swaps + styled; no need to be in any category
    this.renderPreview();
  }

  removeTagBubble(){
    if (this.activeBubbleEl?.parentNode) this.activeBubbleEl.parentNode.removeChild(this.activeBubbleEl);
    this.activeBubbleEl = null;
    if (this.bubbleOutsideListener) {
      document.removeEventListener('pointerdown', this.bubbleOutsideListener, true);
      this.bubbleOutsideListener = null;
    }
  }

  /* ---------- Swap Panel ---------- */
  renderSwapPanel(){
    const panel=this.swapPanel;
    panel.innerHTML="";

    for (const [catKey, set] of this.foundByCategory.entries()){
      if (!set.size) continue;
      const color = ensureCategory(catKey);

      const card=document.createElement("div");
      card.className="swap-card";

      const h=document.createElement("h3");
      const dot=document.createElement("span");
      dot.className="dot"; dot.style.background=color;
      const label=document.createElement("span");
      label.textContent=catKey;
      h.append(dot,label);
      card.appendChild(h);

      for (const term of set){
        const wrap=document.createElement("div"); wrap.className="swap-item";

        const lab=document.createElement("label"); lab.textContent=term;

        const right=document.createElement("div"); right.className="right";
        const inp=document.createElement("input");
        inp.value=this.replacements.get(term) ?? term;
        inp.addEventListener("input",(e)=>{
          this.replacements.set(term, e.target.value);
          this.renderPreview();
        });

        const btnX=document.createElement("button");
        btnX.className="x"; btnX.textContent="✕";
        btnX.title = "Remove this tag (keep the word)";
        btnX.addEventListener("click", ()=>{
          this.untag(catKey, term);
        });

        right.append(inp, btnX);
        wrap.append(lab, right);
        card.appendChild(wrap);
      }

      panel.appendChild(card);
    }
  }

  untag(catKey, term){
    const set = this.foundByCategory.get(catKey);
    if (!set) return;
    set.delete(term);
    if (!set.size) this.foundByCategory.delete(catKey);

    // If this term is not tagged in any category anymore, remove replacement & (optionally keep lock)
    const stillTagged = [...this.foundByCategory.values()].some(s=>s.has(term));
    if (!stillTagged){
      this.replacements.delete(term);
      // NOTE: locking is independent of tagging; we do NOT auto-unlock here.
    }

    this.renderSwapPanel();
    this.renderPreview();
  }

  /* ---------- Edit / Copy / Export / Remove ---------- */
  toggleEdit(){
    this.isEditing = !this.isEditing;
    this.updateEditUI();
    if (!this.isEditing) this.runParse();
  }
  updateEditUI(){
    this.textarea.style.display = this.isEditing ? "block" : "none";
    this.highlightView.style.display = this.isEditing ? "none" : "block";
    this.swapPanel.style.display = this.isEditing ? "none" : "grid";
    this.btnEdit.textContent = this.isEditing ? "Done" : "Edit";
    this.btnCopy.style.display = this.isEditing ? "none" : "inline-flex";
  }

  copyPrompt(){
    const content = this.highlightView.textContent || "";
    navigator.clipboard.writeText(content);
    this.btnCopy.style.opacity = "0.85";
    setTimeout(()=>{ this.btnCopy.style.opacity = "1"; }, 250);
  }

  exportJSON(){
    const payload = {
      prompt: this.originalPrompt,
      categories: Object.fromEntries(categoryRegistry),
      tags: [...this.foundByCategory.entries()].reduce((acc,[k,set])=>{
        acc[k]=[...set]; return acc;
      },{}),
      replacements: Object.fromEntries(this.replacements),
      locked: [...this.lockedSections]
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `prompt-template-${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  remove(){
    this.removeTagBubble();
    this.root.remove();
  }

  /* ---------- Utils ---------- */
  unionClientRect(rects){
    const left = Math.min(...rects.map(r=>r.left));
    const top = Math.min(...rects.map(r=>r.top));
    const right = Math.max(...rects.map(r=>r.right));
    const bottom = Math.max(...rects.map(r=>r.bottom));
    return { left, top, right, bottom, width: right-left, height: bottom-top };
  }
}

/* =========================
   Helpers (global)
   ========================= */
function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"); }
function toTitleCase(s){ return s.replace(/\w\S*/g,t=>t[0].toUpperCase()+t.slice(1).toLowerCase()); }
function debounce(fn,ms=250){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(this,args),ms); }; }

/* =========================
   Boot: "Add New Prompt"
   ========================= */
const list = document.getElementById("promptList");
document.getElementById("addPrompt").addEventListener("click", ()=>{
  new PromptCard(list, "");
});
  </script>
</body>
</html>