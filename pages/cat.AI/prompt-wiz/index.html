<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prompt Engineer – Color-coded Mad Libs</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Noto+Sans:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
:root { --bg: #ffffff; --fg: #111111; --muted: #6b7280; --border: #e5e7eb; --ring: #111111; --c-lighting: #1f2937; --c-mood: #7c3aed; --c-subject: #047857; --c-style: #2563eb; --c-composition: #b45309; --c-effects: #be185d; --hl-bg: #f8fafc; }
body { background: var(--bg); color: var(--fg); font-family: "Noto Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; line-height: 1.5; margin: 0; }
.site-header { padding: 32px 20px 12px; border-bottom: 1px solid var(--border); } .site-header h1 { font-family: "Space Mono", monospace; margin: 0 0 6px; font-size: 28px; } .tagline { margin: 0; color: var(--muted); }
.layout { max-width: 1100px; margin: 0 auto; padding: 20px; display: grid; gap: 28px; } .stage h2 { margin: 0 0 10px; font-size: 18px; }
textarea { width: 100%; padding: 14px; border: 1px solid var(--border); border-radius: 10px; font: inherit; resize: vertical; background: var(--bg); color: var(--fg); }
.row.actions { display: flex; gap: 12px; margin-top: 12px; }
button { border: 1px solid var(--border); background: #fff; color: var(--fg); padding: 10px 14px; border-radius: 12px; font: inherit; cursor: pointer; transition: transform .06s ease, box-shadow .12s ease; }
button.primary { background: var(--fg); color: #fff; border-color: var(--fg); } button.ghost { background: transparent; } button:hover { box-shadow: 0 6px 16px rgba(0,0,0,0.08); }

.parsed-top { display: flex; align-items: center; justify-content: space-between; gap: 16px; } .legend { display: flex; flex-wrap: wrap; gap: 10px; }
.legend .chip { display: inline-flex; align-items: center; gap: 8px; border: 1px solid var(--border); padding: 6px 10px; border-radius: 999px; font-size: 12px; background: #fff; } .legend .dot { width: 10px; height: 10px; border-radius: 999px; }

/* Highlight container */
.highlight-view { border: 1px dashed var(--border); border-radius: 12px; padding: 14px; min-height: 100px; background: var(--hl-bg); white-space: pre-wrap; }

/* Category highlights */
.highlight { position: relative; padding: 1px 3px; border-radius: 6px; cursor: help; white-space: pre-wrap; }
.highlight[data-category="Lighting"] { background: rgba(31,41,55,.08); box-shadow: inset 0 -2px 0 0 var(--c-lighting); }
.highlight[data-category="Mood"] { background: rgba(124,58,237,.08); box-shadow: inset 0 -2px 0 0 var(--c-mood); }
.highlight[data-category="Subject"] { background: rgba(4,120,87,.08); box-shadow: inset 0 -2px 0 0 var(--c-subject); }
.highlight[data-category="Style"] { background: rgba(37,99,235,.08); box-shadow: inset 0 -2px 0 0 var(--c-style); }
.highlight[data-category="Composition"] { background: rgba(180,83,9,.1); box-shadow: inset 0 -2px 0 0 var(--c-composition); }
.highlight[data-category="Effects"] { background: rgba(190,24,93,.08); box-shadow: inset 0 -2px 0 0 var(--c-effects); }

/* Swap panel */
.swap-panel { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 14px; }
.swap-card { border: 1px solid var(--border); border-radius: 12px; padding: 12px; background: #fff; }
.swap-card h3 { display: flex; align-items: center; gap: 8px; margin: 0 0 10px; font-size: 14px; } .swap-card .dot { width: 10px; height: 10px; border-radius: 999px; }
.swap-item { display: grid; grid-template-columns: 1fr; gap: 8px; margin-bottom: 10px; } .swap-item label { font-size: 12px; color: var(--muted); }
.swap-item input { padding: 10px; border: 1px solid var(--border); border-radius: 10px; font: inherit; }

.preview { background: #fff; border-style: solid; }
.site-footer { padding: 16px 20px 40px; color: var(--muted); text-align: center; border-top: 1px solid var(--border); }

/* Tag bubble */
.floating-tag { position: absolute; z-index: 10; background: #fff; border: 1px solid var(--border); border-radius: 8px; padding: 8px; display: flex; gap: 8px; align-items: center; box-shadow: 0 8px 24px rgba(0,0,0,.08); }

/* ===== Whole-word selection UI (file-picker style) ===== */
.highlight-view { user-select: none; cursor: text; }           /* Prevent partial-character selection */
.highlight-view .word { padding: 0 2px; border-radius: 4px; }
.highlight-view .word.selected {
  background: rgba(17,17,17,.08);
  box-shadow: inset 0 -2px 0 0 var(--ring);
}
  </style>
</head>
<body>
  <header class="site-header">
    <h1>Prompt Engineer</h1>
    <p class="tagline">Color-coded Mad Libs for image prompt crafting</p>
  </header>

  <main class="layout">
    <section class="stage input-stage">
      <h2>Prompt</h2>
      <textarea id="promptInput" placeholder="Paste your prompt here..." rows="8"></textarea>
      <div class="row actions">
        <button id="editToggle" class="ghost">✏️ Edit</button>
        <button id="copyPlain" class="primary">Copy Prompt</button>
      </div>
    </section>

    <section class="stage parsed-stage">
      <div class="parsed-top">
        <h2>2–3. Auto-Parse & Interactive Highlight</h2>
      </div>
      <div id="highlightView" class="highlight-view" aria-live="polite"></div>
    </section>

    <section class="stage">
      <h2>4. Swap Panel</h2>
      <div id="swapPanel" class="swap-panel"></div>
    </section>
  </main>

  <footer class="site-footer">
    <p>Tip: Select words (click/drag). Shift = range, Ctrl/⌘ = toggle. Release to open tag bubble. Bubble closes only on outside click or after tagging.</p>
  </footer>

  <script type="module">
/* =========================
   Categories & DOM
   ========================= */
const categories = [
  { key: "Lighting",    colorVar: "--c-lighting",    terms: [] },
  { key: "Mood",        colorVar: "--c-mood",        terms: [] },
  { key: "Style",       colorVar: "--c-style",       terms: [] },
  { key: "Composition", colorVar: "--c-composition", terms: [] },
  { key: "Effects",     colorVar: "--c-effects",     terms: [] },
  { key: "Subject",     colorVar: "--c-subject",     terms: [] }
];
const elements = {
  input: document.getElementById("promptInput"),
  highlightView: document.getElementById("highlightView"),
  livePreview: document.getElementById("highlightView"),
  copyPlain: document.getElementById("copyPlain"),
  editToggle: document.getElementById("editToggle"),
  swapPanel: document.getElementById("swapPanel")
};

/* =========================
   App state
   ========================= */
let originalPrompt = "";
let foundByCategory = {};
let replacements = {};
let lockedSections = new Set();

/* Word-selection state (file-picker style) */
let wordElems = [];                    // index → <span.word>
let selectedWordIdxs = new Set();      // currently selected words
let anchorWordIdx = null;              // anchor for shift-range
let dragState = { active:false, start:null, additive:false, base:new Set() };

/* Tag bubble state (for outside-click close handling) */
let activeBubbleEl = null;
let bubbleOutsideListener = null;
let bubbleGuard = false; // prevents immediate close on the same event that opened it

/* =========================
   Init
   ========================= */
function init(){
  buildLegend();
  elements.input.addEventListener("input", debounce(runParse,300));
  elements.copyPlain.addEventListener("click", ()=>copyOutput(false));
  elements.editToggle.addEventListener("click", toggleEdit);

  attachWordSelectionHandlers();   // enable file-picker selection
  runParse();
}

/* =========================
   Legend
   ========================= */
function buildLegend(){
  elements.highlightView.innerHTML="";
  const wrap=document.createElement("div");
  wrap.className="legend";
  for(const c of categories){
    const chip=document.createElement("div");
    chip.className="chip";
    const dot=document.createElement("span");
    dot.className="dot";
    dot.style.background=getComputedStyle(document.documentElement)
      .getPropertyValue(c.colorVar);
    const label=document.createElement("span");
    label.textContent=c.key;
    chip.append(dot,label);
    wrap.appendChild(chip);
  }
  elements.highlightView.appendChild(wrap);
}

/* =========================
   Parse → highlight → preview
   ========================= */
function runParse(){
  originalPrompt=(elements.input.value||"").trim();
  if(!originalPrompt){
    buildLegend();
    elements.swapPanel.innerHTML="";
    // Reset selection state
    selectedWordIdxs.clear(); anchorWordIdx=null; wordElems=[];
    return;
  }

  // Keep any existing manual tags
  foundByCategory = Object.fromEntries(categories.map(c=>[c.key, foundByCategory[c.key]||new Set()]));

  // Ensure replacements map contains all tagged terms
  replacements = Object.fromEntries(
    Object.values(foundByCategory).flatMap(set => [...set])
      .map(t => [t, replacements[t] ?? t])
  );

  renderHighlight(originalPrompt, foundByCategory, elements.highlightView);
  enableInlineEditing();
  renderSwapPanel();
  renderPreview();
}

function renderPreview(){
  const remixed = applyReplacements(originalPrompt, replacements);

  // Include replacements in preview highlighting
  const foundPreview = Object.fromEntries(Object.entries(foundByCategory)
    .map(([k,set]) => [k,new Set(set)]));
  for(const [term,repl] of Object.entries(replacements)){
    for(const set of Object.values(foundPreview)) if(set?.has?.(term)) set.add(repl);
  }
  renderHighlight(remixed, foundPreview, elements.livePreview);
}

/* =========================
   Replace helpers
   ========================= */
function applyReplacements(text,map){
  const placeholders=[];
  lockedSections.forEach((lock,i)=>{
    const token=`__LOCK_${i}__`;
    placeholders.push({token,lock});
    text=text.replace(new RegExp(escapeRegExp(lock),"g"),token);
  });

  const terms=Object.keys(map).sort((a,b)=>b.length-a.length);
  let out=text;
  for(const t of terms){
    if(!t) continue;
    const repl=map[t];
    const re=new RegExp(`\\b${escapeRegExp(t)}\\b`,"gi");
    out=out.replace(re,match=>{
      if(isTitleCase(match)) return toTitleCase(repl);
      if(match===match.toUpperCase()) return repl.toUpperCase();
      if(match===match.toLowerCase()) return repl.toLowerCase();
      return repl;
    });
  }

  placeholders.forEach(({token,lock})=>{
    out=out.replace(new RegExp(token,"g"),lock);
  });
  return out;
}

/* =========================
   Rendering: highlights + per-word spans
   ========================= */
function renderHighlight(text,found,container){
  // Rebuild selection state for each render
  selectedWordIdxs.clear();
  anchorWordIdx = null;

  const segments = buildHighlightSpans(text,found);
  container.innerHTML = "";

  const { fragment, words } = tokenizeSegmentsToWords(segments);
  container.appendChild(fragment);

  wordElems = words;
  updateWordSelectionClasses();
}

function buildHighlightSpans(text,found){
  const matches=[];
  for (const [cat,set] of Object.entries(found)){
    for (const term of set){
      if(!term) continue;
      const re=new RegExp(`\\b${escapeRegExp(term)}\\b`,"gi");
      let m;
      while((m=re.exec(text))!==null){
        matches.push({start:m.index,end:m.index+m[0].length,category:cat,term,len:m[0].length});
      }
    }
  }
  matches.sort((a,b)=> a.start-b.start || b.len-a.len);

  const picked=[]; let lastEnd=-1;
  for(const m of matches){ if(m.start>=lastEnd){ picked.push(m); lastEnd=m.end; } }

  const nodes=[]; let cursor=0;
  for(const m of picked){
    if(cursor<m.start) nodes.push(document.createTextNode(text.slice(cursor,m.start)));
    const span=document.createElement("span");
    span.className="highlight"; span.dataset.category=m.category; span.title=m.category;
    span.textContent=text.slice(m.start,m.end);
    nodes.push(span);
    cursor=m.end;
  }
  if(cursor<text.length) nodes.push(document.createTextNode(text.slice(cursor)));
  return nodes;
}

function tokenizeSegmentsToWords(segments){
  const frag = document.createDocumentFragment();
  const words = [];
  let idxCounter = 0;

  const pushWord = (segment, category) => {
    const w = document.createElement("span");
    w.className = "word";
    w.dataset.idx = idxCounter++;
    w.textContent = segment;
    words.push(w);

    if (category) {
      const h = document.createElement("span");
      h.className = "highlight";
      h.dataset.category = category;
      h.title = category;
      h.appendChild(w);
      return h;
    }
    return w;
  };

  const processText = (text, category) => {
    if (!text) return;

    if (typeof Intl !== "undefined" && "Segmenter" in Intl) {
      const seg = new Intl.Segmenter(undefined, { granularity: "word" });
      for (const { segment, isWordLike } of seg.segment(text)) {
        if (isWordLike) {
          frag.appendChild(pushWord(segment, category));
        } else {
          frag.appendChild(document.createTextNode(segment));
        }
      }
    } else {
      const re = /([\p{L}\p{M}\p{N}]+(?:['’\-][\p{L}\p{M}\p{N}]+)*)/gu;
      let last = 0, m;
      while ((m = re.exec(text))) {
        if (m.index > last) frag.appendChild(document.createTextNode(text.slice(last, m.index)));
        frag.appendChild(pushWord(m[1], category));
        last = re.lastIndex;
      }
      if (last < text.length) frag.appendChild(document.createTextNode(text.slice(last)));
    }
  };

  segments.forEach(node => {
    if (node.nodeType === Node.TEXT_NODE) {
      processText(node.nodeValue, null);
    } else if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains("highlight")) {
      processText(node.textContent, node.dataset.category || null);
    }
  });

  return { fragment: frag, words };
}

/* =========================
   Word selection (click / shift / ctrl-cmd / drag)
   ========================= */
function attachWordSelectionHandlers(){
  elements.highlightView.addEventListener("mousedown", (e) => {
    const w = e.target.closest(".word");
    const additive = e.ctrlKey || e.metaKey;
    const shift = e.shiftKey;

    // Clicked empty area: clear selection unless additive mode
    if (!w) {
      if (!additive) {
        selectedWordIdxs.clear();
        updateWordSelectionClasses();
        // treat as "clicked off" → close bubble
        removeTagBubble();
      }
      return;
    }

    e.preventDefault(); // force whole-word behavior
    const idx = +w.dataset.idx;

    dragState.active   = true;
    dragState.start    = idx;
    dragState.additive = additive;
    dragState.base     = new Set(selectedWordIdxs);

    if (shift && anchorWordIdx !== null) {
      selectRange(anchorWordIdx, idx, additive);
    } else if (additive) {
      toggleIdx(idx);
      anchorWordIdx = idx;
    } else {
      selectedWordIdxs.clear();
      selectedWordIdxs.add(idx);
      anchorWordIdx = idx;
    }
    updateWordSelectionClasses();
    // don't close bubble here; opening/closing is handled by outside-click + tag action
  });

  // Drag across words = live range selection
  elements.highlightView.addEventListener("mouseover", (e) => {
    if (!dragState.active) return;
    const w = e.target.closest(".word");
    if (!w) return;
    const idx = +w.dataset.idx;
    const range = buildRangeSet(dragState.start, idx);
    selectedWordIdxs = dragState.additive ? unionSets(dragState.base, range) : range;
    updateWordSelectionClasses();
  });

  // Mouse up ends selection and shows the tag bubble (no auto-close anymore)
  document.addEventListener("mouseup", () => {
    if (dragState.active) dragState.active = false;
    maybeShowTagBubble();
  });

  // Keep anchor in sync on clicks
  elements.highlightView.addEventListener("click", (e) => {
    const w = e.target.closest(".word");
    if (w) anchorWordIdx = +w.dataset.idx;
  });

  // Press 't' to reopen the tag bubble for current selection
  document.addEventListener("keydown",(e)=>{
    if (e.key.toLowerCase() === 't') maybeShowTagBubble();
    if (e.key === 'Escape') removeTagBubble();
  });
}

function maybeShowTagBubble(){
  if (!selectedWordIdxs.size) { return; }
  const idxs = [...selectedWordIdxs].sort((a,b)=>a-b);
  const text = idxs.map(i => wordElems[i]?.textContent ?? "").join(" ").trim();
  if (!text) { return; }
  const rect = unionClientRect(idxs.map(i=>wordElems[i].getBoundingClientRect()));
  showTagBubble(text, rect);
}

// Selection helpers
function toggleIdx(i){ selectedWordIdxs.has(i) ? selectedWordIdxs.delete(i) : selectedWordIdxs.add(i); }
function buildRangeSet(a,b){ const s=new Set(); const [lo,hi]=a<=b?[a,b]:[b,a]; for(let i=lo;i<=hi;i++) s.add(i); return s; }
function unionSets(a,b){ const s=new Set(a); for(const x of b) s.add(x); return s; }
function updateWordSelectionClasses(){ wordElems.forEach((el,i)=>el.classList.toggle("selected", selectedWordIdxs.has(i))); }
function selectRange(a,b,add){ const r=buildRangeSet(a,b); selectedWordIdxs = add ? unionSets(selectedWordIdxs,r) : r; updateWordSelectionClasses(); }

/* =========================
   Inline editing (kept)
   ========================= */
function enableInlineEditing(){
  elements.highlightView.onclick=(e)=>{
    const span=e.target.closest(".highlight");
    if(!span || elements.input.disabled===false) return;
    const original=span.textContent;
    const input=document.createElement("input");
    input.value=original;
    input.style.minWidth="120px";
    span.replaceWith(input);
    input.focus();
    const commit=()=>{
      for(const k of Object.keys(replacements)){
        if(k.toLowerCase()===original.toLowerCase()) replacements[k]=input.value;
      }
      renderPreview();
      renderSwapPanel();
    };
    input.addEventListener("blur",commit);
    input.addEventListener("keydown",(ev)=>{ if(ev.key==="Enter"){ input.blur(); } });
  };
}

/* =========================
   Swap panel
   ========================= */
function renderSwapPanel(){
  const panel=elements.swapPanel;
  panel.innerHTML="";

  const getColor=(key)=>{
    const cat=categories.find(c=>c.key===key);
    return getComputedStyle(document.documentElement)
      .getPropertyValue(cat?.colorVar||"--border");
  };

  for (const c of categories){
    const terms=Array.from(foundByCategory[c.key]||[]);
    if(!terms.length) continue;

    const card=document.createElement("div");
    card.className="swap-card";

    const h=document.createElement("h3");
    const dot=document.createElement("span");
    dot.className="dot";
    dot.style.background=getColor(c.key);
    const label=document.createElement("span");
    label.textContent=c.key;
    h.append(dot,label);
    card.appendChild(h);

    terms.forEach(term=>{
      const wrap=document.createElement("div");
      wrap.className="swap-item";
      const lab=document.createElement("label");
      lab.textContent=term;
      const inp=document.createElement("input");
      inp.value=replacements[term]??term;
      inp.dataset.key=term;
      inp.addEventListener("input",(e)=>{
        replacements[term]=e.target.value;
        renderPreview();
      });
      wrap.append(lab,inp);
      card.appendChild(wrap);
    });

    panel.appendChild(card);
  }
}

/* =========================
   Copy / edit / tagging bubble
   ========================= */
function copyOutput(){
  const content=elements.livePreview.textContent;
  if(!content) return;
  navigator.clipboard.writeText(content).then(flashCopied);
}
function flashCopied(){
  elements.copyPlain.textContent="Copied!";
  setTimeout(()=>elements.copyPlain.textContent="Copy Prompt",1000);
}

function toggleEdit(){
  const isDisabled=elements.input.disabled;
  elements.input.disabled=!isDisabled;
  if(!elements.input.disabled){ elements.input.focus(); }
  else { runParse(); }
}

/* Tag bubble: outside-click guarded */
function showTagBubble(selectedText,rect){
  removeTagBubble(); // clean any previous

  const b=document.createElement("div");
  b.className="floating-tag";

  const select=document.createElement("select");
  ["Lighting","Mood","Subject","Style","Composition","Effects"].forEach(k=>{
    const o=document.createElement("option"); o.value=k; o.textContent=k; select.appendChild(o);
  });

  const lockCb=document.createElement("input"); lockCb.type="checkbox"; lockCb.id="lockSec";
  const lockLb=document.createElement("label"); lockLb.htmlFor="lockSec"; lockLb.textContent="Lock section";

  const btn=document.createElement("button"); btn.textContent="Tag";
  btn.onclick=()=>{
    const cat = select.value;
    const phrase = selectedText.trim().replace(/\s+/g,' ');
    if (!phrase) return;

    foundByCategory[cat]=foundByCategory[cat]||new Set();
    foundByCategory[cat].add(phrase);
    replacements[phrase]=replacements[phrase]??phrase;
    if(lockCb.checked) lockedSections.add(phrase);

    renderPreview();     // show highlighted occurrences
    renderSwapPanel();   // panel appears/updates
    removeTagBubble();   // close bubble only after successful tag
  };

  const cancel=document.createElement("button"); cancel.textContent="Cancel";
  cancel.onclick=removeTagBubble;

  // Position + mount
  b.style.top  = `${rect.bottom+window.scrollY+6}px`;
  b.style.left = `${rect.left+window.scrollX}px`;
  b.append(select,lockCb,lockLb,btn,cancel);
  document.body.appendChild(b);

  // Set active bubble + install outside-click guard (capture phase)
  activeBubbleEl = b;
  bubbleGuard = true;                   // block the very event cycle that opened us
  setTimeout(()=>{ bubbleGuard = false; }, 0);

  bubbleOutsideListener = (ev)=>{
    if (bubbleGuard) return;
    if (!activeBubbleEl) return;
    if (!activeBubbleEl.contains(ev.target)) {
      removeTagBubble();                // close only when clicking off
    }
  };
  document.addEventListener('pointerdown', bubbleOutsideListener, true);
}

function removeTagBubble(){
  if (activeBubbleEl?.parentNode) activeBubbleEl.parentNode.removeChild(activeBubbleEl);
  activeBubbleEl = null;
  if (bubbleOutsideListener) {
    document.removeEventListener('pointerdown', bubbleOutsideListener, true);
    bubbleOutsideListener = null;
  }
}

/* =========================
   Utils
   ========================= */
function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"); }
function isTitleCase(s){ return /^[A-Z][a-z]/.test(s); }
function toTitleCase(s){ return s.replace(/\w\S*/g,t=>t[0].toUpperCase()+t.slice(1).toLowerCase()); }
function debounce(fn,ms=250){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(this,args),ms); }; }
function unionClientRect(rects){
  const left = Math.min(...rects.map(r=>r.left));
  const top = Math.min(...rects.map(r=>r.top));
  const right = Math.max(...rects.map(r=>r.right));
  const bottom = Math.max(...rects.map(r=>r.bottom));
  return { left, top, right, bottom, width: right-left, height: bottom-top };
}

/* =========================
   Boot
   ========================= */
init();
  </script>
</body>
</html>
