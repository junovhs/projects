<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prompt Engineer – Color-coded Mad Libs</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Noto+Sans:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
:root { --bg: #ffffff; --fg: #111111; --muted: #6b7280; --border: #e5e7eb; --ring: #111111; --c-lighting: #1f2937; --c-mood: #7c3aed; --c-subject: #047857; --c-style: #2563eb; --c-composition: #b45309; --c-effects: #be185d; --hl-bg: #f8fafc; }
body { background: var(--bg); color: var(--fg); font-family: "Noto Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; line-height: 1.5; margin: 0; }
.site-header { padding: 32px 20px 12px; border-bottom: 1px solid var(--border); }
.site-header h1 { font-family: "Space Mono", monospace; margin: 0 0 6px; font-size: 28px; }
.tagline { margin: 0; color: var(--muted); }
.layout { max-width: 1100px; margin: 0 auto; padding: 20px; display: grid; gap: 28px; }
.stage h2 { margin: 0 0 10px; font-size: 18px; }
textarea { width: 100%; padding: 14px; border: 1px solid var(--border); border-radius: 10px; font: inherit; resize: vertical; background: var(--bg); color: var(--fg); }
.row.actions { display: flex; gap: 12px; margin-top: 12px; }
button { border: 1px solid var(--border); background: #fff; color: var(--fg); padding: 10px 14px; border-radius: 12px; font: inherit; cursor: pointer; transition: transform .06s ease, box-shadow .12s ease; }
button.primary { background: var(--fg); color: #fff; border-color: var(--fg); }
button.ghost { background: transparent; }
button:hover { box-shadow: 0 6px 16px rgba(0,0,0,0.08); }

.parsed-top { display: flex; align-items: center; justify-content: space-between; gap: 16px; }
.legend { display: flex; flex-wrap: wrap; gap: 10px; }
.legend .chip { display: inline-flex; align-items: center; gap: 8px; border: 1px solid var(--border); padding: 6px 10px; border-radius: 999px; font-size: 12px; background: #fff; }
.legend .dot { width: 10px; height: 10px; border-radius: 999px; }

/* Highlight container */
.highlight-view { border: 1px dashed var(--border); border-radius: 12px; padding: 14px; min-height: 100px; background: var(--hl-bg); white-space: pre-wrap; }

/* Category highlights */
.highlight { position: relative; padding: 1px 3px; border-radius: 6px; cursor: help; white-space: pre-wrap; }
.highlight[data-category="Lighting"]    { background: rgba(31,41,55,.08);  box-shadow: inset 0 -2px 0 0 var(--c-lighting); }
.highlight[data-category="Mood"]        { background: rgba(124,58,237,.08); box-shadow: inset 0 -2px 0 0 var(--c-mood); }
.highlight[data-category="Subject"]     { background: rgba(4,120,87,.08);  box-shadow: inset 0 -2px 0 0 var(--c-subject); }
.highlight[data-category="Style"]       { background: rgba(37,99,235,.08); box-shadow: inset 0 -2px 0 0 var(--c-style); }
.highlight[data-category="Composition"] { background: rgba(180,83,9,.1);   box-shadow: inset 0 -2px 0 0 var(--c-composition); }
.highlight[data-category="Effects"]     { background: rgba(190,24,93,.08); box-shadow: inset 0 -2px 0 0 var(--c-effects); }

/* Swap panel */
.swap-panel { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 14px; }
.swap-card { border: 1px solid var(--border); border-radius: 12px; padding: 12px; background: #fff; }
.swap-card h3 { display: flex; align-items: center; gap: 8px; margin: 0 0 10px; font-size: 14px; }
.swap-card .dot { width: 10px; height: 10px; border-radius: 999px; }
.swap-item { display: grid; grid-template-columns: 1fr; gap: 8px; margin-bottom: 10px; }
.swap-item label { font-size: 12px; color: var(--muted); }
.swap-item input { padding: 10px; border: 1px solid var(--border); border-radius: 10px; font: inherit; }

.preview { background: #fff; border-style: solid; }
.site-footer { padding: 16px 20px 40px; color: var(--muted); text-align: center; border-top: 1px solid var(--border); }

/* Tag bubble (chip-based) */
.floating-tag { position: absolute; z-index: 10; background: #fff; border: 1px solid var(--border); border-radius: 10px; padding: 10px; display: grid; gap: 10px; align-items: start; box-shadow: 0 8px 24px rgba(0,0,0,.08); min-width: 260px; }
.floating-tag .sel { font-size: 12px; color: var(--muted); }
.floating-tag .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
.tag-chip { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border: 1px solid var(--border); border-radius: 999px; background: #fff; font-size: 12px; cursor: pointer; }
.tag-chip .dot { width: 10px; height: 10px; border-radius: 999px; }

/* ===== Whole-word selection UI (file-picker style) ===== */
.highlight-view { user-select: none; cursor: text; }      /* prevent partial character selection */
.highlight-view .word { padding: 0 2px; border-radius: 4px; }
.highlight-view .word.selected { background: rgba(17,17,17,.08); box-shadow: inset 0 -2px 0 0 var(--ring); }
  </style>
</head>
<body>
  <header class="site-header">
    <h1>Prompt Engineer</h1>
    <p class="tagline">Color-coded Mad Libs for image prompt crafting</p>
  </header>

  <main class="layout">
    <section class="stage input-stage">
      <h2>Prompt</h2>
      <textarea id="promptInput" placeholder="Paste your prompt here..." rows="8"></textarea>
      <div class="row actions">
        <button id="editToggle" class="ghost">✏️ Edit</button>
        <button id="copyPlain" class="primary">Copy Prompt</button>
      </div>
    </section>

    <section class="stage parsed-stage">
      <div class="parsed-top">
        <h2>Interactive Highlight (Manual)</h2>
      </div>
      <div id="highlightView" class="highlight-view" aria-live="polite"></div>
    </section>

    <section class="stage">
      <h2>Swap Panel</h2>
      <div id="swapPanel" class="swap-panel"></div>
    </section>
  </main>

  <footer class="site-footer">
    <p>Tip: Click/drag to select words. Shift = range, Ctrl/⌘ = toggle. Tag via the chips; bubble closes on outside click or after tagging.</p>
  </footer>

  <script type="module">
/* =========================
   Categories & DOM
   ========================= */
const categories = [
  { key: "Lighting",    colorVar: "--c-lighting" },
  { key: "Mood",        colorVar: "--c-mood" },
  { key: "Style",       colorVar: "--c-style" },
  { key: "Composition", colorVar: "--c-composition" },
  { key: "Effects",     colorVar: "--c-effects" },
  { key: "Subject",     colorVar: "--c-subject" }
];

const elements = {
  input: document.getElementById("promptInput"),
  highlightView: document.getElementById("highlightView"),
  livePreview: document.getElementById("highlightView"),
  copyPlain: document.getElementById("copyPlain"),
  editToggle: document.getElementById("editToggle"),
  swapPanel: document.getElementById("swapPanel")
};

/* =========================
   App state
   ========================= */
let originalPrompt = "";
let foundByCategory = {};      // {Category -> Set<string>}
let replacements = {};         // {term -> replacement}
let lockedSections = new Set();// Set<string> exact phrase locks

/* Word-selection state */
let wordElems = [];                    // index → <span.word>
let selectedWordIdxs = new Set();      // selected indices
let anchorWordIdx = null;              // for shift-range
let dragState = { active:false, start:null, additive:false, base:new Set() };
let selectionDirty = false;            // only open bubble on *new* selection

/* Tag bubble state */
let activeBubbleEl = null;
let bubbleOutsideListener = null;
let bubbleGuard = false;

/* =========================
   Init
   ========================= */
function init(){
  buildLegend();
  elements.input.addEventListener("input", debounce(runParse,300));
  elements.copyPlain.addEventListener("click", ()=>copyOutput(false));
  elements.editToggle.addEventListener("click", toggleEdit);

  attachWordSelectionHandlers();
  runParse();
}

/* =========================
   Legend
   ========================= */
function buildLegend(){
  elements.highlightView.innerHTML="";
  const wrap=document.createElement("div");
  wrap.className="legend";
  for(const c of categories){
    const chip=document.createElement("div");
    chip.className="chip";
    const dot=document.createElement("span");
    dot.className="dot";
    dot.style.background=getColor(c.key);
    const label=document.createElement("span");
    label.textContent=c.key;
    chip.append(dot,label);
    wrap.appendChild(chip);
  }
  elements.highlightView.appendChild(wrap);
}

/* =========================
   Parse → highlight → preview
   ========================= */
function runParse(){
  originalPrompt=(elements.input.value||"").trim();
  if(!originalPrompt){
    buildLegend();
    elements.swapPanel.innerHTML="";
    selectedWordIdxs.clear(); anchorWordIdx=null; wordElems=[];
    return;
  }

  // Persist existing manual tags
  foundByCategory = Object.fromEntries(categories.map(c=>[c.key, foundByCategory[c.key]||new Set()]));

  // Ensure replacements include all tagged terms
  replacements = Object.fromEntries(
    Object.values(foundByCategory).flatMap(set => [...set]).map(t => [t, replacements[t] ?? t])
  );

  renderHighlight(originalPrompt, foundByCategory, elements.highlightView);
  enableInlineEditing();
  renderSwapPanel();
  renderPreview();
}

function renderPreview(){
  const remixed = applyReplacements(originalPrompt, replacements);

  // Preview highlights show originals + replacements
  const foundPreview = Object.fromEntries(Object.entries(foundByCategory).map(([k,set])=>[k,new Set(set)]));
  for(const [term,repl] of Object.entries(replacements)){
    for(const set of Object.values(foundPreview)) if(set?.has?.(term)) set.add(repl);
  }
  renderHighlight(remixed, foundPreview, elements.livePreview);
}

/* =========================
   Replace helpers
   ========================= */
function applyReplacements(text,map){
  const placeholders=[];
  lockedSections.forEach((lock,i)=>{
    const token=`__LOCK_${i}__`;
    placeholders.push({token,lock});
    text=text.replace(new RegExp(escapeRegExp(lock),"g"),token);
  });

  const terms=Object.keys(map).sort((a,b)=>b.length-a.length);
  let out=text;
  for(const t of terms){
    if(!t) continue;
    const repl=map[t];
    const re=new RegExp(`\\b${escapeRegExp(t)}\\b`,"gi");
    out=out.replace(re,match=>{
      if(isTitleCase(match)) return toTitleCase(repl);
      if(match===match.toUpperCase()) return repl.toUpperCase();
      if(match===match.toLowerCase()) return repl.toLowerCase();
      return repl;
    });
  }

  placeholders.forEach(({token,lock})=>{ out=out.replace(new RegExp(token,"g"),lock); });
  return out;
}

/* =========================
   Rendering: highlights + per-word spans
   ========================= */
function renderHighlight(text,found,container){
  // Clear selection on re-render
  selectedWordIdxs.clear();
  anchorWordIdx = null;

  const segments = buildHighlightSpans(text,found);
  container.innerHTML = "";

  const { fragment, words } = tokenizeSegmentsToWords(segments);
  container.appendChild(fragment);

  wordElems = words;
  updateWordSelectionClasses();
}

function buildHighlightSpans(text,found){
  const matches=[];
  for (const [cat,set] of Object.entries(found)){
    for (const term of set){
      if(!term) continue;
      const re=new RegExp(`\\b${escapeRegExp(term)}\\b`,"gi");
      let m;
      while((m=re.exec(text))!==null){
        matches.push({start:m.index,end:m.index+m[0].length,category:cat,term,len:m[0].length});
      }
    }
  }
  matches.sort((a,b)=> a.start-b.start || b.len-a.len);

  const picked=[]; let lastEnd=-1;
  for(const m of matches){ if(m.start>=lastEnd){ picked.push(m); lastEnd=m.end; } }

  const nodes=[]; let cursor=0;
  for(const m of picked){
    if(cursor<m.start) nodes.push(document.createTextNode(text.slice(cursor,m.start)));
    const span=document.createElement("span");
    span.className="highlight"; span.dataset.category=m.category; span.title=m.category;
    span.textContent=text.slice(m.start,m.end);
    nodes.push(span);
    cursor=m.end;
  }
  if(cursor<text.length) nodes.push(document.createTextNode(text.slice(cursor)));
  return nodes;
}

function tokenizeSegmentsToWords(segments){
  const frag = document.createDocumentFragment();
  const words = [];
  let idxCounter = 0;

  const pushWord = (segment, category) => {
    const w = document.createElement("span");
    w.className = "word";
    w.dataset.idx = idxCounter++;
    w.textContent = segment;
    words.push(w);
    if (category) {
      const h = document.createElement("span");
      h.className = "highlight";
      h.dataset.category = category;
      h.title = category;
      h.appendChild(w);
      return h;
    }
    return w;
  };

  const processText = (text, category) => {
    if (!text) return;
    if (typeof Intl !== "undefined" && "Segmenter" in Intl) {
      const seg = new Intl.Segmenter(undefined, { granularity: "word" });
      for (const { segment, isWordLike } of seg.segment(text)) {
        if (isWordLike) frag.appendChild(pushWord(segment, category));
        else frag.appendChild(document.createTextNode(segment));
      }
    } else {
      const re = /([\p{L}\p{M}\p{N}]+(?:['’\-][\p{L}\p{M}\p{N}]+)*)/gu;
      let last = 0, m;
      while ((m = re.exec(text))) {
        if (m.index > last) frag.appendChild(document.createTextNode(text.slice(last, m.index)));
        frag.appendChild(pushWord(m[1], category));
        last = re.lastIndex;
      }
      if (last < text.length) frag.appendChild(document.createTextNode(text.slice(last)));
    }
  };

  segments.forEach(node => {
    if (node.nodeType === Node.TEXT_NODE) processText(node.nodeValue, null);
    else if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains("highlight"))
      processText(node.textContent, node.dataset.category || null);
  });

  return { fragment: frag, words };
}

/* =========================
   Word selection (click / shift / ctrl-cmd / drag)
   ========================= */
function attachWordSelectionHandlers(){
  elements.highlightView.addEventListener("mousedown", (e) => {
    const w = e.target.closest(".word");
    const additive = e.ctrlKey || e.metaKey;
    const shift = e.shiftKey;

    if (!w) {
      if (!additive) {
        selectedWordIdxs.clear();
        updateWordSelectionClasses();
        removeTagBubble(); // clicking off closes bubble
      }
      return;
    }

    e.preventDefault();
    const idx = +w.dataset.idx;
    selectionDirty = true;

    dragState.active   = true;
    dragState.start    = idx;
    dragState.additive = additive;
    dragState.base     = new Set(selectedWordIdxs);

    if (shift && anchorWordIdx !== null) {
      selectRange(anchorWordIdx, idx, additive);
    } else if (additive) {
      toggleIdx(idx);
      anchorWordIdx = idx;
    } else {
      selectedWordIdxs.clear();
      selectedWordIdxs.add(idx);
      anchorWordIdx = idx;
    }
    updateWordSelectionClasses();
  });

  elements.highlightView.addEventListener("mouseover", (e) => {
    if (!dragState.active) return;
    const w = e.target.closest(".word");
    if (!w) return;
    const idx = +w.dataset.idx;
    const range = buildRangeSet(dragState.start, idx);
    selectedWordIdxs = dragState.additive ? unionSets(dragState.base, range) : range;
    updateWordSelectionClasses();
  });

  // Only show bubble when a selection gesture ended on the page (and not inside the bubble)
  document.addEventListener("mouseup", (e) => {
    if (dragState.active) dragState.active = false;
    if (!selectionDirty) return;
    selectionDirty = false;
    if (activeBubbleEl && activeBubbleEl.contains(e.target)) return; // don't rebuild while interacting with bubble
    maybeShowTagBubble();
  });

  // Keep anchor in sync
  elements.highlightView.addEventListener("click", (e) => {
    const w = e.target.closest(".word");
    if (w) anchorWordIdx = +w.dataset.idx;
  });

  // Optional: press 't' to open bubble for current selection
  document.addEventListener("keydown",(e)=>{
    if (e.key.toLowerCase() === 't') maybeShowTagBubble();
    if (e.key === 'Escape') removeTagBubble(); // easy close; remove if undesired
  });
}

function maybeShowTagBubble(){
  if (!selectedWordIdxs.size) return;
  const idxs = [...selectedWordIdxs].sort((a,b)=>a-b);
  const text = idxs.map(i => wordElems[i]?.textContent ?? "").join(" ").trim();
  if (!text) return;
  const rect = unionClientRect(idxs.map(i=>wordElems[i].getBoundingClientRect()));
  showTagBubble(text, rect);
}

/* =========================
   Tag bubble (chip cloud)
   ========================= */
function showTagBubble(selectedText, rect){
  removeTagBubble(); // clean any previous
  const phrase = selectedText.trim().replace(/\s+/g,' ');
  if (!phrase) return;

  const b = document.createElement("div");
  b.className = "floating-tag";

  const selLabel = document.createElement("div");
  selLabel.className = "sel";
  selLabel.textContent = `Selection: “${phrase}”`;

  const cloudRow = document.createElement("div");
  cloudRow.className = "row";
  categories.forEach(c=>{
    const chip = document.createElement("button");
    chip.type="button";
    chip.className="tag-chip";
    const dot = document.createElement("span");
    dot.className="dot";
    dot.style.background = getColor(c.key);
    const lbl = document.createElement("span");
    lbl.textContent = c.key;
    chip.append(dot,lbl);
    chip.addEventListener("click", ()=>{
      foundByCategory[c.key] = foundByCategory[c.key] || new Set();
      foundByCategory[c.key].add(phrase);
      replacements[phrase] = replacements[phrase] ?? phrase;
      if (lockCb.checked) lockedSections.add(phrase);
      renderPreview();
      renderSwapPanel();
      removeTagBubble(); // close after successful tag
    });
    cloudRow.appendChild(chip);
  });

  const controls = document.createElement("div");
  controls.className = "row";
  const lockCb = document.createElement("input");
  lockCb.type="checkbox"; lockCb.id="lockSel";
  const lockLb = document.createElement("label");
  lockLb.htmlFor="lockSel"; lockLb.textContent="Lock selection";
  const cancel = document.createElement("button");
  cancel.textContent="Cancel";
  cancel.type="button";
  cancel.addEventListener("click", removeTagBubble);
  controls.append(lockCb, lockLb, cancel);

  // Position + mount
  b.style.top  = `${rect.bottom+window.scrollY+6}px`;
  b.style.left = `${rect.left+window.scrollX}px`;
  b.append(selLabel, cloudRow, controls);
  document.body.appendChild(b);

  // Outside-click handling (don’t immediately close on the same event)
  activeBubbleEl = b;
  bubbleGuard = true;
  setTimeout(()=>{ bubbleGuard = false; }, 0);
  bubbleOutsideListener = (ev)=>{
    if (bubbleGuard) return;
    if (!activeBubbleEl) return;
    if (!activeBubbleEl.contains(ev.target)) removeTagBubble();
  };
  document.addEventListener('pointerdown', bubbleOutsideListener, true);
}

function removeTagBubble(){
  if (activeBubbleEl?.parentNode) activeBubbleEl.parentNode.removeChild(activeBubbleEl);
  activeBubbleEl = null;
  if (bubbleOutsideListener) {
    document.removeEventListener('pointerdown', bubbleOutsideListener, true);
    bubbleOutsideListener = null;
  }
}

/* =========================
   Swap panel
   ========================= */
function renderSwapPanel(){
  const panel=elements.swapPanel;
  panel.innerHTML="";

  for (const c of categories){
    const terms=Array.from(foundByCategory[c.key]||[]);
    if(!terms.length) continue;

    const card=document.createElement("div");
    card.className="swap-card";

    const h=document.createElement("h3");
    const dot=document.createElement("span");
    dot.className="dot";
    dot.style.background=getColor(c.key);
    const label=document.createElement("span");
    label.textContent=c.key;
    h.append(dot,label);
    card.appendChild(h);

    terms.forEach(term=>{
      const wrap=document.createElement("div");
      wrap.className="swap-item";
      const lab=document.createElement("label");
      lab.textContent=term;
      const inp=document.createElement("input");
      inp.value=replacements[term]??term;
      inp.dataset.key=term;
      inp.addEventListener("input",(e)=>{
        replacements[term]=e.target.value;
        renderPreview();
      });
      wrap.append(lab,inp);
      card.appendChild(wrap);
    });

    panel.appendChild(card);
  }
}

/* =========================
   Copy / edit / inline edit
   ========================= */
function copyOutput(){
  const content=elements.livePreview.textContent;
  if(!content) return;
  navigator.clipboard.writeText(content).then(flashCopied);
}
function flashCopied(){
  elements.copyPlain.textContent="Copied!";
  setTimeout(()=>elements.copyPlain.textContent="Copy Prompt",1000);
}

function toggleEdit(){
  const isDisabled=elements.input.disabled;
  elements.input.disabled=!isDisabled;
  if(!elements.input.disabled){ elements.input.focus(); }
  else { runParse(); }
}

function enableInlineEditing(){
  elements.highlightView.onclick=(e)=>{
    const span=e.target.closest(".highlight");
    if(!span || elements.input.disabled===false) return;
    const original=span.textContent;
    const input=document.createElement("input");
    input.value=original;
    input.style.minWidth="120px";
    span.replaceWith(input);
    input.focus();
    const commit=()=>{
      for(const k of Object.keys(replacements)){
        if(k.toLowerCase()===original.toLowerCase()) replacements[k]=input.value;
      }
      renderPreview();
      renderSwapPanel();
    };
    input.addEventListener("blur",commit);
    input.addEventListener("keydown",(ev)=>{ if(ev.key==="Enter"){ input.blur(); } });
  };
}

/* =========================
   Selection helpers & utils
   ========================= */
function toggleIdx(i){ selectedWordIdxs.has(i) ? selectedWordIdxs.delete(i) : selectedWordIdxs.add(i); }
function buildRangeSet(a,b){ const s=new Set(); const [lo,hi]=a<=b?[a,b]:[b,a]; for(let i=lo;i<=hi;i++) s.add(i); return s; }
function unionSets(a,b){ const s=new Set(a); for(const x of b) s.add(x); return s; }
function updateWordSelectionClasses(){ wordElems.forEach((el,i)=>el.classList.toggle("selected", selectedWordIdxs.has(i))); }
function selectRange(a,b,add){ const r=buildRangeSet(a,b); selectedWordIdxs = add ? unionSets(selectedWordIdxs,r) : r; updateWordSelectionClasses(); }

function getColor(key){
  const cat=categories.find(c=>c.key===key);
  return getComputedStyle(document.documentElement).getPropertyValue(cat?.colorVar||"--border");
}

function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"); }
function isTitleCase(s){ return /^[A-Z][a-z]/.test(s); }
function toTitleCase(s){ return s.replace(/\w\S*/g,t=>t[0].toUpperCase()+t.slice(1).toLowerCase()); }
function debounce(fn,ms=250){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(this,args),ms); }; }
function unionClientRect(rects){
  const left = Math.min(...rects.map(r=>r.left));
  const top = Math.min(...rects.map(r=>r.top));
  const right = Math.max(...rects.map(r=>r.right));
  const bottom = Math.max(...rects.map(r=>r.bottom));
  return { left, top, right, bottom, width: right-left, height: bottom-top };
}

/* =========================
   Boot
   ========================= */
init();
  </script>
</body>
</html>
