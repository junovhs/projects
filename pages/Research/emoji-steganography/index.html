<!-- FILE: index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>StegoMoji: Secure Emoji Encoder</title>
  <style>
    :root {
      --primary: #2563eb;
      --surface: #ffffff;
      --bg: #f8fafc;
      --text: #1e293b;
      --border: #e2e8f0;
      --error: #ef4444;
      --success: #22c55e;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 2rem;
      line-height: 1.5;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      background: var(--surface);
      border-radius: 12px;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    header {
      background: var(--primary);
      color: white;
      padding: 1.5rem;
      text-align: center;
    }

    header h1 { margin: 0; font-size: 1.5rem; }
    header p { margin: 0.5rem 0 0; opacity: 0.9; font-size: 0.9rem; }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      padding: 2rem;
    }

    @media (max-width: 768px) { .grid { grid-template-columns: 1fr; } }

    .panel { display: flex; flex-direction: column; gap: 1rem; }
    
    label { font-weight: 600; font-size: 0.9rem; }
    
    textarea, input, select {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-family: inherit;
      box-sizing: border-box;
    }

    button {
      background: var(--primary);
      color: white;
      border: none;
      padding: 0.75rem;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    button:hover { opacity: 0.9; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    .result-box {
      background: var(--bg);
      padding: 1rem;
      border-radius: 6px;
      border: 1px dashed var(--border);
      min-height: 80px;
      word-break: break-all;
      font-family: monospace;
      font-size: 0.9rem;
    }

    .logs {
      grid-column: 1 / -1;
      background: #1e1e1e;
      color: #a5f3fc;
      padding: 1rem;
      border-radius: 6px;
      font-family: monospace;
      font-size: 0.85rem;
      height: 150px;
      overflow-y: auto;
    }

    .status { font-size: 0.8rem; margin-top: -0.5rem; color: #64748b; }
  </style>
</head>
<body>

<div class="container">
  <header>
    <h1>StegoMoji v2.0</h1>
    <p>High-Capacity, Robust, Encrypted Emoji Steganography</p>
  </header>

  <div class="grid">
    <!-- ENCODER -->
    <div class="panel">
      <h2>Encode</h2>
      
      <div>
        <label for="coverText">Cover Text / Emoji</label>
        <input type="text" id="coverText" value="ðŸ˜Š" placeholder="Base emoji or text..." />
      </div>

      <div>
        <label for="secretInput">Secret Message</label>
        <textarea 
          id="secretInput" 
          rows="3" 
          placeholder="Secret text..." 
          autocomplete="off" 
          data-lpignore="true" 
          data-form-type="other"
        ></textarea>
      </div>

      <div>
        <label for="fileInput">Or Upload File (Max 5MB)</label>
        <input type="file" id="fileInput" />
      </div>

      <div>
        <label for="encPassword">Encryption Password</label>
        <input type="password" id="encPassword" placeholder="Optional AES-256..." />
      </div>

      <button id="btnEncode">Encode Message</button>
      
      <div>
        <label>Output (Copy This)</label>
        <div id="outputEncoded" class="result-box" contenteditable="true"></div>
      </div>
    </div>

    <!-- DECODER -->
    <div class="panel">
      <h2>Decode</h2>
      
      <div>
        <label for="decodeInput">Paste Encoded Text</label>
        <textarea id="decodeInput" rows="4" placeholder="Paste text with hidden data..."></textarea>
      </div>

      <div>
        <label for="decPassword">Decryption Password</label>
        <input type="password" id="decPassword" placeholder="Required if encrypted..." />
      </div>

      <button id="btnDecode">Decode Message</button>

      <div>
        <label>Decoded Result</label>
        <div id="outputDecoded" class="result-box"></div>
      </div>
      
      <div id="downloadSection" style="display:none;">
        <button id="btnDownload" style="background: var(--success);">Download File</button>
      </div>
    </div>

    <!-- LOGS -->
    <div class="logs" id="logPanel"></div>
  </div>
</div>

<script>
/**
 * STRICT CONFIGURATION & CONSTANTS
 * Follows: "Decision Trees -> Step 2: Structure"
 */
const CONFIG = {
  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB limit
  MAX_LOOP_ITER: 1_000_000,       // Hard loop bound
  CHUNK_SIZE: 1024 * 64,          // Process in 64KB chunks
  TIMEOUT_MS: 5000,               // Async timeout
  ALGO_AES: 'AES-GCM',
  ALGO_KDF: 'PBKDF2',
  SALT_LEN: 16,
  IV_LEN: 12
};

// Zero-Width Alphabet: Encodes 2 bits per char
// 00 -> U+200B (Zero Width Space)
// 01 -> U+200C (Zero Width Non-Joiner)
// 10 -> U+200D (Zero Width Joiner)
// 11 -> U+2060 (Word Joiner)
const ZWC_MAP = ['\u200B', '\u200C', '\u200D', '\u2060'];
const REVERSE_ZWC_MAP = {};
ZWC_MAP.forEach((c, i) => REVERSE_ZWC_MAP[c] = i);

/**
 * LOGGING SYSTEM
 * Follows: "Step 5: Instrumentation"
 */
const Logger = {
  el: document.getElementById('logPanel'),
  log(level, msg) {
    const ts = new Date().toISOString().split('T')[1].split('.')[0];
    const entry = `[${ts}] [${level}] ${msg}`;
    const div = document.createElement('div');
    div.textContent = entry;
    div.style.color = level === 'ERR' ? '#ff9999' : '#a5f3fc';
    this.el.appendChild(div);
    this.el.scrollTop = this.el.scrollHeight;
    console.log(entry);
  },
  info(msg) { this.log('INF', msg); },
  error(msg) { this.log('ERR', msg); },
  clear() { this.el.innerHTML = ''; }
};

/**
 * ASSERTION UTILS
 * Follows: "Step 0: Guardrails -> Assertions adequate"
 */
function assert(condition, message) {
  if (!condition) {
    Logger.error(`Assertion Failed: ${message}`);
    throw new Error(message);
  }
}

function assertType(val, type, name) {
  assert(typeof val === type, `${name} must be ${type}`);
}

/**
 * HAMMING(7,4) ERROR CORRECTION
 * Follows: "Step 1: Choose Approach -> Robustness"
 * Encodes 4 data bits into 7 bits (single bit correction).
 */
const Hamming = {
  // G Matrix (Generator) logic embedded
  encodeNibble(n) {
    assert(n >= 0 && n <= 15, "Nibble out of range");
    const d1 = (n >> 3) & 1;
    const d2 = (n >> 2) & 1;
    const d3 = (n >> 1) & 1;
    const d4 = (n >> 0) & 1;

    const p1 = d1 ^ d2 ^ d4;
    const p2 = d1 ^ d3 ^ d4;
    const p3 = d2 ^ d3 ^ d4;

    // Layout: p1 p2 d1 p3 d2 d3 d4
    return (p1 << 6) | (p2 << 5) | (d1 << 4) | (p3 << 3) | (d2 << 2) | (d3 << 1) | d4;
  },

  // H Matrix (Parity Check) logic embedded
  decodeByte(v) {
    // Helper to extract bits from the 7-bit integer
    const getBit = (val, pos) => (val >> pos) & 1;
    
    const p1 = getBit(v, 6);
    const p2 = getBit(v, 5);
    const d1 = getBit(v, 4);
    const p3 = getBit(v, 3);
    const d2 = getBit(v, 2);
    const d3 = getBit(v, 1);
    const d4 = getBit(v, 0);

    const s1 = p1 ^ d1 ^ d2 ^ d4;
    const s2 = p2 ^ d1 ^ d3 ^ d4;
    const s3 = p3 ^ d2 ^ d3 ^ d4;
    
    const syndrome = (s3 << 2) | (s2 << 1) | s1; // Note order: s3, s2, s1 maps to H columns

    if (syndrome === 0) return (d1 << 3) | (d2 << 2) | (d3 << 1) | d4;

    // Error correction logic
    // Syndrome maps to bit position (1-based index in p1..d4 sequence logic)
    // Simplified correction map for layout p1 p2 d1 p3 d2 d3 d4
    // Logic: Flip the bit that matches syndrome.
    // Due to complexity of manual mapping, we log correction and return raw if unsure.
    // For this demo, strict fail or basic correction.
    // Let's implement correction for robustness.
    let corrected = v;
    
    // Map syndrome to bit index to flip (0-6)
    // s1(1) s2(2) s3(4)
    // 001=p1, 010=p2, 011=d1, 100=p3, 101=d2, 110=d3, 111=d4
    if (syndrome === 1) corrected ^= (1<<6); // p1
    if (syndrome === 2) corrected ^= (1<<5); // p2
    if (syndrome === 3) corrected ^= (1<<4); // d1
    if (syndrome === 4) corrected ^= (1<<3); // p3
    if (syndrome === 5) corrected ^= (1<<2); // d2
    if (syndrome === 6) corrected ^= (1<<1); // d3
    if (syndrome === 7) corrected ^= (1<<0); // d4
    
    // Re-extract
    const cd1 = getBit(corrected, 4);
    const cd2 = getBit(corrected, 2);
    const cd3 = getBit(corrected, 1);
    const cd4 = getBit(corrected, 0);
    
    return (cd1 << 3) | (cd2 << 2) | (cd3 << 1) | cd4;
  }
};

/**
 * CRYPTO MODULE
 * Follows: "Step 3: Errors -> Graceful degrade"
 */
const CryptoEngine = {
  async getKey(password, salt, usage) {
    const enc = new TextEncoder();
    const keyMat = await window.crypto.subtle.importKey(
      "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]
    );
    return window.crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt: salt,
        iterations: 100000,
        hash: "SHA-256"
      },
      keyMat,
      { name: "AES-GCM", length: 256 },
      false,
      usage
    );
  },

  async encrypt(data, password) {
    assert(data instanceof Uint8Array, "Encrypt input must be Uint8Array");
    const salt = window.crypto.getRandomValues(new Uint8Array(CONFIG.SALT_LEN));
    const iv = window.crypto.getRandomValues(new Uint8Array(CONFIG.IV_LEN));
    const key = await this.getKey(password, salt, ["encrypt"]);
    
    const ctBuffer = await window.crypto.subtle.encrypt(
      { name: CONFIG.ALGO_AES, iv: iv }, key, data
    );
    
    // Combine Salt + IV + Ciphertext
    const res = new Uint8Array(salt.length + iv.length + ctBuffer.byteLength);
    res.set(salt, 0);
    res.set(iv, salt.length);
    res.set(new Uint8Array(ctBuffer), salt.length + iv.length);
    return res;
  },

  async decrypt(packed, password) {
    assert(packed instanceof Uint8Array, "Decrypt input must be Uint8Array");
    if (packed.length < CONFIG.SALT_LEN + CONFIG.IV_LEN) throw new Error("Data too short");

    const salt = packed.slice(0, CONFIG.SALT_LEN);
    const iv = packed.slice(CONFIG.SALT_LEN, CONFIG.SALT_LEN + CONFIG.IV_LEN);
    const ct = packed.slice(CONFIG.SALT_LEN + CONFIG.IV_LEN);

    const key = await this.getKey(password, salt, ["decrypt"]);
    const decBuffer = await window.crypto.subtle.decrypt(
      { name: CONFIG.ALGO_AES, iv: iv }, key, ct
    );
    return new Uint8Array(decBuffer);
  }
};

/**
 * COMPRESSION MODULE
 * Follows: "Step 1: Choose Approach -> CompressionStream"
 */
const Compressor = {
  async compress(data) {
    // Use GZIP via CompressionStream (modern browsers)
    if (!window.CompressionStream) return data; // Fallback
    const ds = new CompressionStream('gzip');
    const writer = ds.writable.getWriter();
    writer.write(data);
    writer.close();
    return new Response(ds.readable).arrayBuffer().then(b => new Uint8Array(b));
  },
  async decompress(data) {
    if (!window.DecompressionStream) return data;
    try {
      const ds = new DecompressionStream('gzip');
      const writer = ds.writable.getWriter();
      writer.write(data);
      writer.close();
      return await new Response(ds.readable).arrayBuffer().then(b => new Uint8Array(b));
    } catch (e) {
      Logger.error("Decompression failed, assuming raw data");
      return data;
    }
  }
};

/**
 * CORE STEGANOGRAPHY LOGIC
 * Follows: "Step 2: Structure"
 */
const StegoCore = {
  // Convert Byte Array -> Hamming74 Bits -> ZWCs
  encode(buffer) {
    assert(buffer instanceof Uint8Array, "Input must be Uint8Array");
    let output = "";
    let loopGuard = 0;

    // Process byte by byte
    for (let i = 0; i < buffer.length; i++) {
      if (loopGuard++ > CONFIG.MAX_LOOP_ITER) throw new Error("Encoding Loop Exceeded");

      const byte = buffer[i];
      const high = (byte >> 4) & 0xF;
      const low = byte & 0xF;

      // Hamming Encode (4 bits -> 7 bits)
      const hHigh = Hamming.encodeNibble(high); // 7 bits
      const hLow = Hamming.encodeNibble(low);   // 7 bits

      // We have 14 bits total. We map to ZWC (2 bits per char).
      // 14 bits -> 7 ZWCs
      const bits14 = (hHigh << 7) | hLow; // Combine to 14 bits

      // Extract pairs and map
      for (let j = 6; j >= 0; j--) {
        const shift = j * 2;
        const pair = (bits14 >> shift) & 0x3; // Get 2 bits
        output += ZWC_MAP[pair];
      }
    }
    return output;
  },

  decode(zwcString) {
    assertType(zwcString, 'string', 'ZWC String');
    if (zwcString.length % 7 !== 0) {
      Logger.error("Invalid ZWC length (ECC requires blocks of 7 chars)");
      throw new Error("Data corrupted or incomplete");
    }

    const byteCount = zwcString.length / 7;
    const result = new Uint8Array(byteCount);
    let loopGuard = 0;

    for (let i = 0; i < byteCount; i++) {
      if (loopGuard++ > CONFIG.MAX_LOOP_ITER) throw new Error("Decoding Loop Exceeded");
      
      let bits14 = 0;
      // Read 7 chars (14 bits)
      for (let j = 0; j < 7; j++) {
        const char = zwcString[i * 7 + j];
        const val = REVERSE_ZWC_MAP[char];
        if (val === undefined) throw new Error("Invalid ZWC detected");
        bits14 = (bits14 << 2) | val;
      }

      // Split into two 7-bit Hamming blocks
      const hHigh = (bits14 >> 7) & 0x7F;
      const hLow = bits14 & 0x7F;

      // Hamming Decode
      const high = Hamming.decodeByte(hHigh);
      const low = Hamming.decodeByte(hLow);

      result[i] = (high << 4) | low;
    }
    return result;
  }
};

/**
 * UI CONTROLLER
 * Follows: "Step 4: Determinism -> Event Loop"
 */
const App = {
  state: {
    decodedFile: null,
    decodedName: null
  },

  init() {
    this.bindEvents();
    Logger.info("System Ready. Secure Environment Initialized.");
  },

  bindEvents() {
    document.getElementById('btnEncode').addEventListener('click', () => this.handleEncode());
    document.getElementById('btnDecode').addEventListener('click', () => this.handleDecode());
    document.getElementById('btnDownload').addEventListener('click', () => this.handleDownload());
  },

  async handleEncode() {
    try {
      Logger.clear();
      const cover = document.getElementById('coverText').value || "ðŸ˜Š";
      const secret = document.getElementById('secretInput').value;
      const password = document.getElementById('encPassword').value;
      const fileInput = document.getElementById('fileInput').files[0];

      if (!secret && !fileInput) throw new Error("No data to encode");

      Logger.info("Starting Encoding Process...");

      // 1. Prepare Payload
      let rawData;
      let fileName = "";
      
      if (fileInput) {
        if (fileInput.size > CONFIG.MAX_FILE_SIZE) throw new Error("File too large");
        rawData = new Uint8Array(await fileInput.arrayBuffer());
        fileName = fileInput.name;
        Logger.info(`Loaded file: ${fileName} (${rawData.length} bytes)`);
      } else {
        rawData = new TextEncoder().encode(secret);
        Logger.info(`Loaded text (${rawData.length} bytes)`);
      }

      // 2. Create Header [Type(1)][NameLen(1)][Name(...)]
      const nameBytes = new TextEncoder().encode(fileName);
      const nameLen = nameBytes.length;
      const header = new Uint8Array(2 + nameLen);
      header[0] = fileInput ? 1 : 0; // Type: 0=Text, 1=File
      header[1] = nameLen;
      header.set(nameBytes, 2);

      // Combine Header + Body
      const combined = new Uint8Array(header.length + rawData.length);
      combined.set(header, 0);
      combined.set(rawData, header.length);

      // 3. Compress
      Logger.info("Compressing data...");
      const compressed = await Compressor.compress(combined);
      Logger.info(`Compressed to ${compressed.length} bytes`);

      // 4. Encrypt (Optional)
      let processed = compressed;
      if (password) {
        Logger.info("Encrypting with AES-256-GCM...");
        processed = await CryptoEngine.encrypt(compressed, password);
        // Prepend Marker [0xFF] to indicate encryption
        const encMarked = new Uint8Array(processed.length + 1);
        encMarked[0] = 0xFF; 
        encMarked.set(processed, 1);
        processed = encMarked;
      } else {
        // Prepend Marker [0x00] for plain
        const plainMarked = new Uint8Array(processed.length + 1);
        plainMarked[0] = 0x00;
        plainMarked.set(processed, 1);
        processed = plainMarked;
      }

      // 5. Encode to ZWC
      Logger.info("Encoding to High-Density ZWC with ECC...");
      const zwcString = StegoCore.encode(processed);

      // 6. Inject
      // Insert ZWC after the first character of cover for stealth
      // or append. Appending is safer for rendering.
      // We wrap: [Cover] + [ZWC]
      const result = cover + zwcString;
      
      document.getElementById('outputEncoded').textContent = result;
      Logger.info(`Success! Encoded size: ${zwcString.length} chars.`);
      
    } catch (e) {
      Logger.error(e.message);
    }
  },

  async handleDecode() {
    try {
      Logger.clear();
      const input = document.getElementById('decodeInput').value;
      const password = document.getElementById('decPassword').value;
      
      if (!input) throw new Error("Input empty");

      Logger.info("Scanning for hidden data...");

      // 1. Extract ZWCs
      // Filter input for only our ZWC alphabet
      let zwcString = "";
      const validSet = new Set(ZWC_MAP);
      for (const char of input) {
        if (validSet.has(char)) zwcString += char;
      }

      if (zwcString.length === 0) throw new Error("No hidden data found");
      Logger.info(`Found ${zwcString.length} hidden characters.`);

      // 2. Decode ZWC & ECC
      Logger.info("Decoding ECC and unpacking bits...");
      const decodedBytes = StegoCore.decode(zwcString);
      
      // 3. Check Encryption Marker
      const isEncrypted = decodedBytes[0] === 0xFF;
      let payload = decodedBytes.slice(1);

      if (isEncrypted) {
        if (!password) throw new Error("Data is encrypted. Password required.");
        Logger.info("Decrypting...");
        payload = await CryptoEngine.decrypt(payload, password);
      }

      // 4. Decompress
      Logger.info("Decompressing...");
      const decompressed = await Compressor.decompress(payload);

      // 5. Parse Header
      const type = decompressed[0]; // 0=Text, 1=File
      const nameLen = decompressed[1];
      const nameBytes = decompressed.slice(2, 2 + nameLen);
      const content = decompressed.slice(2 + nameLen);
      const fileName = new TextDecoder().decode(nameBytes);

      // 6. Output
      const outDiv = document.getElementById('outputDecoded');
      const dlSection = document.getElementById('downloadSection');
      
      if (type === 0) {
        // Text
        const text = new TextDecoder().decode(content);
        outDiv.textContent = text;
        dlSection.style.display = 'none';
        Logger.info("Text decoded successfully.");
      } else {
        // File
        outDiv.textContent = `File detected: ${fileName} (${content.length} bytes)`;
        this.state.decodedFile = content;
        this.state.decodedName = fileName || "download.bin";
        dlSection.style.display = 'block';
        Logger.info("File ready for download.");
      }

    } catch (e) {
      Logger.error(e.message);
      document.getElementById('outputDecoded').textContent = "Error: " + e.message;
    }
  },

  handleDownload() {
    if (!this.state.decodedFile) return;
    const blob = new Blob([this.state.decodedFile]);
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = this.state.decodedName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
};

// START
App.init();

</script>
</body>
</html>