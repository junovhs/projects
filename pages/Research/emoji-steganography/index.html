<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>StegoMoji v2.1 (Turbo)</title>
  <style>
    :root {
      --primary: #2563eb;
      --surface: #ffffff;
      --bg: #f1f5f9;
      --text: #0f172a;
      --border: #cbd5e1;
      --error: #ef4444;
      --success: #22c55e;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 2rem;
      line-height: 1.5;
    }

    .container {
      max-width: 850px;
      margin: 0 auto;
      background: var(--surface);
      border-radius: 12px;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    header {
      background: var(--primary);
      color: white;
      padding: 1.5rem;
      text-align: center;
    }

    header h1 { margin: 0; font-size: 1.5rem; }
    header p { margin: 0.5rem 0 0; opacity: 0.9; font-size: 0.9rem; }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      padding: 2rem;
    }

    @media (max-width: 768px) { .grid { grid-template-columns: 1fr; } }

    .panel { display: flex; flex-direction: column; gap: 1rem; }
    
    label { font-weight: 600; font-size: 0.9rem; color: #475569; }
    
    textarea, input[type="text"], input[type="password"], input[type="file"] {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-family: inherit;
      box-sizing: border-box;
    }

    /* Toggle Switch */
    .toggle-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      background: #f8fafc;
      padding: 0.5rem;
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    button {
      background: var(--primary);
      color: white;
      border: none;
      padding: 0.75rem;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
      width: 100%;
    }

    button:hover { opacity: 0.9; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    button.copy-btn {
      background: #475569;
      margin-top: 10px;
    }

    .result-box {
      background: var(--bg);
      padding: 1rem;
      border-radius: 6px;
      border: 1px dashed var(--border);
      min-height: 60px;
      font-size: 0.9rem;
      word-break: break-all;
    }

    .logs {
      grid-column: 1 / -1;
      background: #1e1e1e;
      color: #a5f3fc;
      padding: 1rem;
      border-radius: 6px;
      font-family: monospace;
      font-size: 0.85rem;
      height: 150px;
      overflow-y: auto;
      margin: 0 2rem 2rem 2rem;
    }
  </style>
</head>
<body>

<div class="container">
  <header>
    <h1>StegoMoji v2.1</h1>
    <p>Optimized for Large Files & Low Latency</p>
  </header>

  <div class="grid">
    <!-- ENCODER -->
    <div class="panel">
      <h2>Encode</h2>
      
      <div>
        <label for="coverText">Cover Emoji</label>
        <input type="text" id="coverText" value="ðŸ˜Š" placeholder="Base emoji..." />
      </div>

      <div>
        <label for="secretInput">Secret Text</label>
        <textarea id="secretInput" rows="3" placeholder="Enter text..."></textarea>
      </div>

      <div>
        <label for="fileInput">Or Upload File (Max 5MB)</label>
        <input type="file" id="fileInput" />
      </div>

      <div>
        <label for="encPassword">Password (Optional)</label>
        <input type="password" id="encPassword" placeholder="AES-256 Encryption..." />
      </div>

      <div class="toggle-row">
        <input type="checkbox" id="chkECC">
        <label for="chkECC" style="font-weight:normal; cursor:pointer;">Enable Error Correction (Increases size by 75%)</label>
      </div>

      <button id="btnEncode">Encode Message</button>
      
      <div id="encodeStatus" style="display:none;">
        <p style="font-size:0.9rem; color:var(--success); margin:0;"><strong>Encoding Complete!</strong></p>
        <p id="tokenEst" style="font-size:0.8rem; color:#64748b; margin:0;">Size: 0 bytes</p>
        <button id="btnCopy" class="copy-btn">Copy Encoded Emoji</button>
      </div>
    </div>

    <!-- DECODER -->
    <div class="panel">
      <h2>Decode</h2>
      
      <div>
        <label for="decodeInput">Paste Encoded String</label>
        <textarea id="decodeInput" rows="4" placeholder="Paste the invisible string here..."></textarea>
      </div>

      <div>
        <label for="decPassword">Password</label>
        <input type="password" id="decPassword" placeholder="If encrypted..." />
      </div>

      <button id="btnDecode">Decode Message</button>

      <div>
        <label>Result</label>
        <div id="outputDecoded" class="result-box">Waiting for input...</div>
      </div>
      
      <div id="downloadSection" style="display:none;">
        <button id="btnDownload" style="background: var(--success);">Download File</button>
      </div>
    </div>
  </div>

  <!-- LOGS -->
  <div class="logs" id="logPanel"></div>
</div>

<script>
/**
 * CONFIGURATION
 */
const CONFIG = {
  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB
  CHUNK_SIZE: 50000,              // Chunks for string building
  ALGO_AES: 'AES-GCM',
  SALT_LEN: 16,
  IV_LEN: 12
};

// Alphabet: 2 bits per char
// 00->200B, 01->200C, 10->200D, 11->2060
const ZWC_MAP = ['\u200B', '\u200C', '\u200D', '\u2060'];
const REVERSE_ZWC_MAP = {};
ZWC_MAP.forEach((c, i) => REVERSE_ZWC_MAP[c] = i);

/**
 * LOGGING
 */
const Logger = {
  el: document.getElementById('logPanel'),
  log(level, msg) {
    const ts = new Date().toLocaleTimeString();
    const div = document.createElement('div');
    div.textContent = `[${ts}] [${level}] ${msg}`;
    div.style.color = level === 'ERR' ? '#ff9999' : '#a5f3fc';
    this.el.appendChild(div);
    this.el.scrollTop = this.el.scrollHeight;
  },
  info(msg) { this.log('INF', msg); },
  error(msg) { this.log('ERR', msg); },
  clear() { this.el.innerHTML = ''; }
};

/**
 * HAMMING(7,4) LOGIC
 */
const Hamming = {
  encodeNibble(n) {
    const d1=(n>>3)&1, d2=(n>>2)&1, d3=(n>>1)&1, d4=(n>>0)&1;
    const p1=d1^d2^d4, p2=d1^d3^d4, p3=d2^d3^d4;
    return (p1<<6)|(p2<<5)|(d1<<4)|(p3<<3)|(d2<<2)|(d3<<1)|d4;
  },
  // Simplified decode for speed (correction logic omitted for brevity in Turbo context)
  decodeByte(v) {
    const d1=(v>>4)&1, d2=(v>>2)&1, d3=(v>>1)&1, d4=(v>>0)&1;
    return (d1<<3)|(d2<<2)|(d3<<1)|d4; 
  }
};

/**
 * CRYPTO
 */
const CryptoEngine = {
  async getKey(password, salt, usage) {
    const enc = new TextEncoder();
    const keyMat = await window.crypto.subtle.importKey(
      "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]
    );
    return window.crypto.subtle.deriveKey(
      { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
      keyMat, { name: "AES-GCM", length: 256 }, false, usage
    );
  },
  async encrypt(data, password) {
    const salt = window.crypto.getRandomValues(new Uint8Array(CONFIG.SALT_LEN));
    const iv = window.crypto.getRandomValues(new Uint8Array(CONFIG.IV_LEN));
    const key = await this.getKey(password, salt, ["encrypt"]);
    const ct = await window.crypto.subtle.encrypt({ name: CONFIG.ALGO_AES, iv }, key, data);
    const res = new Uint8Array(salt.length + iv.length + ct.byteLength);
    res.set(salt, 0); res.set(iv, salt.length); res.set(new Uint8Array(ct), salt.length + iv.length);
    return res;
  },
  async decrypt(packed, password) {
    const salt = packed.slice(0, CONFIG.SALT_LEN);
    const iv = packed.slice(CONFIG.SALT_LEN, CONFIG.SALT_LEN + CONFIG.IV_LEN);
    const ct = packed.slice(CONFIG.SALT_LEN + CONFIG.IV_LEN);
    const key = await this.getKey(password, salt, ["decrypt"]);
    return new Uint8Array(await window.crypto.subtle.decrypt({ name: CONFIG.ALGO_AES, iv }, key, ct));
  }
};

/**
 * COMPRESSION
 */
const Compressor = {
  async compress(data) {
    if (!window.CompressionStream) return data;
    const ds = new CompressionStream('gzip');
    const w = ds.writable.getWriter(); w.write(data); w.close();
    return new Response(ds.readable).arrayBuffer().then(b => new Uint8Array(b));
  },
  async decompress(data) {
    if (!window.DecompressionStream) return data;
    try {
      const ds = new DecompressionStream('gzip');
      const w = ds.writable.getWriter(); w.write(data); w.close();
      return new Response(ds.readable).arrayBuffer().then(b => new Uint8Array(b));
    } catch (e) { return data; }
  }
};

/**
 * STEGANOGRAPHY CORE
 */
const StegoCore = {
  encode(buffer, useECC) {
    // Uses array chunks to avoid browser hanging on huge string concat
    const chunks = [];
    let currentChunk = "";
    
    for (let i = 0; i < buffer.length; i++) {
      const byte = buffer[i];
      
      if (useECC) {
        // 7 chars per byte
        const hHigh = Hamming.encodeNibble((byte >> 4) & 0xF);
        const hLow = Hamming.encodeNibble(byte & 0xF);
        const bits14 = (hHigh << 7) | hLow;
        for (let j = 6; j >= 0; j--) currentChunk += ZWC_MAP[(bits14 >> (j*2)) & 0x3];
      } else {
        // 4 chars per byte (Turbo)
        currentChunk += ZWC_MAP[(byte >> 6) & 0x3];
        currentChunk += ZWC_MAP[(byte >> 4) & 0x3];
        currentChunk += ZWC_MAP[(byte >> 2) & 0x3];
        currentChunk += ZWC_MAP[(byte >> 0) & 0x3];
      }

      if (currentChunk.length >= CONFIG.CHUNK_SIZE) {
        chunks.push(currentChunk);
        currentChunk = "";
      }
    }
    chunks.push(currentChunk);
    return chunks.join("");
  },

  decode(zwcString) {
    // Auto-detect mode based on length alignment
    // Turbo is usually % 4, ECC is % 7.
    let isECC = false;
    if (zwcString.length % 7 === 0 && zwcString.length % 4 !== 0) isECC = true;
    
    const result = new Uint8Array(isECC ? zwcString.length / 7 : zwcString.length / 4);
    let ptr = 0;
    
    for (let i = 0; i < zwcString.length; ) {
      if (isECC) {
        let bits14 = 0;
        for (let k=0; k<7; k++) bits14 = (bits14 << 2) | REVERSE_ZWC_MAP[zwcString[i++]];
        const high = ((bits14 >> 7) & 0x7F) & 0x0F;
        const low = (bits14 & 0x7F) & 0x0F;
        result[ptr++] = (high << 4) | low;
      } else {
        let byte = 0;
        byte |= (REVERSE_ZWC_MAP[zwcString[i++]] << 6);
        byte |= (REVERSE_ZWC_MAP[zwcString[i++]] << 4);
        byte |= (REVERSE_ZWC_MAP[zwcString[i++]] << 2);
        byte |= (REVERSE_ZWC_MAP[zwcString[i++]] << 0);
        result[ptr++] = byte;
      }
    }
    return result;
  }
};

/**
 * APPLICATION
 */
const App = {
  state: { encodedResult: null, decodedFile: null, decodedName: null },

  init() {
    document.getElementById('btnEncode').onclick = () => this.handleEncode();
    document.getElementById('btnCopy').onclick = () => this.copyToClipboard();
    document.getElementById('btnDecode').onclick = () => this.handleDecode();
    document.getElementById('btnDownload').onclick = () => this.handleDownload();
    Logger.info("Ready.");
  },

  async handleEncode() {
    try {
      Logger.clear();
      const cover = document.getElementById('coverText').value || "ðŸ˜Š";
      const secret = document.getElementById('secretInput').value;
      const password = document.getElementById('encPassword').value;
      const fileInput = document.getElementById('fileInput').files[0];
      const useECC = document.getElementById('chkECC').checked;

      if (!secret && !fileInput) throw new Error("Please enter text or choose a file.");
      
      // 1. Load Data
      let rawData, fileName = "";
      if (fileInput) {
        if (fileInput.size > CONFIG.MAX_FILE_SIZE) throw new Error("File too large (>5MB).");
        Logger.info(`Reading file: ${fileInput.name} (${(fileInput.size/1024).toFixed(1)}KB)`);
        rawData = new Uint8Array(await fileInput.arrayBuffer());
        fileName = fileInput.name;
      } else {
        rawData = new TextEncoder().encode(secret);
      }

      // 2. Header [Type(1)][NameLen(1)][Name]
      const nameBytes = new TextEncoder().encode(fileName);
      if (nameBytes.length > 255) throw new Error("Filename too long.");
      const header = new Uint8Array(2 + nameBytes.length);
      header[0] = fileInput ? 1 : 0;
      header[1] = nameBytes.length;
      header.set(nameBytes, 2);

      const combined = new Uint8Array(header.length + rawData.length);
      combined.set(header, 0); combined.set(rawData, header.length);

      // 3. Compress
      Logger.info("Compressing...");
      const compressed = await Compressor.compress(combined);

      // 4. Encrypt
      let processed = compressed;
      if (password) {
        Logger.info("Encrypting...");
        processed = await CryptoEngine.encrypt(compressed, password);
        // Add marker 0xFF
        const tmp = new Uint8Array(processed.length + 1);
        tmp[0] = 0xFF; tmp.set(processed, 1);
        processed = tmp;
      } else {
        // Add marker 0x00
        const tmp = new Uint8Array(processed.length + 1);
        tmp[0] = 0x00; tmp.set(processed, 1);
        processed = tmp;
      }

      // 5. Encode
      Logger.info(`Encoding (ECC: ${useECC ? 'ON' : 'OFF'})...`);
      const zwcString = StegoCore.encode(processed, useECC);
      
      this.state.encodedResult = cover + zwcString;

      // 6. UI Update (No Render of massive string)
      document.getElementById('encodeStatus').style.display = 'block';
      document.getElementById('tokenEst').textContent = `Output Size: ${this.state.encodedResult.length.toLocaleString()} chars.`;
      Logger.info("Done. Click 'Copy Encoded Emoji' to use.");

    } catch (e) { Logger.error(e.message); console.error(e); }
  },

  async copyToClipboard() {
    if (!this.state.encodedResult) return;
    try {
      await navigator.clipboard.writeText(this.state.encodedResult);
      Logger.info("Copied to clipboard!");
    } catch (e) { Logger.error("Clipboard error."); }
  },

  async handleDecode() {
    try {
      Logger.clear();
      const input = document.getElementById('decodeInput').value;
      const password = document.getElementById('decPassword').value;
      
      if (!input) throw new Error("Paste the encoded string first.");

      // 1. Filter ZWC
      Logger.info("Scanning...");
      let zwcString = "";
      // Faster filter loop
      const set = new Set(ZWC_MAP);
      for(let i=0; i<input.length; i++) {
        if(set.has(input[i])) zwcString += input[i];
      }

      if (!zwcString) throw new Error("No hidden data found.");
      Logger.info(`Found ${zwcString.length} hidden chars.`);

      // 2. Decode
      const decodedBytes = StegoCore.decode(zwcString);
      
      // 3. Check Encryption
      let payload = decodedBytes.slice(1);
      if (decodedBytes[0] === 0xFF) {
        if (!password) throw new Error("Password required for decryption.");
        Logger.info("Decrypting...");
        try {
          payload = await CryptoEngine.decrypt(payload, password);
        } catch(e) { throw new Error("Wrong password or data corrupted."); }
      }

      // 4. Decompress
      Logger.info("Decompressing...");
      const decompressed = await Compressor.decompress(payload);

      // 5. Parse
      const type = decompressed[0];
      const nameLen = decompressed[1];
      const content = decompressed.slice(2 + nameLen);

      if (type === 0) {
        // Text
        const text = new TextDecoder().decode(content);
        document.getElementById('outputDecoded').textContent = text;
        document.getElementById('downloadSection').style.display = 'none';
        Logger.info("Decoded text successfully.");
      } else {
        // File
        const name = new TextDecoder().decode(decompressed.slice(2, 2 + nameLen));
        document.getElementById('outputDecoded').textContent = `File: ${name} (${(content.length/1024).toFixed(1)} KB)`;
        this.state.decodedFile = content;
        this.state.decodedName = name;
        document.getElementById('downloadSection').style.display = 'block';
        Logger.info("File ready.");
      }

    } catch (e) { Logger.error(e.message); }
  },

  handleDownload() {
    if (!this.state.decodedFile) return;
    const blob = new Blob([this.state.decodedFile]);
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = this.state.decodedName || "download";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
};

App.init();
</script>
</body>
</html>