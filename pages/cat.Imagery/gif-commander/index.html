<script>
  // Access FFmpeg from global scope (UMD modules)
  const { FFmpeg } = window.FFmpegWASM || window.FFmpeg || {};
  const { fetchFile } = window.FFmpegUtil || {};

  console.log('Inline script loaded! Globals:', { FFmpeg: !!FFmpeg, fetchFile: !!fetchFile }); // Debug: Check globals

  class MediaConverter {
    constructor() {
      this.ffmpeg = null;
      this.files = [];
      this.isVideo = false;
      this.selectedFormat = 'mp4';
      this.processing = false;
      
      this.init();
    }

    init() {
      // Elements (unchanged)
      this.btnImageFolder = document.getElementById('btnImageFolder');
      this.btnImageFiles = document.getElementById('btnImageFiles');
      this.btnVideo = document.getElementById('btnVideo');
      this.btnExport = document.getElementById('btnExport');
      this.imageFiles = document.getElementById('imageFiles');
      this.folderInput = document.getElementById('folderInput');
      this.videoFile = document.getElementById('videoFile');
      this.fileInfo = document.getElementById('fileInfo');
      this.status = document.getElementById('status');
      this.progressBar = document.getElementById('progressBar');
      this.progressFill = document.getElementById('progressFill');
      this.previewContainer = document.getElementById('previewContainer');
      this.videoPreview = document.getElementById('videoPreview');
      this.imagePreview = document.getElementById('imagePreview');
      this.downloadBtn = document.getElementById('downloadBtn');
      this.ffmpegStatus = document.getElementById('ffmpegStatus');
      this.exportText = document.getElementById('exportText');
      this.fpsInput = document.getElementById('fps');
      this.widthInput = document.getElementById('width');
      this.qualityInput = document.getElementById('quality');

      // Events (unchanged)
      this.btnImageFolder.onclick = () => this.folderInput.click();
      this.btnImageFiles.onclick = () => this.imageFiles.click();
      this.btnVideo.onclick = () => this.videoFile.click();
      this.folderInput.onchange = (e) => this.loadImages(e.target.files);
      this.imageFiles.onchange = (e) => this.loadImages(e.target.files);
      this.videoFile.onchange = (e) => this.loadVideo(e.target.files[0]);
      this.btnExport.onclick = () => this.export();

      // Format selection (unchanged)
      document.querySelectorAll('.format-pill').forEach(pill => {
        pill.onclick = () => {
          document.querySelectorAll('.format-pill').forEach(p => p.classList.remove('selected'));
          pill.classList.add('selected');
          this.selectedFormat = pill.dataset.format;
          this.updateExportButton();
        };
      });

      // Presets (unchanged)
      document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.onclick = (e) => {
          document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          this.applyPreset(btn.dataset.preset);
        };
      });

      this.loadFFmpeg();
    }

    async loadFFmpeg() {
      const baseURL = window.location.origin; // Always use full base for reliability
      console.log('Starting FFmpeg load from:', baseURL + '/lib/'); // Debug

      try {
        if (!FFmpeg) {
          throw new Error('FFmpeg constructor not found - check if /lib/ffmpeg.js loaded');
        }

        this.ffmpeg = new FFmpeg();
        
        this.ffmpeg.on('log', ({ message }) => {
          console.log('FFmpeg Log:', message); // Enhanced logging
        });

        this.ffmpeg.on('progress', ({ progress }) => {
          if (this.processing) {
            const percent = Math.round(progress * 100);
            this.updateProgress(percent);
          }
        });

        // Load with FULL URLs (more reliable on Vercel/static hosts)
        console.log('Loading FFmpeg core...');
        await Promise.race([
          this.ffmpeg.load({
            coreURL: `${baseURL}/lib/ffmpeg-core.js`,
            wasmURL: `${baseURL}/lib/ffmpeg-core.wasm`
          }),
          new Promise((_, reject) => setTimeout(() => reject(new Error('FFmpeg load timeout (30s)')), 30000))
        ]);

        console.log('FFmpeg loaded successfully!');
        this.ffmpegStatus.innerHTML = '✅ Ready to convert!';
        this.ffmpegStatus.classList.add('ready');
        this.btnExport.disabled = false; // Enable export once loaded
        
      } catch (err) {
        console.error('FFmpeg load error:', err); // This WILL log now
        this.ffmpegStatus.innerHTML = `⚠️ Video encoder failed to load: ${err.message}. Try refreshing or check console.`;
        this.ffmpegStatus.classList.add('error');
      }
    }

    // ... (Rest of methods unchanged: applyPreset, loadImages, loadVideo, updateExportButton, export, exportMP4, exportWebM, exportWebP, showResult, setStatus, updateProgress)
    applyPreset(preset) {
      const presets = {
        social: { fps: 30, width: 1280, quality: 'medium' },
        hq: { fps: 24, width: 1920, quality: 'high' },
        small: { fps: 24, width: 854, quality: 'low' }
      };
      const p = presets[preset];
      this.fpsInput.value = p.fps;
      this.widthInput.value = p.width;
      this.qualityInput.value = p.quality;
    }

    loadImages(fileList) {
      const files = Array.from(fileList).filter(f => 
        /\.(png|jpe?g|webp|gif|bmp)$/i.test(f.name)
      );
      
      if (files.length === 0) {
        this.setStatus('No valid image files found');
        return;
      }

      files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));
      
      this.files = files;
      this.isVideo = false;
      this.fileInfo.textContent = `${files.length} images loaded`;
      this.fileInfo.classList.add('has-files');
      this.btnExport.disabled = false;
      this.setStatus(`Ready to export ${files.length} images`);
    }

    loadVideo(file) {
      if (!file) return;
      
      this.files = [file];
      this.isVideo = true;
      this.fileInfo.textContent = `Video: ${file.name} (${(file.size/1024/1024).toFixed(1)} MB)`;
      this.fileInfo.classList.add('has-files');
      this.btnExport.disabled = false;
      this.setStatus('Ready to convert video');
    }

    updateExportButton() {
      const labels = {
        mp4: 'Export as MP4',
        webm: 'Export as WebM',
        webp: 'Export as WebP Animation'
      };
      this.exportText.textContent = labels[this.selectedFormat];
    }

    async export() {
      if (!this.ffmpeg || this.processing) {
        this.setStatus('Encoder not ready. Please wait or refresh the page.');
        return;
      }

      this.processing = true;
      this.btnExport.disabled = true;
      this.progressBar.style.display = 'block';

      try {
        const fps = parseInt(this.fpsInput.value) || 24;
        const width = parseInt(this.widthInput.value) || 1280;
        const quality = this.qualityInput.value;

        if (this.selectedFormat === 'mp4') {
          await this.exportMP4(fps, width, quality);
        } else if (this.selectedFormat === 'webm') {
          await this.exportWebM(fps, width, quality);
        } else if (this.selectedFormat === 'webp') {
          await this.exportWebP(fps, width, quality);
        }
      } catch (err) {
        console.error('Export error:', err);
        this.setStatus(`Error: ${err.message}`);
      } finally {
        this.processing = false;
        this.btnExport.disabled = false;
      }
    }

    async exportMP4(fps, width, quality) {
      this.setStatus('Preparing files...');
      
      const qualitySettings = {
        low: { crf: '28', preset: 'veryfast' },
        medium: { crf: '23', preset: 'medium' },
        high: { crf: '18', preset: 'slow' }
      };
      const q = qualitySettings[quality];

      if (this.isVideo) {
        const videoData = await fetchFile(this.files[0]);
        await this.ffmpeg.writeFile('input.mp4', videoData);
        
        this.setStatus('Converting to MP4...');
        await this.ffmpeg.exec([
          '-i', 'input.mp4',
          '-t', '20',
          '-vf', `scale=${width}:-2`,
          '-c:v', 'libx264',
          '-preset', q.preset,
          '-crf', q.crf,
          '-pix_fmt', 'yuv420p',
          '-movflags', '+faststart',
          '-an',
          'output.mp4'
        ]);
        
        await this.ffmpeg.deleteFile('input.mp4');
      } else {
        this.setStatus(`Loading ${this.files.length} images...`);
        for (let i = 0; i < this.files.length; i++) {
          const data = await fetchFile(this.files[i]);
          await this.ffmpeg.writeFile(`img${String(i).padStart(4, '0')}.png`, data);
          this.updateProgress((i / this.files.length) * 40);
        }
        
        this.setStatus('Encoding MP4 video...');
        await this.ffmpeg.exec([
          '-framerate', String(fps),
          '-i', 'img%04d.png',
          '-t', '20',
          '-vf', `scale=${width}:-2`,
          '-c:v', 'libx264',
          '-preset', q.preset,
          '-crf', q.crf,
          '-pix_fmt', 'yuv420p',
          '-movflags', '+faststart',
          'output.mp4'
        ]);
        
        for (let i = 0; i < this.files.length; i++) {
          await this.ffmpeg.deleteFile(`img${String(i).padStart(4, '0')}.png`);
        }
      }

      const data = await this.ffmpeg.readFile('output.mp4');
      await this.ffmpeg.deleteFile('output.mp4');
      
      const blob = new Blob([data.buffer], { type: 'video/mp4' });
      this.showResult(blob, 'output.mp4', 'video');
    }

    async exportWebM(fps, width, quality) {
      this.setStatus('Preparing files...');
      
      const qualitySettings = {
        low: { crf: '35', cpuUsed: '5' },
        medium: { crf: '31', cpuUsed: '2' },
        high: { crf: '24', cpuUsed: '0' }
      };
      const q = qualitySettings[quality];

      if (this.isVideo) {
        const videoData = await fetchFile(this.files[0]);
        await this.ffmpeg.writeFile('input.mp4', videoData);
        
        this.setStatus('Converting to WebM...');
        await this.ffmpeg.exec([
          '-i', 'input.mp4',
          '-t', '20',
          '-vf', `scale=${width}:-2`,
          '-c:v', 'libvpx-vp9',
          '-crf', q.crf,
          '-b:v', '0',
          '-cpu-used', q.cpuUsed,
          '-an',
          'output.webm'
        ]);
        
        await this.ffmpeg.deleteFile('input.mp4');
      } else {
        this.setStatus(`Loading ${this.files.length} images...`);
        for (let i = 0; i < this.files.length; i++) {
          const data = await fetchFile(this.files[i]);
          await this.ffmpeg.writeFile(`img${String(i).padStart(4, '0')}.png`, data);
          this.updateProgress((i / this.files.length) * 40);
        }
        
        this.setStatus('Encoding WebM video...');
        await this.ffmpeg.exec([
          '-framerate', String(fps),
          '-i', 'img%04d.png',
          '-t', '20',
          '-vf', `scale=${width}:-2`,
          '-c:v', 'libvpx-vp9',
          '-crf', q.crf,
          '-b:v', '0',
          '-cpu-used', q.cpuUsed,
          'output.webm'
        ]);
        
        for (let i = 0; i < this.files.length; i++) {
          await this.ffmpeg.deleteFile(`img${String(i).padStart(4, '0')}.png`);
        }
      }

      const data = await this.ffmpeg.readFile('output.webm');
      await this.ffmpeg.deleteFile('output.webm');
      
      const blob = new Blob([data.buffer], { type: 'video/webm' });
      this.showResult(blob, 'output.webm', 'video');
    }

    async exportWebP(fps, width, quality) {
      this.setStatus('Preparing files...');
      
      const qualitySettings = {
        low: '60',
        medium: '75',
        high: '90'
      };
      const q = qualitySettings[quality];

      if (this.isVideo) {
        const videoData = await fetchFile(this.files[0]);
        await this.ffmpeg.writeFile('input.mp4', videoData);
        
        this.setStatus('Creating animated WebP...');
        await this.ffmpeg.exec([
          '-i', 'input.mp4',
          '-t', '20',
          '-vf', `scale=${width}:-2,fps=${fps}`,
          '-loop', '0',
          '-quality', q,
          '-preset', 'default',
          'output.webp'
        ]);
        
        await this.ffmpeg.deleteFile('input.mp4');
      } else {
        this.setStatus(`Loading ${this.files.length} images...`);
        for (let i = 0; i < this.files.length; i++) {
          const data = await fetchFile(this.files[i]);
          await this.ffmpeg.writeFile(`img${String(i).padStart(4, '0')}.png`, data);
          this.updateProgress((i / this.files.length) * 40);
        }
        
        this.setStatus('Creating animated WebP...');
        await this.ffmpeg.exec([
          '-framerate', String(fps),
          '-i', 'img%04d.png',
          '-t', '20',
          '-vf', `scale=${width}:-2`,
          '-loop', '0',
          '-quality', q,
          '-preset', 'default',
          'output.webp'
        ]);
        
        for (let i = 0; i < this.files.length; i++) {
          await this.ffmpeg.deleteFile(`img${String(i).padStart(4, '0')}.png`);
        }
      }

      const data = await this.ffmpeg.readFile('output.webp');
      await this.ffmpeg.deleteFile('output.webp');
      
      const blob = new Blob([data.buffer], { type: 'image/webp' });
      this.showResult(blob, 'animation.webp', 'image');
    }

    showResult(blob, filename, type) {
      const url = URL.createObjectURL(blob);
      const sizeMB = (blob.size / 1024 / 1024).toFixed(2);
      
      this.previewContainer.style.display = 'block';
      
      if (type === 'video') {
        this.videoPreview.src = url;
        this.videoPreview.style.display = 'block';
        this.imagePreview.style.display = 'none';
      } else {
        this.imagePreview.src = url;
        this.imagePreview.style.display = 'block';
        this.videoPreview.style.display = 'none';
      }
      
      this.downloadBtn.href = url;
      this.downloadBtn.download = filename;
      this.setStatus(`✅ Ready! File size: ${sizeMB} MB`);
      this.progressBar.style.display = 'none';
    }

    setStatus(text) {
      this.status.textContent = text;
    }

    updateProgress(percent) {
      this.progressFill.style.width = `${percent}%`;
    }
  }

  // Wait for scripts to load
  window.addEventListener('load', () => {
    console.log('Window loaded, initializing MediaConverter'); // Debug
    new MediaConverter();
  });
</script>