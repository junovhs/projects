<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Media Converter - MP4/WebM/WebP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      max-width: 900px;
      width: 100%;
      padding: 40px;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 10px;
      color: #2d3748;
    }

    .subtitle {
      color: #718096;
      margin-bottom: 30px;
    }

    .section {
      margin-bottom: 30px;
    }

    .section-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #4a5568;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
    }

    .btn-secondary {
      background: #f7fafc;
      color: #4a5568;
      border: 2px solid #e2e8f0;
    }

    .btn-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .file-info {
      background: #f7fafc;
      border: 2px dashed #cbd5e0;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: #718096;
      margin-top: 15px;
    }

    .file-info.has-files {
      border-color: #667eea;
      background: #f0f4ff;
      color: #4a5568;
    }

    .input-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .input-field {
      display: flex;
      flex-direction: column;
    }

    label {
      font-size: 0.9rem;
      color: #4a5568;
      margin-bottom: 5px;
      font-weight: 500;
    }

    input[type="number"], select {
      padding: 10px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.2s;
    }

    input[type="number"]:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .format-pills {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
    }

    .format-pill {
      padding: 8px 16px;
      background: white;
      border: 2px solid #e2e8f0;
      border-radius: 20px;
      font-size: 0.9rem;
      color: #4a5568;
      cursor: pointer;
      transition: all 0.2s;
    }

    .format-pill:hover {
      border-color: #cbd5e0;
    }

    .format-pill.selected {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 10px;
      display: none;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
      width: 0%;
    }

    .status {
      font-size: 0.9rem;
      color: #718096;
      margin-bottom: 20px;
      min-height: 20px;
    }

    .preview-container {
      margin-top: 30px;
      display: none;
    }

    video, img {
      width: 100%;
      border-radius: 8px;
      background: #000;
      margin-bottom: 20px;
      max-height: 500px;
      object-fit: contain;
    }

    .hidden {
      display: none;
    }

    .ffmpeg-status {
      background: #fef5e7;
      border: 1px solid #f9e79f;
      color: #7d6608;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 0.9rem;
    }

    .ffmpeg-status.ready {
      background: #e8f8f5;
      border-color: #a9dfbf;
      color: #196f3d;
    }

    .loader {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 8px;
      vertical-align: middle;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .preset-btn {
      padding: 8px 16px;
      background: #f7fafc;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      background: #edf2f7;
    }

    .preset-btn.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }

    .quick-settings {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üé¨ Media Converter</h1>
    <p class="subtitle">Convert image sequences or videos to MP4/WebM/WebP</p>

    <div class="ffmpeg-status" id="ffmpegStatus">
      Loading FFmpeg... <span class="loader"></span>
    </div>

    <!-- Input Section -->
    <div class="section">
      <div class="section-title">üìÅ Step 1: Choose Input</div>
      <div class="btn-group">
        <button class="btn btn-primary" id="btnImageFolder">üìÅ Image Folder</button>
        <button class="btn btn-secondary" id="btnImageFiles">üñºÔ∏è Select Images</button>
        <button class="btn btn-secondary" id="btnVideo">üé• Upload Video</button>
      </div>
      
      <input type="file" id="imageFiles" accept="image/*" multiple class="hidden">
      <input type="file" id="folderInput" webkitdirectory directory multiple class="hidden">
      <input type="file" id="videoFile" accept="video/*" class="hidden">
      
      <div class="file-info" id="fileInfo">No files selected</div>
    </div>

    <!-- Settings Section -->
    <div class="section">
      <div class="section-title">‚öôÔ∏è Step 2: Configure Output</div>
      
      <div class="quick-settings">
        <button class="preset-btn" data-preset="social">Social Media (720p)</button>
        <button class="preset-btn" data-preset="hq">High Quality (1080p)</button>
        <button class="preset-btn" data-preset="small">Small File (480p)</button>
      </div>
      
      <div class="input-group">
        <div class="input-field">
          <label for="fps">Frame Rate (FPS)</label>
          <input type="number" id="fps" min="1" max="60" value="24">
        </div>
        <div class="input-field">
          <label for="width">Width (px)</label>
          <input type="number" id="width" min="100" max="3840" value="1280">
        </div>
        <div class="input-field">
          <label for="quality">Quality</label>
          <select id="quality">
            <option value="low">Low (Fast, Smaller)</option>
            <option value="medium" selected>Medium (Balanced)</option>
            <option value="high">High (Slow, Larger)</option>
          </select>
        </div>
      </div>
    </div>

    <!-- Export Section -->
    <div class="section">
      <div class="section-title">üíæ Step 3: Export Format</div>
      
      <div class="format-pills">
        <div class="format-pill selected" data-format="mp4">MP4 (Universal)</div>
        <div class="format-pill" data-format="webm">WebM (Web)</div>
        <div class="format-pill" data-format="webp">WebP (Animation)</div>
      </div>
      
      <button class="btn btn-primary" id="btnExport" disabled>
        <span id="exportText">Export as MP4</span>
      </button>
      
      <div class="progress-bar" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="status" id="status"></div>
    </div>

    <!-- Preview Section -->
    <div class="preview-container" id="previewContainer">
      <div class="section-title">üëÅÔ∏è Preview</div>
      <video id="videoPreview" controls loop style="display: none;"></video>
      <img id="imagePreview" style="display: none;">
      <a class="btn btn-primary" id="downloadBtn" download>‚¨áÔ∏è Download</a>
    </div>
  </div>

  <script src="./lib/ffmpeg.js"></script>
  <script src="./lib/index.js"></script>
  
  <script>
    const { FFmpeg } = FFmpegWASM;
    const { fetchFile } = FFmpegUtil;

    class MediaConverter {
      constructor() {
        this.ffmpeg = null;
        this.files = [];
        this.isVideo = false;
        this.selectedFormat = 'mp4';
        this.processing = false;
        
        this.init();
      }

      init() {
        // Elements
        this.btnImageFolder = document.getElementById('btnImageFolder');
        this.btnImageFiles = document.getElementById('btnImageFiles');
        this.btnVideo = document.getElementById('btnVideo');
        this.btnExport = document.getElementById('btnExport');
        this.imageFiles = document.getElementById('imageFiles');
        this.folderInput = document.getElementById('folderInput');
        this.videoFile = document.getElementById('videoFile');
        this.fileInfo = document.getElementById('fileInfo');
        this.status = document.getElementById('status');
        this.progressBar = document.getElementById('progressBar');
        this.progressFill = document.getElementById('progressFill');
        this.previewContainer = document.getElementById('previewContainer');
        this.videoPreview = document.getElementById('videoPreview');
        this.imagePreview = document.getElementById('imagePreview');
        this.downloadBtn = document.getElementById('downloadBtn');
        this.ffmpegStatus = document.getElementById('ffmpegStatus');
        this.exportText = document.getElementById('exportText');
        this.fpsInput = document.getElementById('fps');
        this.widthInput = document.getElementById('width');
        this.qualityInput = document.getElementById('quality');

        // Events
        this.btnImageFolder.onclick = () => this.folderInput.click();
        this.btnImageFiles.onclick = () => this.imageFiles.click();
        this.btnVideo.onclick = () => this.videoFile.click();
        this.folderInput.onchange = (e) => this.loadImages(e.target.files);
        this.imageFiles.onchange = (e) => this.loadImages(e.target.files);
        this.videoFile.onchange = (e) => this.loadVideo(e.target.files[0]);
        this.btnExport.onclick = () => this.export();

        // Format selection
        document.querySelectorAll('.format-pill').forEach(pill => {
          pill.onclick = () => {
            document.querySelectorAll('.format-pill').forEach(p => p.classList.remove('selected'));
            pill.classList.add('selected');
            this.selectedFormat = pill.dataset.format;
            this.updateExportButton();
          };
        });

        // Presets
        document.querySelectorAll('.preset-btn').forEach(btn => {
          btn.onclick = (e) => {
            document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            this.applyPreset(btn.dataset.preset);
          };
        });

        this.loadFFmpeg();
      }

      async loadFFmpeg() {
        try {
          this.ffmpeg = new FFmpeg();
          
          this.ffmpeg.on('log', ({ message }) => {
            console.log(message);
          });

          this.ffmpeg.on('progress', ({ progress }) => {
            if (this.processing) {
              const percent = Math.round(progress * 100);
              this.updateProgress(percent);
            }
          });

          await this.ffmpeg.load({
            coreURL: './lib/ffmpeg-core.js',
            wasmURL: './lib/ffmpeg-core.wasm',
          });

          this.ffmpegStatus.innerHTML = '‚úÖ Ready to convert!';
          this.ffmpegStatus.classList.add('ready');
        } catch (err) {
          console.error('FFmpeg load error:', err);
          this.ffmpegStatus.innerHTML = '‚ö†Ô∏è FFmpeg failed to load. Please refresh the page.';
        }
      }

      applyPreset(preset) {
        const presets = {
          social: { fps: 30, width: 1280, quality: 'medium' },
          hq: { fps: 24, width: 1920, quality: 'high' },
          small: { fps: 24, width: 854, quality: 'low' }
        };
        const p = presets[preset];
        this.fpsInput.value = p.fps;
        this.widthInput.value = p.width;
        this.qualityInput.value = p.quality;
      }

      loadImages(fileList) {
        const files = Array.from(fileList).filter(f => 
          /\.(png|jpe?g|webp|gif|bmp)$/i.test(f.name)
        );
        
        if (files.length === 0) {
          this.setStatus('No valid image files found');
          return;
        }

        files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));
        
        this.files = files;
        this.isVideo = false;
        this.fileInfo.textContent = `${files.length} images loaded`;
        this.fileInfo.classList.add('has-files');
        this.btnExport.disabled = false;
        this.setStatus(`Ready to export ${files.length} images`);
      }

      loadVideo(file) {
        if (!file) return;
        
        this.files = [file];
        this.isVideo = true;
        this.fileInfo.textContent = `Video: ${file.name} (${(file.size/1024/1024).toFixed(1)} MB)`;
        this.fileInfo.classList.add('has-files');
        this.btnExport.disabled = false;
        this.setStatus('Ready to convert video');
      }

      updateExportButton() {
        const labels = {
          mp4: 'Export as MP4',
          webm: 'Export as WebM',
          webp: 'Export as WebP Animation'
        };
        this.exportText.textContent = labels[this.selectedFormat];
      }

      async export() {
        if (!this.ffmpeg || this.processing) return;

        this.processing = true;
        this.btnExport.disabled = true;
        this.progressBar.style.display = 'block';

        try {
          const fps = parseInt(this.fpsInput.value) || 24;
          const width = parseInt(this.widthInput.value) || 1280;
          const quality = this.qualityInput.value;

          if (this.selectedFormat === 'mp4') {
            await this.exportMP4(fps, width, quality);
          } else if (this.selectedFormat === 'webm') {
            await this.exportWebM(fps, width, quality);
          } else if (this.selectedFormat === 'webp') {
            await this.exportWebP(fps, width, quality);
          }
        } catch (err) {
          console.error('Export error:', err);
          this.setStatus(`Error: ${err.message}`);
        } finally {
          this.processing = false;
          this.btnExport.disabled = false;
        }
      }

      async exportMP4(fps, width, quality) {
        this.setStatus('Preparing files...');
        
        const qualitySettings = {
          low: { crf: '28', preset: 'veryfast' },
          medium: { crf: '23', preset: 'medium' },
          high: { crf: '18', preset: 'slow' }
        };
        const q = qualitySettings[quality];

        if (this.isVideo) {
          const videoData = await fetchFile(this.files[0]);
          await this.ffmpeg.writeFile('input.mp4', videoData);
          
          this.setStatus('Converting to MP4...');
          await this.ffmpeg.exec([
            '-i', 'input.mp4',
            '-t', '20',
            '-vf', `scale=${width}:-2`,
            '-c:v', 'libx264',
            '-preset', q.preset,
            '-crf', q.crf,
            '-pix_fmt', 'yuv420p',
            '-movflags', '+faststart',
            '-an',
            'output.mp4'
          ]);
          
          await this.ffmpeg.deleteFile('input.mp4');
        } else {
          this.setStatus('Loading images...');
          for (let i = 0; i < this.files.length; i++) {
            const data = await fetchFile(this.files[i]);
            await this.ffmpeg.writeFile(`img${String(i).padStart(4, '0')}.png`, data);
            this.updateProgress((i / this.files.length) * 30);
          }
          
          this.setStatus('Creating MP4...');
          await this.ffmpeg.exec([
            '-framerate', String(fps),
            '-i', 'img%04d.png',
            '-t', '20',
            '-vf', `scale=${width}:-2`,
            '-c:v', 'libx264',
            '-preset', q.preset,
            '-crf', q.crf,
            '-pix_fmt', 'yuv420p',
            '-movflags', '+faststart',
            'output.mp4'
          ]);
          
          for (let i = 0; i < this.files.length; i++) {
            await this.ffmpeg.deleteFile(`img${String(i).padStart(4, '0')}.png`);
          }
        }

        const data = await this.ffmpeg.readFile('output.mp4');
        await this.ffmpeg.deleteFile('output.mp4');
        
        const blob = new Blob([data.buffer], { type: 'video/mp4' });
        this.showResult(blob, 'output.mp4', 'video');
      }

      async exportWebM(fps, width, quality) {
        this.setStatus('Preparing files...');
        
        const qualitySettings = {
          low: { crf: '35', cpuUsed: '5' },
          medium: { crf: '31', cpuUsed: '2' },
          high: { crf: '24', cpuUsed: '0' }
        };
        const q = qualitySettings[quality];

        if (this.isVideo) {
          const videoData = await fetchFile(this.files[0]);
          await this.ffmpeg.writeFile('input.mp4', videoData);
          
          this.setStatus('Converting to WebM...');
          await this.ffmpeg.exec([
            '-i', 'input.mp4',
            '-t', '20',
            '-vf', `scale=${width}:-2`,
            '-c:v', 'libvpx-vp9',
            '-crf', q.crf,
            '-b:v', '0',
            '-cpu-used', q.cpuUsed,
            '-an',
            'output.webm'
          ]);
          
          await this.ffmpeg.deleteFile('input.mp4');
        } else {
          this.setStatus('Loading images...');
          for (let i = 0; i < this.files.length; i++) {
            const data = await fetchFile(this.files[i]);
            await this.ffmpeg.writeFile(`img${String(i).padStart(4, '0')}.png`, data);
            this.updateProgress((i / this.files.length) * 30);
          }
          
          this.setStatus('Creating WebM...');
          await this.ffmpeg.exec([
            '-framerate', String(fps),
            '-i', 'img%04d.png',
            '-t', '20',
            '-vf', `scale=${width}:-2`,
            '-c:v', 'libvpx-vp9',
            '-crf', q.crf,
            '-b:v', '0',
            '-cpu-used', q.cpuUsed,
            'output.webm'
          ]);
          
          for (let i = 0; i < this.files.length; i++) {
            await this.ffmpeg.deleteFile(`img${String(i).padStart(4, '0')}.png`);
          }
        }

        const data = await this.ffmpeg.readFile('output.webm');
        await this.ffmpeg.deleteFile('output.webm');
        
        const blob = new Blob([data.buffer], { type: 'video/webm' });
        this.showResult(blob, 'output.webm', 'video');
      }

      async exportWebP(fps, width, quality) {
        this.setStatus('Preparing files...');
        
        const qualitySettings = {
          low: '60',
          medium: '75',
          high: '90'
        };
        const q = qualitySettings[quality];

        if (this.isVideo) {
          const videoData = await fetchFile(this.files[0]);
          await this.ffmpeg.writeFile('input.mp4', videoData);
          
          this.setStatus('Creating animated WebP...');
          await this.ffmpeg.exec([
            '-i', 'input.mp4',
            '-t', '20',
            '-vf', `scale=${width}:-2,fps=${fps}`,
            '-loop', '0',
            '-quality', q,
            'output.webp'
          ]);
          
          await this.ffmpeg.deleteFile('input.mp4');
        } else {
          this.setStatus('Loading images...');
          for (let i = 0; i < this.files.length; i++) {
            const data = await fetchFile(this.files[i]);
            await this.ffmpeg.writeFile(`img${String(i).padStart(4, '0')}.png`, data);
            this.updateProgress((i / this.files.length) * 30);
          }
          
          this.setStatus('Creating animated WebP...');
          await this.ffmpeg.exec([
            '-framerate', String(fps),
            '-i', 'img%04d.png',
            '-t', '20',
            '-vf', `scale=${width}:-2`,
            '-loop', '0',
            '-quality', q,
            'output.webp'
          ]);
          
          for (let i = 0; i < this.files.length; i++) {
            await this.ffmpeg.deleteFile(`img${String(i).padStart(4, '0')}.png`);
          }
        }

        const data = await this.ffmpeg.readFile('output.webp');
        await this.ffmpeg.deleteFile('output.webp');
        
        const blob = new Blob([data.buffer], { type: 'image/webp' });
        this.showResult(blob, 'animation.webp', 'image');
      }

      showResult(blob, filename, type) {
        const url = URL.createObjectURL(blob);
        const sizeMB = (blob.size / 1024 / 1024).toFixed(2);
        
        this.previewContainer.style.display = 'block';
        
        if (type === 'video') {
          this.videoPreview.src = url;
          this.videoPreview.style.display = 'block';
          this.imagePreview.style.display = 'none';
        } else {
          this.imagePreview.src = url;
          this.imagePreview.style.display = 'block';
          this.videoPreview.style.display = 'none';
        }
        
        this.downloadBtn.href = url;
        this.downloadBtn.download = filename;
        this.setStatus(`‚úÖ Ready! File size: ${sizeMB} MB`);
        this.progressBar.style.display = 'none';
      }

      setStatus(text) {
        this.status.textContent = text;
      }

      updateProgress(percent) {
        this.progressFill.style.width = `${percent}%`;
      }
    }

    new MediaConverter();
  </script>
</body>
</html>