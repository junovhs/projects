<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ffmpeg.wasm CDN MVP</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root { color-scheme: light dark; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; padding: 24px; max-width: 720px; margin: 0 auto; }
      h1 { margin: 0 0 12px; font-size: 1.4rem; }
      p.small { opacity: .75; margin-top: 0; }
      button { padding: 10px 14px; margin-right: 8px; border-radius: 10px; border: 1px solid rgba(127,127,127,.4); background: transparent; cursor: pointer; }
      button[disabled] { opacity: .5; cursor: not-allowed; }
      progress { width: 240px; vertical-align: middle; }
      video { width: 100%; margin-top: 16px; border-radius: 12px; }
      pre { background:#111; color:#0f0; padding:12px; overflow:auto; max-height: 240px; border-radius: 10px; }
      footer { margin-top: 16px; opacity: .65; font-size: 0.9rem; }
      .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
      .badge { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background: rgba(127,127,127,.2); padding: 4px 8px; border-radius: 999px; }
    </style>
  </head>
  <body>
    <h1>ffmpeg.wasm CDN MVP</h1>
    <p class="small">Goal: prove we can load <code>ffmpeg.wasm</code> over CDN and run a tiny transcode in-browser.</p>

    <div class="row">
      <button id="load">1) Load core</button>
      <progress id="p" max="1" value="0" style="display:none"></progress>
      <span class="badge" id="v"></span>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="run" disabled>2) Convert sample (webm → mp4)</button>
      <button id="pick" disabled>…or choose a file</button>
      <input id="file" type="file" accept="video/*,image/*,audio/*" style="display:none" />
    </div>

    <video id="out" controls></video>
    <pre id="log"></pre>

    <!-- UMD builds (small). Heavy core is fetched from CDN in load() -->
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.2/dist/umd/index.js"></script>
    <script>
      const { FFmpeg } = window.FFmpegWASM;
      const { fetchFile, toBlobURL } = window.FFmpegUtil;

      const ffmpeg = new FFmpeg();
      const logEl = document.getElementById('log');
      const btnLoad = document.getElementById('load');
      const btnRun  = document.getElementById('run');
      const btnPick = document.getElementById('pick');
      const fileIn  = document.getElementById('file');
      const videoEl = document.getElementById('out');
      const prog    = document.getElementById('p');
      const ver     = document.getElementById('v');

      // Wire basic logs + progress
      ffmpeg.on('log', ({ message }) => { logEl.textContent += message + '\n'; });
      ffmpeg.on('progress', ({ progress, time }) => {
        prog.style.display = 'inline-block';
        prog.value = progress;
      });

      // Keep versions in one place
      const CORE_VER = '0.12.10'; // single-thread core
      const baseURL = `https://cdn.jsdelivr.net/npm/@ffmpeg/core@${CORE_VER}/dist/umd`;

      // -- 1) Load the core from CDN (single-thread; no special headers needed)
      btnLoad.onclick = async () => {
        btnLoad.disabled = true;
        logEl.textContent = 'Loading core (first time ~31 MB)…\n';
        try {
          await ffmpeg.load({
            coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript', true, (r)=>{}),
            wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm', true, (r)=>{}),
          });
          ver.textContent = 'core ' + CORE_VER;
          logEl.textContent += 'Core loaded.\n';
          btnRun.disabled = false;
          btnPick.disabled = false;
        } catch (e) {
          console.error(e);
          logEl.textContent += '\nERROR loading core: ' + e.message + '\n';
          btnLoad.disabled = false;
        } finally {
          prog.style.display = 'none';
        }
      };

      // Helper: run a simple conversion on either a built-in webm or picked file
      async function transcode(inputBytes, inputName='input.webm') {
        logEl.textContent += `\nWriting ${inputName}…\n`;
        await ffmpeg.writeFile(inputName, inputBytes);
        logEl.textContent += 'Converting (keep defaults)…\n';
        await ffmpeg.exec(['-i', inputName, '-t', '2', 'output.mp4']);
        const data = await ffmpeg.readFile('output.mp4');
        const url = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));
        videoEl.src = url;
        logEl.textContent += 'Done.\n';
        videoEl.scrollIntoView({ behavior: 'smooth' });
      }

      // -- 2a) Convert a tiny sample from GitHub (no file picker needed)
      btnRun.onclick = async () => {
        try {
          const sample = 'https://raw.githubusercontent.com/ffmpegwasm/testdata/master/Big_Buck_Bunny_180_10s.webm';
          await transcode(await fetchFile(sample), 'input.webm');
        } catch (e) {
          logEl.textContent += '\nERROR during transcode: ' + e.message + '\n';
          console.error(e);
        }
      };

      // -- 2b) Let the user pick a file instead
      btnPick.onclick = () => fileIn.click();
      fileIn.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          await transcode(await fetchFile(file), file.name);
        } catch (e) {
          logEl.textContent += '\nERROR during transcode: ' + e.message + '\n';
          console.error(e);
        }
      };
    </script>
    <footer>
      Single‑thread core via CDN. For multithread speedups, add COOP/COEP headers and switch to <code>@ffmpeg/core-mt</code>.
    </footer>
  </body>
</html>
