<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Media Converter - Images/Video to WebM/GIF</title>
  <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.min.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    
    .container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      max-width: 800px;
      width: 100%;
      padding: 40px;
    }
    
    h1 {
      font-size: 2rem;
      margin-bottom: 10px;
      color: #2d3748;
    }
    
    .subtitle {
      color: #718096;
      margin-bottom: 30px;
    }
    
    .section {
      margin-bottom: 30px;
    }
    
    .section-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #4a5568;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .input-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .input-field {
      display: flex;
      flex-direction: column;
    }
    
    label {
      font-size: 0.9rem;
      color: #4a5568;
      margin-bottom: 5px;
      font-weight: 500;
    }
    
    input[type="number"], select {
      padding: 10px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.2s;
    }
    
    input[type="number"]:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
    }
    
    .btn-secondary {
      background: #f7fafc;
      color: #4a5568;
      border: 2px solid #e2e8f0;
    }
    
    .btn-secondary:hover {
      background: #edf2f7;
    }
    
    .btn-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .file-info {
      background: #f7fafc;
      border: 2px dashed #cbd5e0;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: #718096;
      margin-bottom: 20px;
    }
    
    .file-info.has-files {
      border-color: #667eea;
      background: #f0f4ff;
      color: #4a5568;
    }
    
    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
      width: 0%;
    }
    
    .status {
      font-size: 0.9rem;
      color: #718096;
      margin-bottom: 20px;
    }
    
    .preview-container {
      margin-top: 30px;
      display: none;
    }
    
    video, img {
      width: 100%;
      border-radius: 8px;
      background: #000;
      margin-bottom: 20px;
    }
    
    .export-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    .hidden {
      display: none;
    }
    
    .quick-settings {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .preset-btn {
      padding: 8px 16px;
      background: #f7fafc;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    
    .preset-btn:hover {
      background: #edf2f7;
      border-color: #cbd5e0;
    }
    
    .preset-btn.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üé¨ Media Converter</h1>
    <p class="subtitle">Convert image sequences or videos to WebM/GIF</p>
    
    <!-- Input Section -->
    <div class="section">
      <div class="section-title">
        <span>üìÅ</span> Step 1: Choose Input
      </div>
      <div class="btn-group">
        <button class="btn btn-primary" id="btnImageFolder">üìÅ Image Folder</button>
        <button class="btn btn-secondary" id="btnImageFiles">üñºÔ∏è Select Images</button>
        <button class="btn btn-secondary" id="btnVideo">üé• Upload Video</button>
      </div>
      
      <input type="file" id="imageFiles" accept="image/*" multiple class="hidden">
      <input type="file" id="folderInput" webkitdirectory directory multiple class="hidden">
      <input type="file" id="videoFile" accept="video/*" class="hidden">
      
      <div class="file-info" id="fileInfo">
        No files selected
      </div>
    </div>
    
    <!-- Settings Section -->
    <div class="section">
      <div class="section-title">
        <span>‚öôÔ∏è</span> Step 2: Configure Output
      </div>
      
      <div class="quick-settings">
        <button class="preset-btn" data-preset="low">Low Quality (Fast)</button>
        <button class="preset-btn" data-preset="medium">Medium Quality</button>
        <button class="preset-btn" data-preset="high">High Quality</button>
      </div>
      
      <div class="input-group">
        <div class="input-field">
          <label for="fps">Frame Rate (FPS)</label>
          <input type="number" id="fps" min="1" max="60" value="10">
        </div>
        <div class="input-field">
          <label for="width">Width (px)</label>
          <input type="number" id="width" min="100" max="1920" placeholder="Auto">
        </div>
        <div class="input-field">
          <label for="height">Height (px)</label>
          <input type="number" id="height" min="100" max="1080" placeholder="Auto">
        </div>
        <div class="input-field">
          <label for="quality">Quality</label>
          <select id="quality">
            <option value="low">Low (Smaller file)</option>
            <option value="medium" selected>Medium</option>
            <option value="high">High (Larger file)</option>
          </select>
        </div>
      </div>
    </div>
    
    <!-- Export Section -->
    <div class="section">
      <div class="section-title">
        <span>üíæ</span> Step 3: Export
      </div>
      <div class="btn-group">
        <button class="btn btn-primary" id="btnExportWebM" disabled>Export as WebM</button>
        <button class="btn btn-secondary" id="btnExportGIF" disabled>Export as GIF</button>
      </div>
      
      <div class="progress-bar" id="progressBar" style="display: none; margin-top: 20px;">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="status" id="status"></div>
    </div>
    
    <!-- Preview Section -->
    <div class="preview-container" id="previewContainer">
      <div class="section-title">
        <span>üëÅÔ∏è</span> Preview
      </div>
      <video id="videoPreview" controls loop muted style="display: none;"></video>
      <img id="gifPreview" style="display: none;">
      <div class="export-buttons">
        <a class="btn btn-primary" id="downloadBtn" download>‚¨áÔ∏è Download</a>
      </div>
    </div>
  </div>
  
  <script>
    class MediaConverter {
      constructor() {
        this.frames = [];
        this.videoSrc = null;
        this.isVideo = false;
        this.initElements();
        this.initEvents();
        this.preloadGifWorker();
      }
      
      initElements() {
        // Buttons
        this.btnImageFolder = document.getElementById('btnImageFolder');
        this.btnImageFiles = document.getElementById('btnImageFiles');
        this.btnVideo = document.getElementById('btnVideo');
        this.btnExportWebM = document.getElementById('btnExportWebM');
        this.btnExportGIF = document.getElementById('btnExportGIF');
        
        // Inputs
        this.imageFiles = document.getElementById('imageFiles');
        this.folderInput = document.getElementById('folderInput');
        this.videoFile = document.getElementById('videoFile');
        this.fpsInput = document.getElementById('fps');
        this.widthInput = document.getElementById('width');
        this.heightInput = document.getElementById('height');
        this.qualityInput = document.getElementById('quality');
        
        // Display
        this.fileInfo = document.getElementById('fileInfo');
        this.progressBar = document.getElementById('progressBar');
        this.progressFill = document.getElementById('progressFill');
        this.status = document.getElementById('status');
        this.previewContainer = document.getElementById('previewContainer');
        this.videoPreview = document.getElementById('videoPreview');
        this.gifPreview = document.getElementById('gifPreview');
        this.downloadBtn = document.getElementById('downloadBtn');
      }
      
      initEvents() {
        this.btnImageFolder.onclick = () => this.folderInput.click();
        this.btnImageFiles.onclick = () => this.imageFiles.click();
        this.btnVideo.onclick = () => this.videoFile.click();
        
        this.folderInput.onchange = (e) => this.loadImageFiles(Array.from(e.target.files));
        this.imageFiles.onchange = (e) => this.loadImageFiles(Array.from(e.target.files));
        this.videoFile.onchange = (e) => this.loadVideo(e.target.files[0]);
        
        this.btnExportWebM.onclick = () => this.exportWebM();
        this.btnExportGIF.onclick = () => this.exportGIF();
        
        // Presets
        document.querySelectorAll('.preset-btn').forEach(btn => {
          btn.onclick = () => this.applyPreset(btn.dataset.preset);
        });
      }
      
      async preloadGifWorker() {
        try {
          const response = await fetch('https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js');
          const blob = await response.blob();
          this.gifWorkerUrl = URL.createObjectURL(blob);
        } catch (err) {
          console.warn('GIF worker preload failed:', err);
        }
      }
      
      applyPreset(preset) {
        document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
        
        const settings = {
          low: { fps: 5, width: 480, quality: 'low' },
          medium: { fps: 10, width: 720, quality: 'medium' },
          high: { fps: 15, width: 1080, quality: 'high' }
        };
        
        const s = settings[preset];
        this.fpsInput.value = s.fps;
        this.widthInput.value = s.width;
        this.heightInput.value = '';
        this.qualityInput.value = s.quality;
      }
      
      naturalSort(a, b) {
        return a.name.localeCompare(b.name, undefined, { numeric: true });
      }
      
      async loadImageFiles(files) {
        const imageFiles = files.filter(f => /\.(png|jpe?g|webp|gif)$/i.test(f.name));
        imageFiles.sort(this.naturalSort);
        
        if (imageFiles.length === 0) {
          this.setStatus('No valid image files found');
          return;
        }
        
        this.frames = [];
        this.isVideo = false;
        this.setStatus('Loading images...');
        this.showProgress(0);
        
        for (let i = 0; i < imageFiles.length; i++) {
          const bitmap = await createImageBitmap(imageFiles[i]);
          this.frames.push(bitmap);
          this.showProgress((i + 1) / imageFiles.length * 100);
        }
        
        this.fileInfo.textContent = `${this.frames.length} images loaded`;
        this.fileInfo.classList.add('has-files');
        this.btnExportWebM.disabled = false;
        this.btnExportGIF.disabled = false;
        this.setStatus(`Loaded ${this.frames.length} images`);
        this.hideProgress();
      }
      
      async loadVideo(file) {
        if (!file) return;
        
        this.isVideo = true;
        this.videoSrc = URL.createObjectURL(file);
        
        this.fileInfo.textContent = `Video: ${file.name} (${(file.size/1024/1024).toFixed(1)} MB)`;
        this.fileInfo.classList.add('has-files');
        this.btnExportWebM.disabled = false;
        this.btnExportGIF.disabled = false;
        this.setStatus('Video loaded');
      }
      
      async extractVideoFrames(video, fps) {
        const frames = [];
        const duration = video.duration;
        const frameCount = Math.ceil(duration * fps);
        
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        
        for (let i = 0; i < frameCount; i++) {
          const time = i / fps;
          video.currentTime = time;
          await new Promise(resolve => {
            video.onseeked = resolve;
          });
          
          ctx.drawImage(video, 0, 0);
          const bitmap = await createImageBitmap(canvas);
          frames.push(bitmap);
          this.showProgress((i + 1) / frameCount * 100);
        }
        
        return frames;
      }
      
      async exportWebM() {
        try {
          this.setStatus('Preparing WebM export...');
          this.showProgress(0);
          
          const fps = parseInt(this.fpsInput.value) || 10;
          let width = parseInt(this.widthInput.value);
          let height = parseInt(this.heightInput.value);
          
          if (this.isVideo) {
            const video = document.createElement('video');
            video.src = this.videoSrc;
            await new Promise(resolve => video.onloadedmetadata = resolve);
            
            if (!width && !height) {
              width = video.videoWidth;
              height = video.videoHeight;
            } else if (width && !height) {
              height = Math.round(video.videoHeight * (width / video.videoWidth));
            } else if (!width && height) {
              width = Math.round(video.videoWidth * (height / video.videoHeight));
            }
            
            this.frames = await this.extractVideoFrames(video, fps);
          } else {
            if (!width && !height) {
              width = this.frames[0].width;
              height = this.frames[0].height;
            } else if (width && !height) {
              height = Math.round(this.frames[0].height * (width / this.frames[0].width));
            } else if (!width && height) {
              width = Math.round(this.frames[0].width * (height / this.frames[0].height));
            }
          }
          
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          
          const stream = canvas.captureStream(fps);
          const qualityMap = { low: 500000, medium: 2000000, high: 5000000 };
          const bitrate = qualityMap[this.qualityInput.value];
          
          const recorder = new MediaRecorder(stream, {
            mimeType: 'video/webm',
            videoBitsPerSecond: bitrate
          });
          
          const chunks = [];
          recorder.ondataavailable = e => chunks.push(e.data);
          
          recorder.start();
          this.setStatus(`Rendering ${this.frames.length} frames...`);
          
          for (let i = 0; i < this.frames.length; i++) {
            ctx.clearRect(0, 0, width, height);
            ctx.drawImage(this.frames[i], 0, 0, width, height);
            await new Promise(resolve => setTimeout(resolve, 1000 / fps));
            this.showProgress((i + 1) / this.frames.length * 100);
          }
          
          recorder.stop();
          
          await new Promise(resolve => recorder.onstop = resolve);
          
          const blob = new Blob(chunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          
          this.showPreview('webm', url, blob);
          this.setStatus(`WebM ready (${(blob.size/1024/1024).toFixed(2)} MB)`);
          this.hideProgress();
          
        } catch (err) {
          this.setStatus(`Error: ${err.message}`);
          this.hideProgress();
        }
      }
      
      async exportGIF() {
        try {
          if (!this.gifWorkerUrl) {
            this.setStatus('GIF worker not loaded, please try again');
            return;
          }
          
          this.setStatus('Preparing GIF export...');
          this.showProgress(0);
          
          const fps = parseInt(this.fpsInput.value) || 10;
          let width = parseInt(this.widthInput.value) || 640;
          let height = parseInt(this.heightInput.value);
          
          if (this.isVideo) {
            const video = document.createElement('video');
            video.src = this.videoSrc;
            await new Promise(resolve => video.onloadedmetadata = resolve);
            
            if (!height) {
              height = Math.round(video.videoHeight * (width / video.videoWidth));
            }
            
            this.frames = await this.extractVideoFrames(video, fps);
          } else {
            if (!height) {
              height = Math.round(this.frames[0].height * (width / this.frames[0].width));
            }
          }
          
          const qualityMap = { low: 20, medium: 10, high: 5 };
          const quality = qualityMap[this.qualityInput.value];
          
          const gif = new GIF({
            workers: 2,
            quality: quality,
            width: width,
            height: height,
            workerScript: this.gifWorkerUrl
          });
          
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          
          this.setStatus(`Adding ${this.frames.length} frames to GIF...`);
          
          for (let i = 0; i < this.frames.length; i++) {
            ctx.clearRect(0, 0, width, height);
            ctx.drawImage(this.frames[i], 0, 0, width, height);
            gif.addFrame(canvas, { delay: 1000 / fps, copy: true });
            this.showProgress((i + 1) / this.frames.length * 50);
          }
          
          gif.on('progress', p => {
            this.showProgress(50 + p * 50);
          });
          
          gif.on('finished', blob => {
            const url = URL.createObjectURL(blob);
            this.showPreview('gif', url, blob);
            this.setStatus(`GIF ready (${(blob.size/1024/1024).toFixed(2)} MB)`);
            this.hideProgress();
          });
          
          gif.render();
          
        } catch (err) {
          this.setStatus(`Error: ${err.message}`);
          this.hideProgress();
        }
      }
      
      showPreview(type, url, blob) {
        this.previewContainer.style.display = 'block';
        
        if (type === 'webm') {
          this.videoPreview.src = url;
          this.videoPreview.style.display = 'block';
          this.gifPreview.style.display = 'none';
          this.downloadBtn.download = 'output.webm';
        } else {
          this.gifPreview.src = url;
          this.gifPreview.style.display = 'block';
          this.videoPreview.style.display = 'none';
          this.downloadBtn.download = 'output.gif';
        }
        
        this.downloadBtn.href = url;
      }
      
      setStatus(text) {
        this.status.textContent = text;
      }
      
      showProgress(percent) {
        this.progressBar.style.display = 'block';
        this.progressFill.style.width = `${percent}%`;
      }
      
      hideProgress() {
        setTimeout(() => {
          this.progressBar.style.display = 'none';
        }, 500);
      }
    }
    
    // Initialize the app
    const converter = new MediaConverter();
  </script>
</body>
</html>