<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Media Converter - Images/Video to MP4/WebM/WebP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    
    .container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      max-width: 900px;
      width: 100%;
      padding: 40px;
    }
    
    h1 {
      font-size: 2rem;
      margin-bottom: 10px;
      color: #2d3748;
    }
    
    .subtitle {
      color: #718096;
      margin-bottom: 30px;
    }
    
    .section {
      margin-bottom: 30px;
    }
    
    .section-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #4a5568;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .input-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .input-field {
      display: flex;
      flex-direction: column;
    }
    
    label {
      font-size: 0.9rem;
      color: #4a5568;
      margin-bottom: 5px;
      font-weight: 500;
    }
    
    input[type="number"], select {
      padding: 10px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.2s;
    }
    
    input[type="number"]:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
    }
    
    .btn-secondary {
      background: #f7fafc;
      color: #4a5568;
      border: 2px solid #e2e8f0;
    }
    
    .btn-secondary:hover:not(:disabled) {
      background: #edf2f7;
    }
    
    .btn-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .file-info {
      background: #f7fafc;
      border: 2px dashed #cbd5e0;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: #718096;
      margin-bottom: 20px;
    }
    
    .file-info.has-files {
      border-color: #667eea;
      background: #f0f4ff;
      color: #4a5568;
    }
    
    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
      width: 0%;
    }
    
    .status {
      font-size: 0.9rem;
      color: #718096;
      margin-bottom: 20px;
      min-height: 20px;
    }
    
    .preview-container {
      margin-top: 30px;
      display: none;
    }
    
    video, img {
      width: 100%;
      border-radius: 8px;
      background: #000;
      margin-bottom: 20px;
      max-height: 500px;
      object-fit: contain;
    }
    
    .export-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    .hidden {
      display: none;
    }
    
    .quick-settings {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .preset-btn {
      padding: 8px 16px;
      background: #f7fafc;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    
    .preset-btn:hover {
      background: #edf2f7;
      border-color: #cbd5e0;
    }
    
    .preset-btn.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }
    
    .ffmpeg-status {
      background: #fef5e7;
      border: 1px solid #f9e79f;
      color: #7d6608;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 0.9rem;
      display: none;
    }
    
    .ffmpeg-status.ready {
      background: #e8f8f5;
      border-color: #a9dfbf;
      color: #196f3d;
    }
    
    .format-pills {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
    }
    
    .format-pill {
      padding: 6px 12px;
      background: white;
      border: 2px solid #e2e8f0;
      border-radius: 20px;
      font-size: 0.85rem;
      color: #4a5568;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .format-pill:hover {
      border-color: #cbd5e0;
    }
    
    .format-pill.selected {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }
    
    .loader {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 8px;
      vertical-align: middle;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üé¨ Media Converter</h1>
    <p class="subtitle">Convert image sequences or videos to MP4/WebM/WebP - all in your browser!</p>
    
    <div class="ffmpeg-status" id="ffmpegStatus">
      Initializing FFmpeg... <span class="loader"></span>
    </div>
    
    <!-- Input Section -->
    <div class="section">
      <div class="section-title">
        <span>üìÅ</span> Step 1: Choose Input
      </div>
      <div class="btn-group">
        <button class="btn btn-primary" id="btnImageFolder">üìÅ Image Folder</button>
        <button class="btn btn-secondary" id="btnImageFiles">üñºÔ∏è Select Images</button>
        <button class="btn btn-secondary" id="btnVideo">üé• Upload Video</button>
      </div>
      
      <input type="file" id="imageFiles" accept="image/*" multiple class="hidden">
      <input type="file" id="folderInput" webkitdirectory directory multiple class="hidden">
      <input type="file" id="videoFile" accept="video/*" class="hidden">
      
      <div class="file-info" id="fileInfo">
        No files selected
      </div>
    </div>
    
    <!-- Settings Section -->
    <div class="section">
      <div class="section-title">
        <span>‚öôÔ∏è</span> Step 2: Configure Output
      </div>
      
      <div class="quick-settings">
        <button class="preset-btn" data-preset="low">Low Quality (Fast)</button>
        <button class="preset-btn" data-preset="medium">Medium Quality</button>
        <button class="preset-btn" data-preset="high">High Quality</button>
        <button class="preset-btn" data-preset="ultra">Ultra (4K)</button>
      </div>
      
      <div class="input-group">
        <div class="input-field">
          <label for="fps">Frame Rate (FPS)</label>
          <input type="number" id="fps" min="1" max="60" value="10">
        </div>
        <div class="input-field">
          <label for="width">Width (px)</label>
          <input type="number" id="width" min="100" max="3840" placeholder="Auto">
        </div>
        <div class="input-field">
          <label for="height">Height (px)</label>
          <input type="number" id="height" min="100" max="2160" placeholder="Auto">
        </div>
        <div class="input-field">
          <label for="quality">Quality/Bitrate</label>
          <select id="quality">
            <option value="low">Low (1 Mbps)</option>
            <option value="medium" selected>Medium (2.5 Mbps)</option>
            <option value="high">High (5 Mbps)</option>
            <option value="ultra">Ultra (10 Mbps)</option>
          </select>
        </div>
      </div>
    </div>
    
    <!-- Export Section -->
    <div class="section">
      <div class="section-title">
        <span>üíæ</span> Step 3: Export Format
      </div>
      
      <div class="format-pills">
        <div class="format-pill selected" data-format="mp4">MP4 (H.264)</div>
        <div class="format-pill" data-format="webm">WebM (VP9)</div>
        <div class="format-pill" data-format="webp">WebP Animation</div>
      </div>
      
      <div class="btn-group">
        <button class="btn btn-primary" id="btnExport" disabled>
          <span id="exportBtnText">Export as MP4</span>
        </button>
        <button class="btn btn-secondary" id="btnCancel" style="display: none;">Cancel</button>
      </div>
      
      <div class="progress-bar" id="progressBar" style="display: none; margin-top: 20px;">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="status" id="status"></div>
    </div>
    
    <!-- Preview Section -->
    <div class="preview-container" id="previewContainer">
      <div class="section-title">
        <span>üëÅÔ∏è</span> Preview
      </div>
      <video id="videoPreview" controls loop muted style="display: none;"></video>
      <img id="imagePreview" style="display: none;">
      <div class="export-buttons">
        <a class="btn btn-primary" id="downloadBtn" download>‚¨áÔ∏è Download</a>
      </div>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/umd/index.js"></script>
  <script>
    const { FFmpeg } = FFmpegWASM;
    const { fetchFile } = FFmpegUtil;
    
    class MediaConverter {
      constructor() {
        this.frames = [];
        this.videoSrc = null;
        this.isVideo = false;
        this.ffmpeg = null;
        this.selectedFormat = 'mp4';
        this.isProcessing = false;
        this.initElements();
        this.initEvents();
        this.initFFmpeg();
      }
      
      initElements() {
        // Buttons
        this.btnImageFolder = document.getElementById('btnImageFolder');
        this.btnImageFiles = document.getElementById('btnImageFiles');
        this.btnVideo = document.getElementById('btnVideo');
        this.btnExport = document.getElementById('btnExport');
        this.btnCancel = document.getElementById('btnCancel');
        this.exportBtnText = document.getElementById('exportBtnText');
        
        // Inputs
        this.imageFiles = document.getElementById('imageFiles');
        this.folderInput = document.getElementById('folderInput');
        this.videoFile = document.getElementById('videoFile');
        this.fpsInput = document.getElementById('fps');
        this.widthInput = document.getElementById('width');
        this.heightInput = document.getElementById('height');
        this.qualityInput = document.getElementById('quality');
        
        // Display
        this.fileInfo = document.getElementById('fileInfo');
        this.progressBar = document.getElementById('progressBar');
        this.progressFill = document.getElementById('progressFill');
        this.status = document.getElementById('status');
        this.previewContainer = document.getElementById('previewContainer');
        this.videoPreview = document.getElementById('videoPreview');
        this.imagePreview = document.getElementById('imagePreview');
        this.downloadBtn = document.getElementById('downloadBtn');
        this.ffmpegStatus = document.getElementById('ffmpegStatus');
      }
      
      initEvents() {
        this.btnImageFolder.onclick = () => this.folderInput.click();
        this.btnImageFiles.onclick = () => this.imageFiles.click();
        this.btnVideo.onclick = () => this.videoFile.click();
        
        this.folderInput.onchange = (e) => this.loadImageFiles(Array.from(e.target.files));
        this.imageFiles.onchange = (e) => this.loadImageFiles(Array.from(e.target.files));
        this.videoFile.onchange = (e) => this.loadVideo(e.target.files[0]);
        
        this.btnExport.onclick = () => this.export();
        this.btnCancel.onclick = () => this.cancelExport();
        
        // Format selection
        document.querySelectorAll('.format-pill').forEach(pill => {
          pill.onclick = () => {
            document.querySelectorAll('.format-pill').forEach(p => p.classList.remove('selected'));
            pill.classList.add('selected');
            this.selectedFormat = pill.dataset.format;
            this.updateExportButton();
          };
        });
        
        // Presets
        document.querySelectorAll('.preset-btn').forEach(btn => {
          btn.onclick = () => this.applyPreset(btn.dataset.preset);
        });
      }
      
      async initFFmpeg() {
        try {
          this.ffmpegStatus.style.display = 'block';
          this.ffmpeg = new FFmpeg();
          
          this.ffmpeg.on('log', ({ message }) => {
            console.log(message);
          });
          
          this.ffmpeg.on('progress', ({ progress }) => {
            if (this.isProcessing) {
              this.showProgress(Math.round(progress * 100));
            }
          });
          
          await this.ffmpeg.load({
            coreURL: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.4/dist/umd/ffmpeg-core.js',
            wasmURL: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.4/dist/umd/ffmpeg-core.wasm',
          });
          
          this.ffmpegStatus.innerHTML = '‚úÖ FFmpeg ready! Full MP4/WebM/WebP support loaded.';
          this.ffmpegStatus.classList.add('ready');
          
        } catch (err) {
          console.error('FFmpeg init error:', err);
          this.ffmpegStatus.innerHTML = '‚ö†Ô∏è FFmpeg failed to load. WebM export still available.';
        }
      }
      
      updateExportButton() {
        const formats = {
          'mp4': 'Export as MP4',
          'webm': 'Export as WebM',
          'webp': 'Export as WebP Animation'
        };
        this.exportBtnText.textContent = formats[this.selectedFormat];
      }
      
      applyPreset(preset) {
        document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
        
        const settings = {
          low: { fps: 10, width: 480, quality: 'low' },
          medium: { fps: 15, width: 720, quality: 'medium' },
          high: { fps: 24, width: 1080, quality: 'high' },
          ultra: { fps: 30, width: 1920, quality: 'ultra' }
        };
        
        const s = settings[preset];
        this.fpsInput.value = s.fps;
        this.widthInput.value = s.width;
        this.heightInput.value = '';
        this.qualityInput.value = s.quality;
      }
      
      naturalSort(a, b) {
        return a.name.localeCompare(b.name, undefined, { numeric: true });
      }
      
      async loadImageFiles(files) {
        const imageFiles = files.filter(f => /\.(png|jpe?g|webp|gif)$/i.test(f.name));
        imageFiles.sort(this.naturalSort);
        
        if (imageFiles.length === 0) {
          this.setStatus('No valid image files found');
          return;
        }
        
        this.frames = imageFiles; // Store files, not bitmaps for FFmpeg
        this.isVideo = false;
        
        this.fileInfo.textContent = `${this.frames.length} images loaded`;
        this.fileInfo.classList.add('has-files');
        this.btnExport.disabled = false;
        this.setStatus(`Loaded ${this.frames.length} images`);
      }
      
      async loadVideo(file) {
        if (!file) return;
        
        this.isVideo = true;
        this.videoFile = file;
        this.videoSrc = URL.createObjectURL(file);
        
        this.fileInfo.textContent = `Video: ${file.name} (${(file.size/1024/1024).toFixed(1)} MB)`;
        this.fileInfo.classList.add('has-files');
        this.btnExport.disabled = false;
        this.setStatus('Video loaded');
      }
      
      async export() {
        if (this.selectedFormat === 'webm' && !this.ffmpeg) {
          // Fallback to native WebM export
          return this.exportWebMNative();
        }
        
        if (!this.ffmpeg) {
          this.setStatus('FFmpeg not loaded yet, please wait...');
          return;
        }
        
        this.isProcessing = true;
        this.btnExport.disabled = true;
        this.btnCancel.style.display = 'inline-block';
        
        try {
          if (this.selectedFormat === 'mp4') {
            await this.exportMP4();
          } else if (this.selectedFormat === 'webm') {
            await this.exportWebMFFmpeg();
          } else if (this.selectedFormat === 'webp') {
            await this.exportWebP();
          }
        } catch (err) {
          console.error('Export error:', err);
          this.setStatus(`Error: ${err.message}`);
        } finally {
          this.isProcessing = false;
          this.btnExport.disabled = false;
          this.btnCancel.style.display = 'none';
          this.hideProgress();
        }
      }
      
      async exportMP4() {
        this.setStatus('Preparing MP4 export...');
        this.showProgress(0);
        
        const fps = parseInt(this.fpsInput.value) || 10;
        const width = parseInt(this.widthInput.value) || 720;
        const height = parseInt(this.heightInput.value) || '';
        
        const qualityMap = {
          'low': '1000k',
          'medium': '2500k',
          'high': '5000k',
          'ultra': '10000k'
        };
        const bitrate = qualityMap[this.qualityInput.value];
        
        // Write files to FFmpeg filesystem
        if (this.isVideo) {
          this.setStatus('Loading video into FFmpeg...');
          const videoData = await fetchFile(this.videoFile);
          await this.ffmpeg.writeFile('input.mp4', videoData);
        } else {
          this.setStatus('Loading images into FFmpeg...');
          for (let i = 0; i < this.frames.length; i++) {
            const imgData = await fetchFile(this.frames[i]);
            await this.ffmpeg.writeFile(`frame_${String(i).padStart(4, '0')}.png`, imgData);
            this.showProgress((i / this.frames.length) * 30);
          }
        }
        
        this.setStatus('Encoding MP4...');
        
        // Build FFmpeg command
        let cmd;
        if (this.isVideo) {
          cmd = [
            '-i', 'input.mp4',
            '-r', String(fps),
            '-vf', height ? `scale=${width}:${height}` : `scale=${width}:-1`,
            '-c:v', 'libx264',
            '-preset', 'medium',
            '-crf', '23',
            '-b:v', bitrate,
            '-pix_fmt', 'yuv420p',
            '-movflags', '+faststart',
            'output.mp4'
          ];
        } else {
          cmd = [
            '-framerate', String(fps),
            '-i', 'frame_%04d.png',
            '-vf', height ? `scale=${width}:${height}` : `scale=${width}:-1`,
            '-c:v', 'libx264',
            '-preset', 'medium',
            '-crf', '23',
            '-b:v', bitrate,
            '-pix_fmt', 'yuv420p',
            '-movflags', '+faststart',
            'output.mp4'
          ];
        }
        
        await this.ffmpeg.exec(cmd);
        
        const data = await this.ffmpeg.readFile('output.mp4');
        const blob = new Blob([data.buffer], { type: 'video/mp4' });
        const url = URL.createObjectURL(blob);
        
        this.showPreview('video', url, blob, 'output.mp4');
        this.setStatus(`MP4 ready (${(blob.size/1024/1024).toFixed(2)} MB)`);
        
        // Cleanup
        if (this.isVideo) {
          await this.ffmpeg.deleteFile('input.mp4');
        } else {
          for (let i = 0; i < this.frames.length; i++) {
            await this.ffmpeg.deleteFile(`frame_${String(i).padStart(4, '0')}.png`);
          }
        }
        await this.ffmpeg.deleteFile('output.mp4');
      }
      
      async exportWebMFFmpeg() {
        this.setStatus('Preparing WebM export...');
        this.showProgress(0);
        
        const fps = parseInt(this.fpsInput.value) || 10;
        const width = parseInt(this.widthInput.value) || 720;
        const height = parseInt(this.heightInput.value) || '';
        
        const qualityMap = {
          'low': '1000k',
          'medium': '2500k',
          'high': '5000k',
          'ultra': '10000k'
        };
        const bitrate = qualityMap[this.qualityInput.value];
        
        // Write files to FFmpeg filesystem
        if (this.isVideo) {
          this.setStatus('Loading video into FFmpeg...');
          const videoData = await fetchFile(this.videoFile);
          await this.ffmpeg.writeFile('input.mp4', videoData);
        } else {
          this.setStatus('Loading images into FFmpeg...');
          for (let i = 0; i < this.frames.length; i++) {
            const imgData = await fetchFile(this.frames[i]);
            await this.ffmpeg.writeFile(`frame_${String(i).padStart(4, '0')}.png`, imgData);
            this.showProgress((i / this.frames.length) * 30);
          }
        }
        
        this.setStatus('Encoding WebM...');
        
        // Build FFmpeg command for WebM
        let cmd;
        if (this.isVideo) {
          cmd = [
            '-i', 'input.mp4',
            '-r', String(fps),
            '-vf', height ? `scale=${width}:${height}` : `scale=${width}:-1`,
            '-c:v', 'libvpx-vp9',
            '-b:v', bitrate,
            '-quality', 'good',
            '-cpu-used', '2',
            'output.webm'
          ];
        } else {
          cmd = [
            '-framerate', String(fps),
            '-i', 'frame_%04d.png',
            '-vf', height ? `scale=${width}:${height}` : `scale=${width}:-1`,
            '-c:v', 'libvpx-vp9',
            '-b:v', bitrate,
            '-quality', 'good',
            '-cpu-used', '2',
            'output.webm'
          ];
        }
        
        await this.ffmpeg.exec(cmd);
        
        const data = await this.ffmpeg.readFile('output.webm');
        const blob = new Blob([data.buffer], { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        
        this.showPreview('video', url, blob, 'output.webm');
        this.setStatus(`WebM ready (${(blob.size/1024/1024).toFixed(2)} MB)`);
        
        // Cleanup
        if (this.isVideo) {
          await this.ffmpeg.deleteFile('input.mp4');
        } else {
          for (let i = 0; i < this.frames.length; i++) {
            await this.ffmpeg.deleteFile(`frame_${String(i).padStart(4, '0')}.png`);
          }
        }
        await this.ffmpeg.deleteFile('output.webm');
      }
      
      async exportWebP() {
        this.setStatus('Preparing animated WebP export...');
        this.showProgress(0);
        
        const fps = parseInt(this.fpsInput.value) || 10;
        const width = parseInt(this.widthInput.value) || 512;
        const height = parseInt(this.heightInput.value) || '';
        
        const qualityMap = {
          'low': '60',
          'medium': '75',
          'high': '85',
          'ultra': '95'
        };
        const quality = qualityMap[this.qualityInput.value];
        
        // Write files to FFmpeg filesystem
        if (this.isVideo) {
          this.setStatus('Loading video into FFmpeg...');
          const videoData = await fetchFile(this.videoFile);
          await this.ffmpeg.writeFile('input.mp4', videoData);
        } else {
          this.setStatus('Loading images into FFmpeg...');
          for (let i = 0; i < this.frames.length; i++) {
            const imgData = await fetchFile(this.frames[i]);
            await this.ffmpeg.writeFile(`frame_${String(i).padStart(4, '0')}.png`, imgData);
            this.showProgress((i / this.frames.length) * 30);
          }
        }
        
        this.setStatus('Creating animated WebP...');
        
        // Build FFmpeg command for animated WebP
        let cmd;
        const frameDelay = Math.round(1000 / fps); // milliseconds per frame
        
        if (this.isVideo) {
          cmd = [
            '-i', 'input.mp4',
            '-vf', height ? `scale=${width}:${height},fps=${fps}` : `scale=${width}:-1,fps=${fps}`,
            '-loop', '0',
            '-preset', 'picture',
            '-quality', quality,
            '-compression_level', '6',
            'output.webp'
          ];
        } else {
          cmd = [
            '-framerate', String(fps),
            '-i', 'frame_%04d.png',
            '-vf', height ? `scale=${width}:${height}` : `scale=${width}:-1`,
            '-loop', '0',
            '-preset', 'picture',
            '-quality', quality,
            '-compression_level', '6',
            'output.webp'
          ];
        }
        
        await this.ffmpeg.exec(cmd);
        
        const data = await this.ffmpeg.readFile('output.webp');
        const blob = new Blob([data.buffer], { type: 'image/webp' });
        const url = URL.createObjectURL(blob);
        
        this.showPreview('image', url, blob, 'animation.webp');
        this.setStatus(`Animated WebP ready (${(blob.size/1024/1024).toFixed(2)} MB)`);
        
        // Cleanup
        if (this.isVideo) {
          await this.ffmpeg.deleteFile('input.mp4');
        } else {
          for (let i = 0; i < this.frames.length; i++) {
            await this.ffmpeg.deleteFile(`frame_${String(i).padStart(4, '0')}.png`);
          }
        }
        await this.ffmpeg.deleteFile('output.webp');
      }
      
      async exportWebMNative() {
        // Native browser WebM export (fallback)
        this.setStatus('Using native WebM encoder...');
        this.showProgress(0);
        
        const fps = parseInt(this.fpsInput.value) || 10;
        let width = parseInt(this.widthInput.value);
        let height = parseInt(this.heightInput.value);
        
        // Load frames as bitmaps for native encoding
        const bitmaps = [];
        if (this.isVideo) {
          // Extract frames from video
          const video = document.createElement('video');
          video.src = this.videoSrc;
          await new Promise(resolve => video.onloadedmetadata = resolve);
          
          if (!width && !height) {
            width = video.videoWidth;
            height = video.videoHeight;
          } else if (width && !height) {
            height = Math.round(video.videoHeight * (width / video.videoWidth));
          } else if (!width && height) {
            width = Math.round(video.videoWidth * (height / video.videoHeight));
          }
          
          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');
          
          const duration = video.duration;
          const frameCount = Math.ceil(duration * fps);
          
          for (let i = 0; i < frameCount; i++) {
            video.currentTime = i / fps;
            await new Promise(resolve => video.onseeked = resolve);
            ctx.drawImage(video, 0, 0);
            const bitmap = await createImageBitmap(canvas);
            bitmaps.push(bitmap);
            this.showProgress((i + 1) / frameCount * 50);
          }
        } else {
          for (let i = 0; i < this.frames.length; i++) {
            const bitmap = await createImageBitmap(this.frames[i]);
            bitmaps.push(bitmap);
            this.showProgress((i + 1) / this.frames.length * 50);
          }
          
          if (!width && !height) {
            width = bitmaps[0].width;
            height = bitmaps[0].height;
          } else if (width && !height) {
            height = Math.round(bitmaps[0].height * (width / bitmaps[0].width));
          } else if (!width && height) {
            width = Math.round(bitmaps[0].width * (height / bitmaps[0].height));
          }
        }
        
        // Create canvas and record
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        const stream = canvas.captureStream(fps);
        const qualityMap = { low: 500000, medium: 2500000, high: 5000000, ultra: 10000000 };
        const bitrate = qualityMap[this.qualityInput.value];
        
        const recorder = new MediaRecorder(stream, {
          mimeType: 'video/webm;codecs=vp9',
          videoBitsPerSecond: bitrate
        });
        
        const chunks = [];
        recorder.ondataavailable = e => chunks.push(e.data);
        
        recorder.start();
        
        for (let i = 0; i < bitmaps.length; i++) {
          ctx.clearRect(0, 0, width, height);
          ctx.drawImage(bitmaps[i], 0, 0, width, height);
          await new Promise(resolve => setTimeout(resolve, 1000 / fps));
          this.showProgress(50 + (i + 1) / bitmaps.length * 50);
        }
        
        recorder.stop();
        await new Promise(resolve => recorder.onstop = resolve);
        
        const blob = new Blob(chunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        
        this.showPreview('video', url, blob, 'output.webm');
        this.setStatus(`WebM ready (${(blob.size/1024/1024).toFixed(2)} MB)`);
      }
      
      cancelExport() {
        // FFmpeg doesn't have a direct cancel, but we can try to terminate
        if (this.ffmpeg) {
          this.ffmpeg.terminate();
          this.initFFmpeg(); // Reinitialize
        }
        this.isProcessing = false;
        this.btnExport.disabled = false;
        this.btnCancel.style.display = 'none';
        this.setStatus('Export canceled');
        this.hideProgress();
      }
      
      showPreview(type, url, blob, filename) {
        this.previewContainer.style.display = 'block';
        
        if (type === 'video') {
          this.videoPreview.src = url;
          this.videoPreview.style.display = 'block';
          this.imagePreview.style.display = 'none';
        } else {
          this.imagePreview.src = url;
          this.imagePreview.style.display = 'block';
          this.videoPreview.style.display = 'none';
        }
        
        this.downloadBtn.href = url;
        this.downloadBtn.download = filename;
      }
      
      setStatus(text) {
        this.status.textContent = text;
      }
      
      showProgress(percent) {
        this.progressBar.style.display = 'block';
        this.progressFill.style.width = `${percent}%`;
      }
      
      hideProgress() {
        setTimeout(() => {
          this.progressBar.style.display = 'none';
        }, 500);
      }
    }
    
    // Initialize the app
    const converter = new MediaConverter();
  </script>
</body>
</html>