<html>
<head>
    <title>Thumbnail Play Button Adder</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* Global Styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column; /* Stack vertically */
            justify-content: flex-start; /* Align items to the top */
            align-items: center; /* Center items horizontally */
            min-height: 100vh;
            background-color: #f0f2f5; /* Match crop tool */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px; /* Slightly larger radius */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* Softer shadow */
            text-align: center;
            width: 100%;
            max-width: 1100px; /* Increased width to accommodate controls better */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #1c1e21; /* Darker heading */
            margin-bottom: 25px;
            font-size: 2.2em; /* Slightly larger title */
            font-weight: 600;
        }

        /* --- Drop Zone Styles --- */
        .drop-zone {
            width: 90%; /* Relative width */
            max-width: 600px;
            height: 200px;
            border: 2px dashed #adb5bd; /* Subtler border color */
            border-radius: 10px; /* Consistent radius */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #f8f9fa; /* Lighter background */
            transition: all 0.3s ease;
            margin-bottom: 20px;
            cursor: pointer; /* Indicate clickability */
            color: #495057; /* Text color */
        }
        .drop-zone.drag-over {
            background: #e9ecef; /* Slightly darker on drag */
            border-color: #6c757d;
            transform: scale(1.02);
        }
        .drop-zone svg {
            width: 50px; /* Slightly smaller */
            height: 50px;
            margin-bottom: 15px;
            fill: #6c757d; /* Match border */
            pointer-events: none; /* SVG shouldn't intercept events */
        }
        .drop-zone p {
            font-size: 1.1em; /* Slightly larger text */
            margin: 0;
            color: #495057;
            pointer-events: none;
        }
        #imageUploadInput {
             display: none; /* Hide the actual file input */
        }
        /* --- End Drop Zone --- */


        /* --- Editor Section --- */
        .editor-section {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            gap: 25px; /* Add gap between preview and controls */
        }

        /* --- Crop Preview (adapted) --- */
        #preview-container {
            /* Allow dynamic sizing based on content */
            width: auto; /* Let flexbox handle initial size */
            max-width: 100%; /* Ensure it doesn't overflow */
            height: auto;
            /* aspect-ratio maintained by crop-area */
            position: relative;
            background: #e9ecef; /* Placeholder background */
            border-radius: 8px;
            overflow: hidden; /* Clip the crop area border if needed */
            border: 1px solid #dee2e6; /* Subtle border */
            /* Use flex to center the crop-area */
            display: flex;
            justify-content: center;
            align-items: center;
            /* Estimate max size for layout stability if needed, but flexible is better */
             min-height: 300px; /* Minimum height */
        }

        #crop-area {
            position: relative; /* Changed from absolute */
            /* top/left/transform removed */
            overflow: hidden; /* Crucial: This clips the image */
            border: 3px dashed rgba(0, 123, 255, 0.6); /* Updated color, slightly thinner */
            border-radius: 4px;
            box-sizing: content-box; /* Border should be outside dimensions */
            background-color: rgba(0,0,0, 0.05); /* Dim the outside area slightly */
             /* width/height set by JS based on aspect ratio and container constraints */
        }

        #crop-area img#previewImage { /* Target the image inside */
            position: absolute;
            left: 50%;
            top: 50%;
            transform-origin: center center;
            cursor: grab;
            user-select: none;
            -webkit-user-drag: none;
            display: block; /* Prevent extra space below image */
            max-width: none !important; /* Override any potential global max-width */
            z-index: 1; /* Below overlay and button */
        }
        #crop-area img#previewImage:active {
             cursor: grabbing;
        }

        /* --- Image Overlay --- */
        #imageOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0); /* Initial transparent */
            pointer-events: none; /* Don't interfere with interactions */
            z-index: 5; /* Above image, below button */
            transition: background-color 0.3s ease; /* Smooth transition */
        }
        /* --- End Image Overlay --- */

        /* --- End Crop Preview --- */


        /* --- Play Button Styling (Adjusted) --- */
        .play-button-container {
            position: absolute; /* Positioned relative to crop-area */
            /* top/left set by JS */
            transform: translate(-50%, -50%); /* Center the button based on JS top/left */
            cursor: grab;
            touch-action: none;
            z-index: 10; /* Ensure button is above the image and overlay */
            /* CSS Drop Shadow will be applied via JS */
            filter: drop-shadow(2px 3px 3px rgba(0, 0, 0, 0.4)); /* Default shadow */
            transition: filter 0.3s ease, opacity 0.3s ease; /* Smooth transitions */
        }
        .play-button-container:active {
            cursor: grabbing;
        }
        #playButtonSvg {
            display: block;
            /* width/height set by JS */
            pointer-events: none; /* Dragging is handled by container */
        }
        /* --- End Play Button --- */


        /* --- Controls Section --- */
        .controls-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center;
            gap: 20px; /* Space between control groups */
            width: 100%;
            max-width: 1050px; /* Align with container */
            margin-bottom: 20px;
        }

        .controls-group {
            background-color: #f8f9fa; /* Lighter group background */
            padding: 20px 25px; /* More padding */
            border-radius: 8px; /* Consistent radius */
            border: 1px solid #dee2e6; /* Softer border */
            text-align: left;
            flex: 1; /* Allow groups to grow */
            min-width: 300px; /* Minimum width before wrapping */
            box-sizing: border-box;
            display: flex; /* Use flex for internal layout */
            flex-direction: column;
            gap: 18px; /* Space between control items */
        }

        .controls-group h2 {
            margin-top: 0;
            margin-bottom: 5px; /* Reduced bottom margin */
            font-size: 1.3em; /* Slightly larger group title */
            color: #343a40; /* Darker text */
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
            font-weight: 600;
        }

        .control-item { /* Replaces control-group for better semantics */
            display: flex;
            flex-direction: column; /* Stack label and input/controls */
            gap: 8px; /* Space between label and input */
        }

        .control-item label {
            font-weight: 500; /* Slightly lighter weight */
            color: #495057;
            font-size: 0.95em; /* Slightly larger label */
            display: flex; /* Align label and value display */
            justify-content: space-between;
            align-items: center;
        }

        .control-item input[type="range"] {
            width: 100%; /* Full width */
            cursor: pointer;
            margin-top: 0; /* Remove top margin */
            accent-color: #007bff; /* Modern accent */
        }
        .control-item select,
        .control-item input[type="number"],
        .control-item input[type="text"],
        .control-item input[type="color"] { /* Style color input */
            padding: 8px 10px;
            border-radius: 5px; /* Slightly softer radius */
            border: 1px solid #ced4da;
            width: 100%; /* Full width */
            box-sizing: border-box;
            font-size: 0.9em;
            background-color: #fff; /* White background */
            transition: border-color 0.2s ease;
        }
         .control-item input[type="color"] {
             height: 38px; /* Match other inputs height */
             padding: 4px; /* Adjust padding for color input */
         }
        .control-item select:focus,
        .control-item input:focus {
            border-color: #80bdff;
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
        }

        .control-value-display { /* Common class for value spans */
            /* Removed min-width */
            text-align: right;
            font-size: 0.9em;
            color: #6c757d; /* Slightly darker value */
            font-weight: 400;
            /* Removed alignment/margin tweaks, handled by flexbox in label */
        }

        .dimension-inputs, .shadow-offset-inputs { /* Shared class for side-by-side inputs */
            display: flex;
            gap: 10px;
            width: 100%;
        }
        .dimension-inputs > div, .shadow-offset-inputs > div {
             flex: 1;
             display: flex;
             flex-direction: column;
             gap: 5px; /* Space between label and input within the sub-group */
        }
         /* Adjust labels within side-by-side groups */
         .dimension-inputs label, .shadow-offset-inputs label {
             margin-bottom: 0;
             justify-content: flex-start; /* Align label text left */
         }
         .dimension-inputs input, .shadow-offset-inputs input {
             margin-top: 0;
         }


        .ratio-btns {
             display: flex;
             flex-wrap: wrap;
             gap: 6px; /* Slightly more gap */
             margin-top: 5px;
        }
         .ratio-btns button {
            background: #e9ecef; /* Lighter button background */
            color: #495057;
            border: 1px solid #ced4da;
            padding: 5px 10px; /* Slightly more padding */
            border-radius: 5px;
            font-size: 0.85em;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
         }
          .ratio-btns button:hover {
              background: #dee2e6;
              border-color: #adb5bd;
          }
           .ratio-btns button.active { /* Style for active ratio */
                background: #007bff;
                color: white;
                border-color: #007bff;
           }


        /* --- Best Practices --- */
        .best-practices {
            background-color: #e7f3fe; /* Softer blue background */
            border: 1px solid #b3d7ff;
            color: #004085; /* Darker blue text for better contrast */
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: left;
            width: 100%;
            max-width: 1050px; /* Align with controls */
            box-sizing: border-box;
        }
         .best-practices h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            font-weight: 600;
            color: #004085;
        }
        .best-practices ul {
            margin: 0;
            padding-left: 20px;
            font-size: 0.95em; /* Slightly larger text */
            line-height: 1.6; /* Better readability */
        }


        /* --- Download Button --- */
        #downloadButton {
            padding: 12px 30px; /* More padding */
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 500; /* Medium weight */
            transition: background-color 0.3s ease, transform 0.1s ease;
            margin-top: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #downloadButton:hover {
            background-color: #218838;
        }
         #downloadButton:active {
            transform: scale(0.98); /* Click feedback */
         }
        #downloadButton:disabled {
            background-color: #adb5bd; /* Disabled color */
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }


        .hidden {
            display: none !important; /* Ensure hidden */
        }

        /* Responsive adjustments */
        @media (max-width: 1150px) { /* Adjust breakpoint */
             .container {
                 max-width: 95%;
             }
             .controls-container, .best-practices {
                max-width: 100%;
             }
             #preview-container {
                 /* Preview container can shrink more aggressively if needed */
                 min-height: 250px;
             }
        }

        @media (max-width: 768px) { /* Tablet breakpoint */
            .controls-group {
                 min-width: calc(50% - 10px); /* Two columns on tablet */
             }
             h1 {
                 font-size: 1.8em;
             }
        }


        @media (max-width: 600px) { /* Mobile breakpoint */
            body {
                padding: 10px;
            }
            .container {
                padding: 15px;
            }
             .controls-group {
                 min-width: 100%; /* Stack groups vertically */
             }
             .dimension-inputs, .shadow-offset-inputs {
                 flex-direction: column; /* Stack width/height inputs */
             }
             h1 {
                 font-size: 1.6em;
             }
              #downloadButton {
                  font-size: 1em;
                  padding: 10px 25px;
              }
              .drop-zone p {
                  font-size: 1em;
              }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Thumbnail Play Button Adder</h1>

        <!-- Drop Zone (Initially Visible) -->
        <label for="imageUploadInput" class="drop-zone" id="dropZone">
             <svg viewBox="0 0 24 24">
                <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4C9.11 4 6.6 5.64 5.35 8.04C2.34 8.36 0 10.91 0 14C0 17.31 2.69 20 6 20H19C21.76 20 24 17.76 24 15C24 12.36 21.95 10.22 19.35 10.04ZM14 13V17H10V13H7L12 8L17 13H14Z"/>
            </svg>
            <p>Drag & Drop Image Here or Click to Upload</p>
        </label>
        <input type="file" id="imageUploadInput" accept="image/*">


        <!-- Editor Section (Initially Hidden) -->
        <div class="editor-section hidden">
             <!-- Crop Preview Area -->
            <div id="preview-container">
                <div id="crop-area">
                    <!-- Image will be added here by JS -->
                    <div id="imageOverlay"></div>
                     <div id="playButtonContainer" class="play-button-container">
                        <svg id="playButtonSvg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                            <!-- SVG content will be generated by JS -->
                        </svg>
                    </div>
                </div>
            </div>

             <!-- Controls -->
            <div class="controls-container">
                <!-- Image Crop Controls Group -->
                <div class="controls-group">
                    <h2>Image & Crop</h2>
                     <!-- Aspect Ratio -->
                    <div class="control-item">
                        <label for="aspectRatioSlider">Aspect Ratio: <span id="ratioDisplay" class="control-value-display">16:9</span></label>
                        <input type="range" id="aspectRatioSlider" min="0.3333" max="3" step="0.01" value="1.7778">
                        <div class="ratio-btns" id="keystoneButtons">
                            <!-- Buttons added by JS -->
                        </div>
                    </div>
                     <!-- Rotation -->
                    <div class="control-item">
                        <label for="rotationSlider">Rotation (째): <span id="rotationDisplay" class="control-value-display">0째</span></label>
                        <input type="range" id="rotationSlider" min="-45" max="45" step="0.5" value="0">
                    </div>
                    <!-- Zoom -->
                    <div class="control-item">
                         <label for="zoomSlider">Zoom: <span id="zoomDisplay" class="control-value-display">1.00</span></label>
                        <input type="range" id="zoomSlider" step="0.01">
                    </div>
                    <!-- Image Overlay Controls -->
                    <div class="control-item">
                         <label for="overlayColor">Image Overlay Color: <span id="overlayOpacityValue" class="control-value-display">0%</span></label>
                        <input type="color" id="overlayColor" value="#000000"> <!-- Default to black, opacity set via JS -->
                    </div>
                     <!-- Export Dimensions -->
                     <div class="control-item dimension-inputs">
                         <div>
                             <label for="canvasWidthInput">Export Width (px):</label>
                            <input type="number" id="canvasWidthInput" placeholder="e.g., 1920">
                         </div>
                         <div>
                             <label for="canvasHeightInput">Export Height (px):</label>
                            <input type="number" id="canvasHeightInput" placeholder="e.g., 1080">
                         </div>
                    </div>
                     <!-- Filename -->
                     <div class="control-item">
                        <label for="filenameInput">Filename Prefix:</label>
                        <input type="text" id="filenameInput" placeholder="my_thumbnail">
                    </div>
                </div>

                <!-- Play Button Controls Group -->
                 <div class="controls-group">
                    <h2>Play Button</h2>
                    <div class="control-item">
                        <label for="buttonStyle">Style:</label>
                        <select id="buttonStyle">
                            <!-- Options populated by JS -->
                        </select>
                    </div>
                    <div class="control-item">
                        <label for="buttonSize">Size: <span id="buttonSizeValue" class="control-value-display">80px</span></label>
                        <input type="range" id="buttonSize" min="20" max="300" value="80">
                    </div>
                    <div class="control-item">
                        <label for="buttonOpacity">Opacity: <span id="buttonOpacityValue" class="control-value-display">0.90</span></label>
                        <input type="range" id="buttonOpacity" min="0" max="1" step="0.05" value="0.9">
                    </div>
                     <!-- Position Controls -->
                     <div class="control-item">
                         <label>Position (X / Y):</label>
                         <div class="dimension-inputs"> <!-- Re-use dimension-inputs class for layout -->
                             <div>
                                <label for="positionX"><span id="positionXValue" class="control-value-display">50%</span></label>
                                <input type="range" id="positionX" min="0" max="100" step="0.5" value="50">
                             </div>
                             <div>
                                <label for="positionY"><span id="positionYValue" class="control-value-display">50%</span></label>
                                <input type="range" id="positionY" min="0" max="100" step="0.5" value="50">
                             </div>
                         </div>
                    </div>
                    <!-- Shadow Controls -->
                     <div class="control-item">
                        <label>Shadow:</label>
                        <div class="shadow-offset-inputs">
                             <div>
                                <label for="shadowOffsetX">Offset X (px): <span id="shadowOffsetXValue" class="control-value-display">2</span></label>
                                <input type="range" id="shadowOffsetX" min="-10" max="10" step="1" value="2">
                             </div>
                             <div>
                                <label for="shadowOffsetY">Offset Y (px): <span id="shadowOffsetYValue" class="control-value-display">3</span></label>
                                <input type="range" id="shadowOffsetY" min="-10" max="10" step="1" value="3">
                             </div>
                         </div>
                     </div>
                      <div class="control-item">
                          <label for="shadowBlur">Blur (px): <span id="shadowBlurValue" class="control-value-display">3</span></label>
                         <input type="range" id="shadowBlur" min="0" max="20" step="1" value="3">
                      </div>
                      <div class="control-item">
                         <label for="shadowColor">Color & Opacity:</label>
                        <input type="color" id="shadowColor" value="#000000"> <!-- Default shadow color black -->
                    </div>

                 </div>
            </div>

            <div class="best-practices">
                <h3>Best Practices</h3>
                <ul>
                     <li>Use the default 16:9 aspect ratio for standard video thumbnails.</li>
                    <li>Ensure high contrast between the play button and the image background, potentially using the overlay.</li>
                     <li>Adjust the play button shadow for better visibility against complex backgrounds.</li>
                    <li>Place the button centrally or where it draws attention without obscuring key elements.</li>
                     <li>Adjust zoom and position to frame the most important part of your image.</li>
                    <li>Avoid making the button too large or too small relative to the thumbnail.</li>
                     <li>Check the preview carefully on different potential background colors before downloading.</li>
                </ul>
            </div>

            <button id="downloadButton" disabled>Download Image</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "canvas-confetti": "https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/+esm"
        }
    }
    </script>
    <script type="module">
        import confetti from 'canvas-confetti';

        // --- Configuration ---
        const DEFAULT_ASPECT_RATIO = 16 / 9;
        const DEFAULT_EXPORT_WIDTH = 1920;
        const DEFAULT_EXPORT_HEIGHT = 1080;
        const PLAY_BUTTON_STYLES = {
            classicRed: `
                <g filter="url(#shadow)">
                    <circle cx="50" cy="50" r="45" fill="#FF0000"/>
                    <path d="M 40,30 L 70,50 L 40,70 z" fill="#FFFFFF"/>
                </g>
                 <defs>
                    <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                        <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
                        <feOffset dx="2" dy="2" result="offsetblur"/>
                        <feComponentTransfer>
                            <feFuncA type="linear" slope="0.5"/>
                        </feComponentTransfer>
                        <feMerge>
                            <feMergeNode/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
            `,
            whiteOutline: `
                <circle cx="50" cy="50" r="45" fill="none" stroke="#FFFFFF" stroke-width="5"/>
                <path d="M 40,30 L 70,50 L 40,70 z" fill="#FFFFFF"/>
            `,
            blackSolid: `
                <circle cx="50" cy="50" r="48" fill="#000000"/>
                <path d="M 42,32 L 72,50 L 42,68 z" fill="#FFFFFF"/>
            `,
            gradientCircle: `
                 <defs>
                    <radialGradient id="grad1" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                        <stop offset="0%" style="stop-color:rgb(255,255,255);stop-opacity:0.4" />
                        <stop offset="100%" style="stop-color:rgb(200,0,0);stop-opacity:0.8" />
                    </radialGradient>
                     <filter id="shadow2" x="-20%" y="-20%" width="140%" height="140%">
                        <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
                        <feOffset dx="1" dy="1" result="offsetblur"/>
                         <feComponentTransfer>
                            <feFuncA type="linear" slope="0.6"/>
                        </feComponentTransfer>
                        <feMerge>
                            <feMergeNode/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
                 <g filter="url(#shadow2)">
                    <circle cx="50" cy="50" r="46" fill="url(#grad1)" />
                    <path d="M 41,31 L 71,50 L 41,69 z" fill="#FFFFFF" stroke="#fff" stroke-width="1.5"/>
                </g>
            `,
             minimalTriangle: `
                <path d="M 35,25 L 75,50 L 35,75 z" fill="#FFFFFF"/>
                 <!-- Note: Removed internal shadow for minimal style, use CSS shadow -->
            `};

        const KEYSTONE_RATIOS = [
            { label: "1:3", value: 0.3333 }, { label: "1:2", value: 0.5 },
            { label: "9:16", value: 0.5625 }, { label: "10:16", value: 0.625 },
            { label: "2:3", value: 0.6667 }, { label: "3:4", value: 0.75 },
            { label: "4:5", value: 0.8 }, { label: "1:1", value: 1 },
            { label: "5:4", value: 1.25 }, { label: "4:3", value: 1.3333 },
            { label: "3:2", value: 1.5 }, { label: "16:10", value: 1.6 },
            { label: "16:9", value: 1.7778 }, { label: "2:1", value: 2 },
            { label: "3:1", value: 3 }
        ];

        // --- DOM Elements ---
        const dropZone = document.getElementById('dropZone');
        const imageUploadInput = document.getElementById('imageUploadInput');
        const editorSection = document.querySelector('.editor-section');
        const previewContainer = document.getElementById('preview-container');
        const cropArea = document.getElementById('crop-area');
        const imageOverlay = document.getElementById('imageOverlay'); // New
        const playButtonContainer = document.getElementById('playButtonContainer');
        const playButtonSvg = document.getElementById('playButtonSvg');
        const downloadButton = document.getElementById('downloadButton');

        // Crop Controls
        const aspectRatioSlider = document.getElementById('aspectRatioSlider');
        const ratioDisplay = document.getElementById('ratioDisplay');
        const keystoneButtonsContainer = document.getElementById('keystoneButtons');
        const rotationSlider = document.getElementById('rotationSlider');
        const rotationDisplay = document.getElementById('rotationDisplay');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomDisplay = document.getElementById('zoomDisplay');
        const canvasWidthInput = document.getElementById('canvasWidthInput');
        const canvasHeightInput = document.getElementById('canvasHeightInput');
        const filenameInput = document.getElementById('filenameInput');

        // Image Overlay Controls (New)
        const overlayColorInput = document.getElementById('overlayColor');
        const overlayOpacityValue = document.getElementById('overlayOpacityValue');

        // Play Button Controls
        const buttonStyleSelect = document.getElementById('buttonStyle');
        const buttonSizeSlider = document.getElementById('buttonSize');
        const buttonSizeValue = document.getElementById('buttonSizeValue');
        const buttonOpacitySlider = document.getElementById('buttonOpacity');
        const buttonOpacityValue = document.getElementById('buttonOpacityValue');
        const positionXSlider = document.getElementById('positionX');
        const positionXValue = document.getElementById('positionXValue');
        const positionYSlider = document.getElementById('positionY');
        const positionYValue = document.getElementById('positionYValue');

        // Play Button Shadow Controls (New)
        const shadowOffsetXSlider = document.getElementById('shadowOffsetX');
        const shadowOffsetXValue = document.getElementById('shadowOffsetXValue');
        const shadowOffsetYSlider = document.getElementById('shadowOffsetY');
        const shadowOffsetYValue = document.getElementById('shadowOffsetYValue');
        const shadowBlurSlider = document.getElementById('shadowBlur');
        const shadowBlurValue = document.getElementById('shadowBlurValue');
        const shadowColorInput = document.getElementById('shadowColor');


        // --- State Variables ---
        let currentImage = null; // The loaded Image object
        let previewImageElement = null; // The <img> element in the DOM
        let currentFilename = 'thumbnail';
        let currentFileType = 'image/png'; // Default download type

        // Crop State
        let aspectRatio = DEFAULT_ASPECT_RATIO;
        let displayTargetWidth = 0; // Crop area width in px
        let displayTargetHeight = 0; // Crop area height in px
        let offsetX = 0; // Image pan X offset within crop area
        let offsetY = 0; // Image pan Y offset within crop area
        let currentRotation = 0; // Image rotation in degrees
        let userZoom = 1; // Image zoom level
        let coverScale = 1; // Scale needed to cover crop area (for panning limits)
        let isDraggingImage = false;
        let dragStartX = 0, dragStartY = 0;

        // Image Overlay State (New)
        let currentOverlayColor = 'rgba(0, 0, 0, 0)'; // Initial: transparent black

        // Play Button State
        let currentButtonStyle = 'classicRed';
        let currentButtonSize = 80; // Default size adjusted
        let currentButtonOpacity = 0.9;
        let currentPosition = { x: 50, y: 50 }; // Percentage based position relative to crop area
        let isDraggingButton = false;
        let btnDragStartX, btnDragStartY;

        // Play Button Shadow State (New)
        let shadowOffsetX = 2;
        let shadowOffsetY = 3;
        let shadowBlur = 3;
        let shadowColor = 'rgba(0, 0, 0, 0.4)'; // Default shadow color with alpha


        // --- Initialization ---
        function initialize() {
            setupDragAndDrop();
            setupCropControls();
            setupOverlayControls(); // New
            setupPlayButtonControls();
            setupPlayButtonDragging();
            setupShadowControls(); // New
            downloadButton.addEventListener('click', handleDownload);
            populateStyleSelector();
            populateKeystoneButtons();
            updatePlayButton(); // Initial render with defaults
            updatePlayButtonShadow(); // Initial shadow render
            updateImageOverlay(); // Initial overlay render
            // Set initial shadow color input value (split hex and alpha manually)
            const initialShadowRgba = parseRgba(shadowColor);
            shadowColorInput.value = rgbToHex(initialShadowRgba.r, initialShadowRgba.g, initialShadowRgba.b);
             // Set initial overlay color input value (without alpha initially)
            overlayColorInput.value = '#000000'; // Default to black hex
            updateOverlayOpacityDisplay(0); // Start with 0% opacity visually
        }

        // --- File Handling & Loading ---
        function setupDragAndDrop() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false); // Prevent browser default drop behavior
            });
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.add('drag-over'), false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.remove('drag-over'), false);
            });
            dropZone.addEventListener('drop', handleDrop, false);
            // Allow clicking the drop zone to open file dialog
            dropZone.addEventListener('click', () => imageUploadInput.click());
            imageUploadInput.addEventListener('change', handleFileInputChange);
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleFileInputChange(e) {
             const files = e.target.files;
             if (files.length > 0) {
                processFile(files[0]);
             }
              // Reset input value to allow uploading the same file again
             e.target.value = null;
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            let file = null;
            if (dt.items) {
                for (let i = 0; i < dt.items.length; i++) {
                    if (dt.items[i].kind === 'file' && dt.items[i].type.startsWith('image/')) {
                        file = dt.items[i].getAsFile();
                        break; // Only process the first valid image file
                    }
                }
            } else if (dt.files) {
                 for (let i = 0; i < dt.files.length; i++) {
                     if (dt.files[i].type.startsWith('image/')) {
                         file = dt.files[i];
                         break; // Only process the first valid image file
                     }
                 }
            }

            if (file) {
                processFile(file);
            } else {
                 alert('Please drop a valid image file.');
            }
        }

         function processFile(file) {
            if (!file.type.startsWith('image/')) {
                 alert('Please upload a valid image file.');
                 return;
            }
            currentFileType = file.type; // Store original file type
            // Suggest a filename based on the uploaded file
            currentFilename = file.name.substring(0, file.name.lastIndexOf('.')) || 'thumbnail';
            filenameInput.value = currentFilename.replace(/[^a-zA-Z0-9_]/g, '_'); // Sanitize


            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    resetCropAndButtonState(); // Reset transforms and button position
                    setupPreviewImage(e.target.result);

                    // Use requestAnimationFrame to ensure dimensions are ready for calculation
                    requestAnimationFrame(() => {
                        setDefaultExportSize(); // Set 16:9 default size based on image dimensions
                        updateCropAreaDimensions(); // Update crop box based on default aspect ratio
                        calculateFitZoom(); // Calculate initial zoom to fit
                        constrainOffsets(); // Ensure initial offset is valid
                        updatePreview(); // Apply initial transforms
                        updatePlayButton(); // Render button with default settings
                        updatePlayButtonPosition(); // Ensure button is positioned correctly
                        updatePlayButtonShadow(); // Apply default shadow
                        updateImageOverlay(); // Apply default overlay

                        editorSection.classList.remove('hidden');
                        dropZone.classList.add('hidden'); // Hide drop zone
                        downloadButton.disabled = false;
                    });
                };
                 img.onerror = () => {
                     alert('Error loading image.');
                     resetUI();
                 };
                img.src = e.target.result;
            };
            reader.onerror = () => {
                alert('Error reading file.');
                 resetUI();
            };
            reader.readAsDataURL(file);
        }

        function resetUI() {
             editorSection.classList.add('hidden');
             dropZone.classList.remove('hidden');
             downloadButton.disabled = true;
             currentImage = null;
             if (previewImageElement) {
                 previewImageElement.remove();
                 previewImageElement = null;
             }
             cropArea.style.width = 'auto'; // Reset crop area size
             cropArea.style.height = 'auto';
        }

         function setupPreviewImage(src) {
             if (previewImageElement) {
                 previewImageElement.remove(); // Remove old image if exists
             }
             previewImageElement = document.createElement('img');
             previewImageElement.id = 'previewImage';
             previewImageElement.alt = "Image Preview";
             previewImageElement.src = src;
             // Insert image *before* the overlay
             cropArea.insertBefore(previewImageElement, imageOverlay);

             // Add dragging listeners directly to the image now it exists
             previewImageElement.addEventListener('mousedown', startImageDrag);
             document.addEventListener('mousemove', dragImage);
             document.addEventListener('mouseup', endImageDrag);
             document.addEventListener('mouseleave', endImageDrag); // Also end drag if mouse leaves window

             // Add wheel zoom listener to the crop area
             cropArea.removeEventListener('wheel', handleWheelZoom); // Remove previous listener if any
             cropArea.addEventListener('wheel', handleWheelZoom, { passive: false });
         }


        // --- Crop Logic ---
        function setupCropControls() {
            aspectRatioSlider.addEventListener('input', handleAspectRatioChange);
            rotationSlider.addEventListener('input', handleRotationChange);
            zoomSlider.addEventListener('input', handleZoomChange);
            canvasWidthInput.addEventListener('input', handleCustomExportDimChange);
            canvasHeightInput.addEventListener('input', handleCustomExportDimChange);
        }

        function resetCropAndButtonState() {
            aspectRatio = DEFAULT_ASPECT_RATIO;
            aspectRatioSlider.value = aspectRatio;
            currentRotation = 0;
            rotationSlider.value = 0;
            offsetX = 0;
            offsetY = 0;
            userZoom = 1; 

            currentButtonStyle = 'classicRed';
            buttonStyleSelect.value = currentButtonStyle;
            currentButtonSize = 80;
            buttonSizeSlider.value = currentButtonSize;
            currentButtonOpacity = 0.9;
            buttonOpacitySlider.value = currentButtonOpacity;
            currentPosition = { x: 50, y: 50 };
            positionXSlider.value = 50;
            positionYSlider.value = 50;

             currentOverlayColor = 'rgba(0, 0, 0, 0)';
             overlayColorInput.value = '#000000'; 

             shadowOffsetX = 2;
             shadowOffsetY = 3;
             shadowBlur = 3;
             shadowColor = 'rgba(0, 0, 0, 0.4)';
             shadowOffsetXSlider.value = shadowOffsetX;
             shadowOffsetYSlider.value = shadowOffsetY;
             shadowBlurSlider.value = shadowBlur;
             const initialShadowRgba = parseRgba(shadowColor);
             shadowColorInput.value = rgbToHex(initialShadowRgba.r, initialShadowRgba.g, initialShadowRgba.b);


            updateRatioDisplay();
            rotationDisplay.textContent = `${currentRotation}째`;
            buttonSizeValue.textContent = `${currentButtonSize}px`;
            buttonOpacityValue.textContent = currentButtonOpacity.toFixed(2);
            positionXValue.textContent = `${Math.round(currentPosition.x)}%`;
            positionYValue.textContent = `${Math.round(currentPosition.y)}%`;
            updateOverlayOpacityDisplay(0); 
            shadowOffsetXValue.textContent = `${shadowOffsetX}`;
            shadowOffsetYValue.textContent = `${shadowOffsetY}`;
            shadowBlurValue.textContent = `${shadowBlur}`;

             if (currentImage) { 
                 updateImageOverlay();
                 updatePlayButtonShadow();
             }
        }

         function setDefaultExportSize() {
            if (!currentImage) return;

            const imgWidth = currentImage.naturalWidth;
            const imgHeight = currentImage.naturalHeight;

            let targetWidth, targetHeight;

            if (imgWidth >= DEFAULT_EXPORT_WIDTH && imgHeight >= DEFAULT_EXPORT_HEIGHT) {
                targetWidth = DEFAULT_EXPORT_WIDTH;
                targetHeight = DEFAULT_EXPORT_HEIGHT;
            } else {
                const imgAspect = imgWidth / imgHeight;
                if (imgAspect > DEFAULT_ASPECT_RATIO) {
                    targetHeight = imgHeight;
                    targetWidth = Math.round(targetHeight * DEFAULT_ASPECT_RATIO);
                } else {
                    targetWidth = imgWidth;
                    targetHeight = Math.round(targetWidth / DEFAULT_ASPECT_RATIO);
                }
            }

            canvasWidthInput.value = targetWidth;
            canvasHeightInput.value = targetHeight;
            aspectRatio = targetWidth / targetHeight;
            aspectRatioSlider.value = aspectRatio;
            updateRatioDisplay();
            updateActiveKeystoneButton();
         }

        function handleAspectRatioChange() {
            aspectRatio = parseFloat(aspectRatioSlider.value);
             canvasWidthInput.value = "";
             canvasHeightInput.value = "";
            updateCropAreaDimensions();
            updateRatioDisplay();
            calculateFitZoom(); 
            updatePreview();
            constrainOffsets(); 
            updatePreview();
            updateActiveKeystoneButton();
        }

         function handleKeystoneButtonClick(value) {
             aspectRatio = value;
             aspectRatioSlider.value = value;
             canvasWidthInput.value = "";
             canvasHeightInput.value = "";
             updateCropAreaDimensions();
             updateRatioDisplay();
             calculateFitZoom();
             updatePreview();
             constrainOffsets();
             updatePreview();
             updateActiveKeystoneButton();
         }

        function handleRotationChange() {
            currentRotation = parseFloat(rotationSlider.value);
            rotationDisplay.textContent = `${currentRotation.toFixed(1)}째`;
            updatePreview();
            constrainOffsets(); 
            updatePreview();
        }

        function handleZoomChange() {
            userZoom = parseFloat(zoomSlider.value);
            updatePreview();
            constrainOffsets(); 
            updatePreview();
        }

        function handleWheelZoom(e) {
            if (!currentImage) return;
            e.preventDefault();
            const step = 0.05 * userZoom; 
            const zoomMin = parseFloat(zoomSlider.min);
            const zoomMax = parseFloat(zoomSlider.max);
            if (e.deltaY < 0) { 
                userZoom = Math.min(userZoom + step, zoomMax);
            } else { 
                userZoom = Math.max(userZoom - step, zoomMin);
            }
            zoomSlider.value = userZoom;
            updatePreview();
            constrainOffsets();
            updatePreview();
        }


        function handleCustomExportDimChange() {
            const cw = parseFloat(canvasWidthInput.value);
            const ch = parseFloat(canvasHeightInput.value);

            if (cw > 0 && ch > 0) {
                aspectRatio = cw / ch;
                aspectRatioSlider.value = aspectRatio; 
                updateRatioDisplay();
                updateCropAreaDimensions();
                calculateFitZoom(); 
                updatePreview();
                 constrainOffsets(); 
                 updatePreview();
                 updateActiveKeystoneButton();
            }
        }

        function updateCropAreaDimensions() {
            const container = previewContainer; 
            const maxContainerWidth = container.clientWidth || window.innerWidth * 0.8; 
            const maxContainerHeight = container.clientHeight || window.innerHeight * 0.6; 

            if (maxContainerWidth <= 0 || maxContainerHeight <= 0) {
                requestAnimationFrame(updateCropAreaDimensions);
                return;
            }

            const containerRatio = maxContainerWidth / maxContainerHeight;

            if (aspectRatio > containerRatio) {
                displayTargetWidth = maxContainerWidth;
                displayTargetHeight = Math.round(maxContainerWidth / aspectRatio);
            } else {
                displayTargetHeight = maxContainerHeight;
                displayTargetWidth = Math.round(maxContainerHeight * aspectRatio);
            }

            displayTargetWidth = Math.max(1, displayTargetWidth);
            displayTargetHeight = Math.max(1, displayTargetHeight);

            cropArea.style.width = `${displayTargetWidth}px`;
            cropArea.style.height = `${displayTargetHeight}px`;

            updatePlayButtonPosition(); 
        }

        function updateRatioDisplay() {
            let displayText;
            const tolerance = 0.01; 
            let matchedRatio = KEYSTONE_RATIOS.find(r => Math.abs(r.value - aspectRatio) < tolerance);

            if (matchedRatio) {
                displayText = matchedRatio.label;
            } else if (aspectRatio >= 1) {
                displayText = `${aspectRatio.toFixed(2)}:1`;
            } else {
                displayText = `1:${(1 / aspectRatio).toFixed(2)}`;
            }
            ratioDisplay.textContent = displayText;
        }

        function populateKeystoneButtons() {
             keystoneButtonsContainer.innerHTML = "";
             KEYSTONE_RATIOS.forEach(ratioObj => {
                const btn = document.createElement('button');
                btn.textContent = ratioObj.label;
                 btn.dataset.value = ratioObj.value; 
                btn.addEventListener('click', () => handleKeystoneButtonClick(ratioObj.value));
                keystoneButtonsContainer.appendChild(btn);
             });
             updateActiveKeystoneButton(); 
        }

         function updateActiveKeystoneButton() {
            const buttons = keystoneButtonsContainer.querySelectorAll('button');
            buttons.forEach(btn => {
                if (Math.abs(parseFloat(btn.dataset.value) - aspectRatio) < 0.001) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
         }


        function calculateFitZoom() {
             if (!currentImage || displayTargetWidth === 0 || displayTargetHeight === 0) return;

            const rad = Math.abs(currentRotation * Math.PI / 180);
             const imgW = currentImage.naturalWidth;
             const imgH = currentImage.naturalHeight;

             const effectiveWidthNeeded = displayTargetWidth * Math.cos(rad) + displayTargetHeight * Math.sin(rad);
             const effectiveHeightNeeded = displayTargetWidth * Math.sin(rad) + displayTargetHeight * Math.cos(rad);

             const scaleX = effectiveWidthNeeded / imgW;
             const scaleY = effectiveHeightNeeded / imgH;

             const fitScale = Math.max(displayTargetWidth / imgW, displayTargetHeight / imgH); 

             coverScale = Math.max(scaleX, scaleY); 

             zoomSlider.min = fitScale.toFixed(4); 
             zoomSlider.max = Math.max(2, coverScale * 1.5).toFixed(4); 

             userZoom = coverScale;
             zoomSlider.value = userZoom;
             zoomDisplay.textContent = userZoom.toFixed(2);
        }

        function updatePreview() {
             if (!previewImageElement || !currentImage) return;

            previewImageElement.style.width = `${currentImage.naturalWidth}px`;
            previewImageElement.style.height = `${currentImage.naturalHeight}px`;
             previewImageElement.style.transition = isDraggingImage ? "none" : "transform 0.1s ease-out";
            previewImageElement.style.transform = `translate(-50%, -50%) translate(${offsetX}px, ${offsetY}px) scale(${userZoom}) rotate(${currentRotation}deg)`;

            zoomDisplay.textContent = userZoom.toFixed(2);
        }

         function clamp(val, min, max) {
            return Math.min(Math.max(val, min), max);
         }

        function constrainOffsets() {
            if (!currentImage || !previewImageElement || displayTargetWidth === 0 || displayTargetHeight === 0) return;

            const w = currentImage.naturalWidth * userZoom;
            const h = currentImage.naturalHeight * userZoom;
            const rad = currentRotation * Math.PI / 180;
            const cos = Math.abs(Math.cos(rad));
            const sin = Math.abs(Math.sin(rad));
            const bbWidth = w * cos + h * sin; 
            const bbHeight = w * sin + h * cos; 

            const maxOffsetX = Math.max(0, (bbWidth - displayTargetWidth) / 2);
            const maxOffsetY = Math.max(0, (bbHeight - displayTargetHeight) / 2);

            offsetX = clamp(offsetX, -maxOffsetX, maxOffsetX);
            offsetY = clamp(offsetY, -maxOffsetY, maxOffsetY);
        }

        // --- Image Dragging ---
         function startImageDrag(e) {
             if (!currentImage || e.button !== 0) return; 
             e.preventDefault(); 
             isDraggingImage = true;
             if(previewImageElement) previewImageElement.style.cursor = 'grabbing';
             dragStartX = e.clientX;
             dragStartY = e.clientY;
         }

         function dragImage(e) {
             if (!isDraggingImage) return;
             e.preventDefault();
             const dx = e.clientX - dragStartX;
             const dy = e.clientY - dragStartY;
             dragStartX = e.clientX;
             dragStartY = e.clientY;
             offsetX += dx;
             offsetY += dy;
             constrainOffsets();
             updatePreview();
         }

         function endImageDrag(e) {
             if (isDraggingImage) {
                 isDraggingImage = false;
                  if(previewImageElement) previewImageElement.style.cursor = 'grab';
                 constrainOffsets();
                 updatePreview();
             }
         }

        // --- Image Overlay Logic (New) ---
        function setupOverlayControls() {
            overlayColorInput.addEventListener('input', handleOverlayColorChange);
        }

        function handleOverlayColorChange() {
            const hexColor = overlayColorInput.value;
            const currentAlpha = parseRgba(currentOverlayColor).a;
            const rgb = hexToRgb(hexColor);
            if (rgb) {
                 currentOverlayColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${currentAlpha})`;
                 updateImageOverlay();
            }
        }

        function updateImageOverlay() {
             imageOverlay.style.backgroundColor = currentOverlayColor;
             const alpha = parseRgba(currentOverlayColor).a;
             updateOverlayOpacityDisplay(alpha);
        }

        function updateOverlayOpacityDisplay(alpha) {
             const percentage = Math.round(alpha * 100);
             overlayOpacityValue.textContent = `${percentage}%`;
        }

        // --- Play Button Logic ---
        function setupPlayButtonControls() {
            buttonStyleSelect.addEventListener('change', (event) => {
                currentButtonStyle = event.target.value;
                updatePlayButton();
            });
            buttonSizeSlider.addEventListener('input', (event) => {
                currentButtonSize = parseInt(event.target.value, 10);
                buttonSizeValue.textContent = `${currentButtonSize}px`;
                updatePlayButton(); 
                updatePlayButtonPosition(); 
            });
            buttonOpacitySlider.addEventListener('input', (event) => {
                currentButtonOpacity = parseFloat(event.target.value);
                buttonOpacityValue.textContent = currentButtonOpacity.toFixed(2);
                updatePlayButton(); 
            });
            positionXSlider.addEventListener('input', (event) => {
                currentPosition.x = parseFloat(event.target.value);
                positionXValue.textContent = `${Math.round(currentPosition.x)}%`;
                updatePlayButtonPosition();
            });
            positionYSlider.addEventListener('input', (event) => {
                currentPosition.y = parseFloat(event.target.value);
                positionYValue.textContent = `${Math.round(currentPosition.y)}%`;
                updatePlayButtonPosition();
            });
        }

        function getPlayButtonSvgContent(style) {
            return PLAY_BUTTON_STYLES[style] || PLAY_BUTTON_STYLES.classicRed;
        }

        function updatePlayButton() {
            playButtonSvg.innerHTML = PLAY_BUTTON_STYLES[currentButtonStyle] || PLAY_BUTTON_STYLES.classicRed;
            playButtonSvg.style.width = `${currentButtonSize}px`;
            playButtonSvg.style.height = `${currentButtonSize}px`;
            playButtonContainer.style.opacity = currentButtonOpacity;
        }

        function updatePlayButtonPosition() {
             if (displayTargetWidth === 0 || displayTargetHeight === 0) return; 

            const posX = (currentPosition.x / 100) * displayTargetWidth;
            const posY = (currentPosition.y / 100) * displayTargetHeight;

            playButtonContainer.style.left = `${posX}px`;
            playButtonContainer.style.top = `${posY}px`;
        }

        function populateStyleSelector() {
            buttonStyleSelect.innerHTML = '';
            for (const styleKey in PLAY_BUTTON_STYLES) {
                const option = document.createElement('option');
                option.value = styleKey;
                option.textContent = styleKey.replace(/([A-Z])/g, ' $1').replace(/^./, (str) => str.toUpperCase());
                buttonStyleSelect.appendChild(option);
            }
            buttonStyleSelect.value = currentButtonStyle;
        }

        // --- Play Button Shadow Logic (New) ---
        function setupShadowControls() {
            shadowOffsetXSlider.addEventListener('input', (e) => {
                shadowOffsetX = parseInt(e.target.value, 10);
                shadowOffsetXValue.textContent = shadowOffsetX;
                updatePlayButtonShadow();
            });
            shadowOffsetYSlider.addEventListener('input', (e) => {
                shadowOffsetY = parseInt(e.target.value, 10);
                shadowOffsetYValue.textContent = shadowOffsetY;
                updatePlayButtonShadow();
            });
            shadowBlurSlider.addEventListener('input', (e) => {
                shadowBlur = parseInt(e.target.value, 10);
                shadowBlurValue.textContent = shadowBlur;
                updatePlayButtonShadow();
            });
            shadowColorInput.addEventListener('input', (e) => {
                const hexColor = e.target.value;
                const currentAlpha = parseRgba(shadowColor).a; 
                const rgb = hexToRgb(hexColor);
                if (rgb) {
                     shadowColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${currentAlpha})`; 
                     updatePlayButtonShadow();
                }
            });
             shadowColorInput.addEventListener('change', (e) => {
                 const colorValue = e.target.value;
                 if (colorValue.startsWith('#') && colorValue.length === 9) { 
                     shadowColor = hexToRgba(colorValue);
                 } else if (colorValue.startsWith('#')) { 
                      const rgb = hexToRgb(colorValue);
                      if (rgb) shadowColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 1)`; 
                 } else {
                      shadowColor = colorValue; 
                 }
                 updatePlayButtonShadow();
             });
        }

        function updatePlayButtonShadow() {
            playButtonContainer.style.filter = `drop-shadow(${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px ${shadowColor})`;
        }

        // --- Helper Functions for Color --- (New/Modified)
        function hexToRgb(hex) {
            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

         function hexToRgba(hex) { 
            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (!result) { 
                const rgb = hexToRgb(hex);
                return rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 1)` : 'rgba(0,0,0,1)';
            }
            const r = parseInt(result[1], 16);
            const g = parseInt(result[2], 16);
            const b = parseInt(result[3], 16);
            const a = (parseInt(result[4], 16) / 255).toFixed(2);
            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        function parseRgba(rgbaString) {
            const result = rgbaString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            return result ? {
                r: parseInt(result[1]),
                g: parseInt(result[2]),
                b: parseInt(result[3]),
                a: result[4] !== undefined ? parseFloat(result[4]) : 1
            } : { r: 0, g: 0, b: 0, a: 1 }; 
        }


        // --- Play Button Dragging ---
        function setupPlayButtonDragging() {
            playButtonContainer.addEventListener('mousedown', startButtonDrag);
            playButtonContainer.addEventListener('touchstart', startButtonDrag, { passive: false });

            document.addEventListener('mousemove', dragButton);
            document.addEventListener('touchmove', dragButton, { passive: false });

            document.addEventListener('mouseup', endButtonDrag);
            document.addEventListener('touchend', endButtonDrag);
             document.addEventListener('mouseleave', endButtonDrag); 
        }

        function startButtonDrag(e) {
             if (e.button !== 0 && e.type !== 'touchstart') return; 
             e.preventDefault();
             isDraggingButton = true;
             playButtonContainer.style.cursor = 'grabbing';

             const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
             const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

             const rect = playButtonContainer.getBoundingClientRect();
             const cropRect = cropArea.getBoundingClientRect();

             btnDragStartX = clientX - rect.left - (rect.width / 2);
             btnDragStartY = clientY - rect.top - (rect.height / 2);
        }

        function dragButton(e) {
            if (!isDraggingButton || displayTargetWidth === 0 || displayTargetHeight === 0) return;
            e.preventDefault();

            const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

            const cropRect = cropArea.getBoundingClientRect();

             let targetX = clientX - cropRect.left - btnDragStartX;
             let targetY = clientY - cropRect.top - btnDragStartY;

             targetX = clamp(targetX, 0, displayTargetWidth);
             targetY = clamp(targetY, 0, displayTargetHeight);

             currentPosition.x = (targetX / displayTargetWidth) * 100;
             currentPosition.y = (targetY / displayTargetHeight) * 100;

            updatePlayButtonPosition();

            positionXSlider.value = currentPosition.x;
            positionXValue.textContent = `${Math.round(currentPosition.x)}%`;
            positionYSlider.value = currentPosition.y;
            positionYValue.textContent = `${Math.round(currentPosition.y)}%`;
        }

        function endButtonDrag() {
            if (isDraggingButton) {
                isDraggingButton = false;
                playButtonContainer.style.cursor = 'grab';
            }
        }


        // --- Download Logic ---
        function handleDownload() {
            if (!currentImage) return;
            downloadButton.disabled = true; 
            downloadButton.textContent = "Processing...";

            try {
                let exportWidth = parseInt(canvasWidthInput.value);
                let exportHeight = parseInt(canvasHeightInput.value);

                if (!(exportWidth > 0 && exportHeight > 0)) {
                    if (aspectRatio >= 1) {
                         exportWidth = DEFAULT_EXPORT_WIDTH;
                         exportHeight = Math.round(exportWidth / aspectRatio);
                     } else {
                         exportHeight = DEFAULT_EXPORT_HEIGHT; 
                         exportWidth = Math.round(exportHeight * aspectRatio);
                     }
                }

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = exportWidth;
                tempCanvas.height = exportHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.imageSmoothingQuality = 'high';

                const exportScaleX = exportWidth / displayTargetWidth;
                const exportScaleY = exportHeight / displayTargetHeight;

                const drawX = exportWidth / 2 + offsetX * exportScaleX;
                const drawY = exportHeight / 2 + offsetY * exportScaleY;
                const drawScale = userZoom * exportScaleX; 
                const drawRotationRad = currentRotation * Math.PI / 180;

                tempCtx.save();
                tempCtx.translate(drawX, drawY);
                tempCtx.rotate(drawRotationRad);
                tempCtx.scale(drawScale, drawScale);
                tempCtx.drawImage(
                    currentImage,
                    -currentImage.naturalWidth / 2,
                    -currentImage.naturalHeight / 2,
                    currentImage.naturalWidth,
                    currentImage.naturalHeight
                );
                tempCtx.restore();

                if (parseRgba(currentOverlayColor).a > 0) {
                    tempCtx.fillStyle = currentOverlayColor;
                    tempCtx.fillRect(0, 0, exportWidth, exportHeight);
                 }

                const finalButtonSize = currentButtonSize * Math.min(exportScaleX, exportScaleY); 
                const finalButtonX = (exportWidth * currentPosition.x / 100) - (finalButtonSize / 2);
                const finalButtonY = (exportHeight * currentPosition.y / 100) - (finalButtonSize / 2);

                const rawSvgContent = PLAY_BUTTON_STYLES[currentButtonStyle] || PLAY_BUTTON_STYLES.classicRed;

                const svgString = `<svg width="${finalButtonSize}" height="${finalButtonSize}" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                                    <g opacity="${currentButtonOpacity}">
                                        ${rawSvgContent}
                                    </g>
                                </svg>`;

                const svgImage = new Image();
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                svgImage.onload = () => {
                    tempCtx.drawImage(svgImage, finalButtonX, finalButtonY, finalButtonSize, finalButtonSize);
                    URL.revokeObjectURL(url); 

                    tempCtx.shadowOffsetX = 0;
                    tempCtx.shadowOffsetY = 0;
                    tempCtx.shadowBlur = 0;
                    tempCtx.shadowColor = 'transparent';

                    const mimeType = 'image/png';
                    const extension = 'png';
                    const dataURL = tempCanvas.toDataURL(mimeType); 

                    const finalFilename = (filenameInput.value || currentFilename || 'thumbnail') + '_with_play.' + extension;

                    const link = document.createElement('a');
                    link.href = dataURL;
                    link.download = finalFilename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
                    downloadButton.disabled = false;
                    downloadButton.textContent = "Download Image";
                };

                svgImage.onerror = (err) => {
                    console.error("Error loading SVG for rendering:", err);
                    alert("Error applying play button overlay.");
                    URL.revokeObjectURL(url);
                    downloadButton.disabled = false;
                    downloadButton.textContent = "Download Image";
                };
                svgImage.src = url;

             } catch (error) {
                 console.error("Error during download process:", error);
                 alert("An error occurred while generating the image. Please check console for details.");
                 downloadButton.disabled = false;
                 downloadButton.textContent = "Download Image";
             }
        }

        // --- Run Initialization ---
        initialize();

    </script>
</body>
</html>
