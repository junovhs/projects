<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DirAnalyze 2.0 - AI Code Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #e8e8e8;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border: #d0d0d0;
            --accent: #4a90e2;
            --accent-hover: #357abd;
            --success: #5cb85c;
            --error: #d9534f;
            --warning: #f0ad4e;
        }

        body.dark {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #2d2d30;
            --text-primary: #d4d4d4;
            --text-secondary: #888888;
            --border: #3e3e3e;
            --accent: #0e639c;
            --accent-hover: #1177bb;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #loading-screen video {
            max-width: 300px;
            max-height: 300px;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            gap: 20px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 20px;
            font-weight: 600;
        }

        .logo svg {
            width: 32px;
            height: 32px;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 350px;
            min-width: 250px;
            max-width: 600px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .sidebar-resize {
            position: absolute;
            right: -3px;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 10;
        }

        .sidebar-resize:hover {
            background: var(--accent);
            opacity: 0.5;
        }

        /* Drop Zone */
        .drop-zone {
            margin: 20px;
            padding: 40px;
            border: 2px dashed var(--border);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .drop-zone:hover {
            border-color: var(--accent);
            background: var(--bg-tertiary);
        }

        .drop-zone.active {
            border-color: var(--accent);
            background: var(--accent);
            color: white;
        }

        /* Controls */
        .controls {
            padding: 15px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
        }

        .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        button {
            padding: 8px 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        button:hover {
            background: var(--accent-hover);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        button.secondary:hover {
            background: var(--bg-tertiary);
        }

        /* Filters */
        .filters {
            padding: 10px 15px;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border);
        }

        .filter-row {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
        }

        input[type="text"] {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
        }

        label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
            cursor: pointer;
        }

        /* File Tree */
        .file-tree {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .tree-item {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            cursor: pointer;
            user-select: none;
            border-radius: 3px;
            margin-bottom: 1px;
        }

        .tree-item:hover {
            background: var(--bg-tertiary);
        }

        .tree-item.selected {
            background: var(--accent);
            color: white;
        }

        .tree-indent {
            display: inline-block;
        }

        .tree-icon {
            margin-right: 6px;
            display: inline-flex;
        }

        .tree-checkbox {
            margin-right: 8px;
        }

        .tree-name {
            flex: 1;
        }

        .tree-size {
            margin-left: auto;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .tree-item.selected .tree-size {
            color: rgba(255,255,255,0.8);
        }

        /* Editor */
        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
        }

        .editor-toolbar {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            gap: 10px;
        }

        .main-view {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .committed-tree {
            height: 100%;
            overflow-y: auto;
            padding: 20px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
            font-size: 13px;
        }

        .editor-view {
            height: 100%;
            display: none;
            flex-direction: column;
        }

        .editor-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
        }

        .line-numbers {
            width: 60px;
            padding: 10px 10px 10px 0;
            text-align: right;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 20px;
            overflow: hidden;
            user-select: none;
            border-right: 1px solid var(--border);
        }

        .editor-textarea {
            flex: 1;
            padding: 10px 15px;
            font-family: inherit;
            font-size: 14px;
            line-height: 20px;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: none;
            outline: none;
            resize: none;
            white-space: pre;
            overflow: auto;
        }

        /* Status Bar */
        .status-bar {
            display: flex;
            align-items: center;
            padding: 5px 15px;
            background: var(--accent);
            color: white;
            font-size: 12px;
            gap: 20px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 25px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .modal-header {
            margin-bottom: 20px;
        }

        .modal-header h2 {
            margin-bottom: 10px;
        }

        .modal-header p {
            color: var(--text-secondary);
            font-size: 13px;
        }

        .modal-body {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .modal textarea {
            width: 100%;
            min-height: 400px;
            padding: 15px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 13px;
            resize: vertical;
        }

        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Notification */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            background: var(--accent);
            color: white;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            z-index: 1001;
            animation: slideIn 0.3s;
        }

        .notification.active {
            display: block;
        }

        .notification.success {
            background: var(--success);
        }

        .notification.error {
            background: var(--error);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Theme Toggle */
        .theme-toggle {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .switch {
            position: relative;
            width: 44px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--border);
            border-radius: 24px;
            transition: 0.3s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: 0.3s;
        }

        input:checked + .slider {
            background: var(--accent);
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <video autoplay loop muted>
            <source src="loading.webm" type="video/webm">
        </video>
    </div>

    <!-- Header -->
    <div class="header">
        <div class="logo">
            <img src="logo.png" alt="DirAnalyze" style="height: 32px;">
        </div>
        <div class="theme-toggle">
            <span>Light</span>
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
            <span>Dark</span>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-resize" id="sidebar-resize"></div>
            
            <!-- Drop Zone -->
            <div class="drop-zone" id="drop-zone">
                <div style="font-size: 24px;">üìÅ</div>
                <div style="margin-top: 10px;">DROP FOLDER</div>
                <div style="margin-top: 5px; color: var(--text-secondary); font-size: 12px;">- OR -</div>
                <button style="margin-top: 10px;">SELECT FOLDER</button>
            </div>

            <!-- Controls -->
            <div class="controls">
                <div class="control-group">
                    <button id="export-text-report">TEXT REPORT</button>
                    <button id="export-combined">EXPORT COMBINED TEXT</button>
                </div>
                <div class="control-group">
                    <button id="select-all" class="secondary">SELECT ALL</button>
                    <button id="deselect-all" class="secondary">DESELECT ALL</button>
                    <button id="commit" class="secondary">COMMIT</button>
                </div>
                <div class="control-group">
                    <button id="expand-all" class="secondary">EXPAND ALL</button>
                    <button id="collapse-all" class="secondary">COLLAPSE ALL</button>
                </div>
            </div>

            <!-- Filters -->
            <div class="filters">
                <div class="filter-row">
                    <input type="text" id="include-filter" placeholder="Include patterns (e.g., *.js, *.css)">
                </div>
                <div class="filter-row">
                    <input type="text" id="exclude-filter" placeholder="Exclude patterns (e.g., node_modules, .git)">
                </div>
                <div class="filter-row">
                    <label>
                        <input type="checkbox" id="show-hidden"> Show hidden files
                    </label>
                </div>
            </div>

            <!-- File Tree -->
            <div class="file-tree" id="file-tree">
                <div style="padding: 20px; text-align: center; color: var(--text-secondary);">
                    No folder loaded
                </div>
            </div>
        </div>

        <!-- Editor Container -->
        <div class="editor-container">
            <div class="editor-toolbar">
                <button id="copy-with-numbers">Copy with Line Numbers</button>
                <button id="apply-patch">Apply Patch</button>
                <button id="save-file" disabled>Save</button>
                <span style="margin-left: auto; color: var(--text-secondary); font-size: 13px;">
                    <span id="current-file">Committed Files View</span>
                </span>
            </div>
            
            <!-- Main View Area -->
            <div id="main-view" class="main-view">
                <!-- Staged Report (default view) -->
                <div id="committed-tree" class="committed-tree"></div>
                
                <!-- Editor (shown only when a file is clicked) -->
                <div id="editor-view" class="editor-view">
                    <div class="editor-content">
                        <div class="line-numbers" id="line-numbers"></div>
                        <textarea class="editor-textarea" id="editor" placeholder="Select a file to edit..."></textarea>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-item">
            <span id="status-files">0 files</span>
        </div>
        <div class="status-item">
            <span id="status-selected">0 selected</span>
        </div>
        <div class="status-item">
            <span id="status-size">0 KB</span>
        </div>
        <div class="status-item" style="margin-left: auto;">
            <span id="status-message">Ready</span>
        </div>
    </div>

    <!-- Patch Modal -->
    <div class="modal" id="patch-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Apply AI Patches</h2>
                <p>Paste patches in the format below. The AI should respond with FILE: and line ranges.</p>
                <p style="margin-top: 5px; font-family: monospace; background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
                    FILE: path/to/file.js<br>
                    45-47:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;new code here
                </p>
            </div>
            <div class="modal-body">
                <textarea id="patch-input" placeholder="PATCHES:

FILE: src/main.js
45-47:
    const updated = true;
    console.log('Updated');

FILE: src/utils.js
10-15:
    function helper() {
        return processData();
    }"></textarea>
            </div>
            <div class="modal-footer">
                <button class="secondary" id="cancel-patch">Cancel</button>
                <button id="confirm-patch">Apply Patches</button>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <!-- Hidden file input -->
    <input type="file" id="folder-input" webkitdirectory directory multiple style="display: none;">

    <script>
        // Application State
        const state = {
            files: new Map(), // path -> content
            fileTree: null,   // hierarchical structure
            selectedFiles: new Set(),
            committedFiles: new Set(), // Files that are committed
            expandedFolders: new Set(),
            currentFile: null,
            hasUnsavedChanges: false,
            viewMode: 'tree', // 'tree' or 'editor'
            filters: {
                include: '',
                exclude: '',
                showHidden: false
            },
            gitignorePatterns: [],
            placeholders: new Map(), // dirPath -> {count, size, name/label}
            lastLoadedFiles: [] // keep the original File objects so filters can reapply
        };

        // Default gitignore patterns
        const DEFAULT_GITIGNORE = `
node_modules/
.git/
.gitignore
dist/
build/
*.log
.DS_Store
.env
.env.local
.cache
.parcel-cache
.next
.nuxt
.vscode/
.idea/
*.swp
*.swo
*~
.npm
.yarn/
coverage/
.nyc_output
`;

        // Parse gitignore patterns
        function parseGitignore(content) {
            const lines = content.split('\n');
            const patterns = [];
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed && !trimmed.startsWith('#')) {
                    patterns.push(trimmed);
                }
            }
            return patterns;
        }

        // Check if file matches gitignore patterns (robust glob matcher)
        function matchesGitignore(path, patterns) {
            // normalize path separators
            const p = path.replace(/\\/g, '/');
            for (let raw of patterns) {
                if (!raw) continue;
                let pattern = raw.trim();
                if (!pattern || pattern.startsWith('#')) continue;   // comment
                if (pattern.startsWith('!')) continue;               // ignore negations for now

                // directory rule like "node_modules/"
                if (pattern.endsWith('/')) {
                    const dir = pattern.slice(0, -1);
                    if (p.split('/').includes(dir)) return true;
                    continue;
                }

                const rx = globToRegExp(pattern);
                if (rx.test(p)) return true;
            }
            return false;
        }

        // Convert .gitignore-like globs to a safe RegExp
        function globToRegExp(glob) {
            let g = glob.replace(/\\/g, '/');

            // escape regex specials but keep glob tokens * ? [ ]
            g = g.replace(/([.+^$(){}|\\])/g, '\\$1');

            // ** -> .*
            g = g.replace(/\*\*/g, '¬ß¬ßDS¬ß¬ß');

            // *  -> [^/]*  (no slash)
            g = g.replace(/\*/g, '[^/]*');

            // restore **
            g = g.replace(/¬ß¬ßDS¬ß¬ß/g, '.*');

            // ?  -> single non-slash
            g = g.replace(/\?/g, '[^/]');

            // allow match anywhere in the path
            return new RegExp('(^|/)' + g + '($|/)?');
        }


        // DOM Elements
        const elements = {
            loadingScreen: document.getElementById('loading-screen'),
            sidebar: document.getElementById('sidebar'),
            sidebarResize: document.getElementById('sidebar-resize'),
            dropZone: document.getElementById('drop-zone'),
            fileTree: document.getElementById('file-tree'),
            mainView: document.getElementById('main-view'),
            committedTree: document.getElementById('committed-tree'),
            editorView: document.getElementById('editor-view'),
            editor: document.getElementById('editor'),
            lineNumbers: document.getElementById('line-numbers'),
            currentFile: document.getElementById('current-file'),
            saveButton: document.getElementById('save-file'),
            notification: document.getElementById('notification'),
            patchModal: document.getElementById('patch-modal'),
            patchInput: document.getElementById('patch-input'),
            folderInput: document.getElementById('folder-input'),
            themeToggle: document.getElementById('theme-toggle'),
            statusFiles: document.getElementById('status-files'),
            statusSelected: document.getElementById('status-selected'),
            statusSize: document.getElementById('status-size'),
            statusMessage: document.getElementById('status-message'),
            includeFilter: document.getElementById('include-filter'),
            excludeFilter: document.getElementById('exclude-filter'),
            showHidden: document.getElementById('show-hidden')
        };

        // Initialize
        function init() {
            setupEventListeners();
            loadTheme();
            updateStatus();
            
            setTimeout(() => {
                elements.loadingScreen.classList.add('hidden');
            }, 1000);
            
            // Initialize gitignore patterns
            state.gitignorePatterns = parseGitignore(DEFAULT_GITIGNORE);
            elements.excludeFilter.value = 'node_modules,.git,dist,build,.DS_Store';
            updateCommittedTreeView(); // show initial "No files" or empty report
        }

        // Event Listeners
        function setupEventListeners() {
            // Theme
            elements.themeToggle.addEventListener('change', toggleTheme);

            // Sidebar resize
            setupSidebarResize();

            // File operations
            elements.dropZone.addEventListener('click', () => elements.folderInput.click());
            elements.dropZone.addEventListener('dragover', handleDragOver);
            elements.dropZone.addEventListener('dragenter', (e) => { e.preventDefault(); elements.dropZone.classList.add('active'); });
            elements.dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); elements.dropZone.classList.remove('active'); });
            elements.dropZone.addEventListener('drop', handleDrop);
            elements.folderInput.addEventListener('change', handleFolderSelect);

            // Prevent browser from navigating on window drop
            window.addEventListener('dragover', (e) => e.preventDefault());
            window.addEventListener('drop', (e) => e.preventDefault());

            // Buttons
            document.getElementById('export-text-report').addEventListener('click', exportTextReport);
            document.getElementById('export-combined').addEventListener('click', exportCombinedText);
            document.getElementById('select-all').addEventListener('click', () => selectAll(true));
            document.getElementById('deselect-all').addEventListener('click', () => selectAll(false));
            document.getElementById('commit').addEventListener('click', commitSelection);
            document.getElementById('expand-all').addEventListener('click', () => expandAll(true));
            document.getElementById('collapse-all').addEventListener('click', () => expandAll(false));
            document.getElementById('copy-with-numbers').addEventListener('click', copyWithLineNumbers);
            document.getElementById('apply-patch').addEventListener('click', () => showPatchModal());
            document.getElementById('save-file').addEventListener('click', saveCurrentFile);
            document.getElementById('cancel-patch').addEventListener('click', () => closePatchModal());
            document.getElementById('confirm-patch').addEventListener('click', applyPatches);

            // Filters
            elements.includeFilter.addEventListener('input', applyFilters);
            elements.excludeFilter.addEventListener('input', applyFilters);
            elements.showHidden.addEventListener('change', applyFilters);

            // Editor
            elements.editor.addEventListener('input', handleEditorChange);
            elements.editor.addEventListener('scroll', syncScroll);

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboard);
        }

        // Sidebar Resize
        function setupSidebarResize() {
            let isResizing = false;
            elements.sidebarResize.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.cursor = 'ew-resize';
                e.preventDefault();
            });
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const newWidth = e.clientX;
                if (newWidth > 250 && newWidth < 600) {
                    elements.sidebar.style.width = newWidth + 'px';
                }
            });
            document.addEventListener('mouseup', () => {
                isResizing = false;
                document.body.style.cursor = '';
            });
        }

        // Theme
        function toggleTheme() {
            document.body.classList.toggle('dark', elements.themeToggle.checked);
            localStorage.setItem('theme', elements.themeToggle.checked ? 'dark' : 'light');
        }

        function loadTheme() {
            const theme = localStorage.getItem('theme') || 'light';
            elements.themeToggle.checked = theme === 'dark';
            document.body.classList.toggle('dark', theme === 'dark');
        }

        // Drag & Drop
        function handleDragOver(e) {
            e.preventDefault();
            if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
            elements.dropZone.classList.add('active');
        }

        async function handleDrop(e) {
            e.preventDefault();
            elements.dropZone.classList.remove('active');

            const { items, files } = e.dataTransfer || {};

            if (items && items.length) {
                const collected = await (async function collect(items) {
                    const out = [];
                    async function traverseEntry(entry, prefix = '') {
                        return new Promise((resolve) => {
                            if (entry.isFile) {
                                entry.file((file) => {
                                    Object.defineProperty(file, 'webkitRelativePath', {
                                        value: (prefix + entry.name).replace(/^\//, ''),
                                        configurable: true
                                    });
                                    out.push(file);
                                    resolve();
                                }, () => resolve());
                            } else if (entry.isDirectory) {
                                const reader = entry.createReader();
                                const entries = [];
                                const readBatch = () => {
                                    reader.readEntries((batch) => {
                                        if (!batch.length) {
                                            (async () => {
                                                for (const child of entries) {
                                                    await traverseEntry(child, `${prefix}${entry.name}/`);
                                                }
                                                resolve();
                                            })();
                                            return;
                                        }
                                        entries.push(...batch);
                                        readBatch();
                                    }, () => resolve());
                                };
                                readBatch();
                            } else {
                                resolve();
                            }
                        });
                    }
                    const tasks = [];
                    for (let i = 0; i < items.length; i++) {
                        const it = items[i];
                        if (it && it.kind === 'file' && it.webkitGetAsEntry) {
                            const entry = it.webkitGetAsEntry();
                            if (entry) tasks.push(traverseEntry(entry, ''));
                        }
                    }
                    await Promise.all(tasks);
                    return out;
                })(items);

                if (collected && collected.length) {
                    await loadFiles(collected);
                    return;
                }
            }

            if (files && files.length) {
                await loadFiles(Array.from(files));
            }
        }

        // Folder input chooser
        async function handleFolderSelect(e) {
            const files = Array.from(e.target.files);
            await loadFiles(files);
        }

        // File reading and loading
        async function loadFiles(fileList) {
            state.files.clear();
            state.selectedFiles.clear();
            state.committedFiles.clear();
            state.placeholders = new Map();
            state.lastLoadedFiles = Array.from(fileList);

            showNotification(`Loading ${fileList.length} files...`);

            // Discover .gitignore (anywhere)
            let gitignoreContent = '';
            for (const file of fileList) {
                const p = file.webkitRelativePath || file.name;
                if (p.endsWith('.gitignore') || p === '.gitignore') {
                    gitignoreContent = await readFileContent(file);
                    break;
                }
            }

            // Parse gitignore patterns
            state.gitignorePatterns = parseGitignore(
                gitignoreContent ? (DEFAULT_GITIGNORE + '\n' + gitignoreContent) : DEFAULT_GITIGNORE
            );

            // Known build/cache dirs to show placeholders for
            const KNOWN_BUILD_DIRS = new Set([
                'node_modules','.next','.nuxt','dist','build','.parcel-cache','.cache','coverage',
                '.git','.vscode','.idea','out','.svelte-kit','.angular','.vercel','.turbo','target','bin','obj'
            ]);

            // Classify & record placeholders for ignored directories, load included files
            for (const file of fileList) {
                const path = file.webkitRelativePath || file.name;

                // Determine ignore first so we can record placeholder stats
                const isIgnored = matchesGitignore(path, state.gitignorePatterns);

                if (isIgnored) {
                    // Walk path segments to find a known build/cache dir
                    const parts = path.split('/');
                    const stack = [];
                    for (let i = 0; i < parts.length - 1; i++) {
                        const seg = parts[i];
                        stack.push(seg);
                        if (KNOWN_BUILD_DIRS.has(seg)) {
                            const dirPath = stack.join('/');
                            const rec = state.placeholders.get(dirPath) || { count: 0, size: 0, name: seg };
                            rec.count += 1;
                            rec.size += (typeof file.size === 'number' ? file.size : 0);
                            state.placeholders.set(dirPath, rec);
                            break;
                        }
                    }
                    continue; // skip loading ignored files
                }

                // Apply include/exclude + hidden filters
                if (!shouldIncludeFile(path)) continue;

                const content = await readFileContent(file);
                state.files.set(path, content);

                // Auto-commit included files
                state.selectedFiles.add(path);
                state.committedFiles.add(path);
            }

            buildFileTree();
            updateCommittedTreeView();
            updateStatus();
            showNotification(`Loaded ${state.files.size} files`, 'success');
        }

        function readFileContent(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = () => resolve('');
                reader.readAsText(file);
            });
        }

        function shouldIncludeFile(path) {
            // Respect .gitignore & built-in defaults first
            if (matchesGitignore(path, state.gitignorePatterns)) {
                return false;
            }

            // Exclude filter (comma-separated substrings)
            const excludePatterns = state.filters.exclude.split(',').map(p => p.trim()).filter(Boolean);
            for (const pattern of excludePatterns) {
                if (pattern && path.includes(pattern)) return false;
            }

            // Hidden files
            if (!state.filters.showHidden && path.split('/').some(part => part.startsWith('.'))) {
                return false;
            }

            // Include filter (wildcards supported)
            const includePatterns = state.filters.include.split(',').map(p => p.trim()).filter(Boolean);
            if (includePatterns.length > 0) {
                const matches = includePatterns.some(pattern => {
                    const safe = pattern.split('*').map(s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('.*');
                    const regex = new RegExp('^' + safe + '$');
                    return regex.test(path);
                });
                if (!matches) return false;
            }

            return true;
        }

        // Build File Tree for sidebar (actual loaded files only)
        function buildFileTree() {
            const tree = {};
            for (const [path] of state.files) {
                const parts = path.split('/');
                let current = tree;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (i === parts.length - 1) {
                        current[part] = { type: 'file', path };
                    } else {
                        if (!current[part]) {
                            current[part] = { type: 'folder', children: {} };
                        }
                        current = current[part].children;
                    }
                }
            }
            state.fileTree = tree;
            renderFileTree();
        }

        // Get file icon based on extension
        function getFileIcon(filename) {
            const ext = filename.split('.').pop()?.toLowerCase();
            const icons = {
                'js': 'üìú','jsx': '‚öõÔ∏è','ts': 'üìò','tsx': '‚öõÔ∏è','json': 'üìã','html': 'üåê','css': 'üé®','scss': 'üé®','sass': 'üé®','less': 'üé®',
                'yml': '‚öôÔ∏è','yaml': '‚öôÔ∏è','toml': '‚öôÔ∏è','xml': 'üì∞','env': 'üîê','gitignore': 'üö´','lock': 'üîí',
                'md': 'üìù','txt': 'üìÑ','pdf': 'üìï','doc': 'üìò','docx': 'üìò',
                'sh': 'üêö','bat': 'ü¶á','py': 'üêç','rb': 'üíé','go': 'üêπ','rs': 'ü¶Ä','java': '‚òï','php': 'üêò',
                'sql': 'üóÉÔ∏è','sqlite': 'üóÉÔ∏è','sqlite3': 'üóÉÔ∏è','csv': 'üìä',
                'png': 'üñºÔ∏è','jpg': 'üñºÔ∏è','jpeg': 'üñºÔ∏è','gif': 'üñºÔ∏è','svg': 'üé®','ico': 'üé≠','webm': 'üé¨','mp4': 'üé¨','mp3': 'üéµ',
                'exe': '‚ö°','zip': 'üì¶','tar': 'üì¶','gz': 'üì¶','default': 'üìÑ'
            };
            if (filename === '.gitignore') return 'üö´';
            if (filename === 'package.json') return 'üì¶';
            if (filename === 'README.md') return 'üìñ';
            if (filename === 'LICENSE') return '‚öñÔ∏è';
            if (filename === 'Dockerfile') return 'üê≥';
            return icons[ext] || icons.default;
        }

        // Render sidebar file tree (only loaded files)
        function renderFileTree() {
            elements.fileTree.innerHTML = '';
            const node = state.fileTree || {};
            if (Object.keys(node).length === 0) {
                elements.fileTree.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">No files match filters</div>';
                return;
            }
            renderTreeNode(node, elements.fileTree, '', 0);
        }

        function renderTreeNode(node, container, path, depth) {
            const entries = Object.entries(node).sort(([a, aVal], [b, bVal]) => {
                if (aVal.type !== bVal.type) {
                    return aVal.type === 'folder' ? -1 : 1;
                }
                return a.localeCompare(b);
            });
            
            for (const [name, value] of entries) {
                const fullPath = path ? `${path}/${name}` : name;
                const item = document.createElement('div');
                item.className = 'tree-item';
                
                // Indentation
                const indent = document.createElement('span');
                indent.className = 'tree-indent';
                indent.style.width = (depth * 20) + 'px';
                item.appendChild(indent);
                
                // Checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'tree-checkbox';
                checkbox.checked = state.selectedFiles.has(value.path || fullPath);
                checkbox.onclick = (e) => {
                    e.stopPropagation();
                    toggleSelection(value.path || fullPath);
                };
                item.appendChild(checkbox);
                
                // Icon
                const icon = document.createElement('span');
                icon.className = 'tree-icon';
                icon.textContent = (value.type === 'folder') ? (state.expandedFolders.has(fullPath) ? 'üìÇ' : 'üìÅ') : getFileIcon(name);
                item.appendChild(icon);
                
                // Name
                const nameSpan = document.createElement('span');
                nameSpan.className = 'tree-name';
                nameSpan.textContent = name;
                item.appendChild(nameSpan);
                
                // Size (for files)
                if (value.type === 'file') {
                    const size = document.createElement('span');
                    size.className = 'tree-size';
                    const bytes = state.files.get(value.path).length;
                    size.textContent = formatSize(bytes);
                    item.appendChild(size);
                    item.onclick = () => openFile(value.path);
                } else {
                    item.onclick = () => toggleFolder(fullPath);
                    if (state.expandedFolders.has(fullPath)) {
                        icon.textContent = 'üìÇ';
                    }
                }
                
                container.appendChild(item);
                
                if (value.type === 'folder' && state.expandedFolders.has(fullPath)) {
                    renderTreeNode(value.children, container, fullPath, depth + 1);
                }
            }
        }

        // Staged Report View
        function updateCommittedTreeView() {
            elements.committedTree.innerHTML = '';
            if (state.files.size === 0 && state.placeholders.size === 0) {
                elements.committedTree.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 40px;">No files loaded</div>';
                return;
            }
            const pre = document.createElement('pre');
            pre.style.whiteSpace = 'pre-wrap';
            pre.style.fontFamily = "'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace";
            pre.textContent = getReportText(true); // committed/staged view
            elements.committedTree.appendChild(pre);
        }

        // Toggle between report and editor view
        function showTreeView() {
            state.viewMode = 'tree';
            elements.editorView.style.display = 'none';
            elements.committedTree.style.display = 'block';
            elements.currentFile.textContent = 'Committed Files View';
            elements.saveButton.disabled = true;
        }

        function showEditorView() {
            state.viewMode = 'editor';
            elements.committedTree.style.display = 'none';
            elements.editorView.style.display = 'flex';
        }

        // Selection & Commit
        function toggleSelection(path) {
            if (state.selectedFiles.has(path)) {
                state.selectedFiles.delete(path);
                state.committedFiles.delete(path);
            } else {
                state.selectedFiles.add(path);
                state.committedFiles.add(path);
            }
            renderFileTree();
            updateCommittedTreeView();
            updateStatus();
        }

        function commitSelection() {
            state.committedFiles.clear();
            for (const file of state.selectedFiles) {
                state.committedFiles.add(file);
            }
            updateCommittedTreeView();
            showNotification(`Committed ${state.committedFiles.size} files`, 'success');
            showTreeView();
        }

        // Folder expand/collapse
        function toggleFolder(path) {
            if (state.expandedFolders.has(path)) {
                state.expandedFolders.delete(path);
            } else {
                state.expandedFolders.add(path);
            }
            renderFileTree();
        }

        function expandAll(expand) {
            if (expand) {
                function findFolders(node, path) {
                    for (const [name, value] of Object.entries(node)) {
                        const fullPath = path ? `${path}/${name}` : name;
                        if (value.type === 'folder') {
                            state.expandedFolders.add(fullPath);
                            findFolders(value.children, fullPath);
                        }
                    }
                }
                findFolders(state.fileTree || {}, '');
            } else {
                state.expandedFolders.clear();
            }
            renderFileTree();
        }

        // Editor Operations (single, correct version)
        function openFile(path) {
            if (state.hasUnsavedChanges && state.currentFile) {
                if (!confirm('You have unsaved changes. Continue?')) {
                    return;
                }
            }
            state.currentFile = path;
            elements.editor.value = state.files.get(path) || '';
            elements.currentFile.textContent = path;
            state.hasUnsavedChanges = false;
            elements.saveButton.disabled = false;
            updateLineNumbers();
            showEditorView();
        }

        function handleEditorChange() {
            updateLineNumbers();
            if (!state.hasUnsavedChanges) {
                state.hasUnsavedChanges = true;
                elements.saveButton.disabled = false;
                if (state.currentFile) {
                    elements.currentFile.textContent = state.currentFile + ' (modified)';
                }
            }
        }

        function saveCurrentFile() {
            if (!state.currentFile) return;
            state.files.set(state.currentFile, elements.editor.value);
            state.hasUnsavedChanges = false;
            elements.saveButton.disabled = true;
            elements.currentFile.textContent = state.currentFile;
            showNotification('File saved', 'success');
        }

        function updateLineNumbers() {
            const lines = elements.editor.value.split('\n').length;
            const numbers = [];
            for (let i = 1; i <= lines; i++) numbers.push(i);
            elements.lineNumbers.innerHTML = numbers.join('<br>');
        }

        function syncScroll() {
            elements.lineNumbers.scrollTop = elements.editor.scrollTop;
        }

        // Copy with line numbers
        function copyWithLineNumbers() {
            if (!state.currentFile) {
                showNotification('No file open', 'error');
                return;
            }
            const content = elements.editor.value;
            let selection, startLine;
            if (elements.editor.selectionStart !== elements.editor.selectionEnd) {
                selection = content.substring(elements.editor.selectionStart, elements.editor.selectionEnd);
                const beforeSelection = content.substring(0, elements.editor.selectionStart);
                startLine = beforeSelection.split('\n').length;
            } else {
                selection = content;
                startLine = 1;
            }
            const lines = selection.split('\n');
            const numbered = [];
            numbered.push(`FILE: ${state.currentFile}`);
            numbered.push(`LINES: ${startLine}-${startLine + lines.length - 1}`);
            numbered.push('='.repeat(40));
            lines.forEach((line, i) => numbered.push(`${startLine + i}: ${line}`));
            const output = numbered.join('\n');
            navigator.clipboard.writeText(output);
            showNotification('Copied with line numbers!', 'success');
        }

        function selectAll(select) {
            if (select) {
                for (const [path] of state.files) {
                    if (!matchesGitignore(path, state.gitignorePatterns)) {
                        state.selectedFiles.add(path);
                    }
                }
            } else {
                state.selectedFiles.clear();
            }
            renderFileTree();
            updateCommittedTreeView();
            updateStatus();
        }

        // Export: Text report mirrors the staged view and includes placeholders
        function exportTextReport() {
            const reportText = getReportText(true);
            navigator.clipboard.writeText(reportText);
            showNotification('Text report copied to clipboard!', 'success');
        }

        // Export: Combined text (structure + contents for staged files) with placeholders
        function exportCombinedText() {
            const selected = state.committedFiles.size > 0 
                ? Array.from(state.committedFiles) 
                : Array.from(state.files.keys());

            if (selected.length === 0) {
                showNotification('No files committed for export', 'error');
                return;
            }

            const output = [];
            output.push('//--- COMPREHENSIVE TEXT REPORT ---//');
            output.push(`// Timestamp: ${new Date().toISOString()}`);
            output.push(`// Files: ${selected.length}`);
            output.push('//');
            output.push('//--- DIRECTORY STRUCTURE ---');
            output.push(generateDetailedTreeStructure(true)); // staged + placeholders
            output.push('');
            output.push('//--- FILE CONTENTS WITH LINE NUMBERS ---');
            output.push('');

            for (const path of selected.sort()) {
                const content = state.files.get(path) || '';
                output.push(`=== FILE: ${path} ===`);
                const lines = content.split('\n');
                lines.forEach((line, i) => output.push(`${i + 1}: ${line}`));
                output.push('');
            }

            output.push('//--- END OF REPORT ---//');

            navigator.clipboard.writeText(output.join('\n'));
            showNotification(`Exported ${selected.length} files to clipboard!`, 'success');
        }

        // Build merged structure (files + placeholders) and render detailed tree
        function generateDetailedTreeStructure(committedOnly = false) {
            const structure = buildTreeStructureWithPlaceholders(committedOnly);
            const lines = [];

            function nodeFolderSize(n) {
                if (n.type === 'file') {
                    const bytes = state.files.get(n.path)?.length || 0;
                    return bytes;
                }
                if (n.type === 'placeholder') {
                    return n.size || 0;
                }
                let s = 0;
                for (const child of Object.values(n.children || {})) s += nodeFolderSize(child);
                return s;
            }

            function countFiles(n) {
                if (n.type === 'file') return 1;
                if (n.type === 'placeholder') return 0;
                let c = 0;
                for (const child of Object.values(n.children || {})) c += countFiles(child);
                return c;
            }

            function countSubfoldersInNode(n) {
                if (n.type === 'file') return 0;
                if (n.type === 'placeholder') return 1; // treat placeholder as a subdir
                let c = 0;
                for (const child of Object.values(n.children || {})) {
                    if (child.type !== 'file') c += 1;
                    c += countSubfoldersInNode(child);
                }
                return c;
            }

            function render(node, name, prefix = '', isLast = true) {
                const connector = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
                const extension = isLast ? '    ' : '‚îÇ   ';

                if (node.type === 'file') {
                    const size = formatSize(state.files.get(node.path)?.length || 0);
                    const ext = name.includes('.') ? name.split('.').pop() : '(no ext)';
                    lines.push(`${prefix}${connector}${name} (Size: ${size}, Ext: .${ext})`);
                    return;
                }

                if (node.type === 'placeholder') {
                    const lbl = node.label || 'Standard build/cache present';
                    const skipped = formatSize(node.size || 0);
                    lines.push(`${prefix}${connector}${name}/ [placeholder: ${lbl}; ${node.count || 0} files, ${skipped} skipped]`);
                    return;
                }

                const fileCount = countFiles(node);
                const folderCount = countSubfoldersInNode(node);
                const size = nodeFolderSize(node);
                lines.push(`${prefix}${connector}${name}/ (Files: ${fileCount}, Subdirs: ${folderCount}, Size: ${formatSize(size)})`);

                const entries = Object.entries(node.children || {}).sort(([a, av], [b, bv]) => {
                    const order = (t) => t === 'folder' ? 0 : (t === 'placeholder' ? 1 : 2);
                    const oa = order(av.type), ob = order(bv.type);
                    if (oa !== ob) return oa - ob;
                    return a.localeCompare(b);
                });

                entries.forEach(([childName, childNode], index) => {
                    render(childNode, childName, prefix + extension, index === entries.length - 1);
                });
            }

            const rootEntries = Object.entries(structure);
            rootEntries.forEach(([name, node], index) => {
                render(node, name, '', index === rootEntries.length - 1);
            });

            return lines.join('\n');
        }

        function buildTreeStructure(committedOnly = false) {
            const tree = {};
            const filesToProcess = committedOnly ? state.committedFiles : new Set(state.files.keys());

            for (const path of filesToProcess) {
                const parts = path.split('/');
                let current = tree;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (i === parts.length - 1) {
                        current[part] = { type: 'file', path };
                    } else {
                        if (!current[part]) current[part] = { type: 'folder', children: {} };
                        current = current[part].children;
                    }
                }
            }
            return tree;
        }

        function buildTreeStructureWithPlaceholders(committedOnly = false) {
            const tree = buildTreeStructure(committedOnly);

            for (const [dirPath, meta] of state.placeholders) {
                const parts = dirPath.split('/');
                let current = tree;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (i === parts.length - 1) {
                        if (!current[part]) {
                            current[part] = {
                                type: 'placeholder',
                                label: getPlaceholderLabel(part),
                                count: meta.count || 0,
                                size: meta.size || 0
                            };
                        }
                    } else {
                        if (!current[part]) current[part] = { type: 'folder', children: {} };
                        current = current[part].children;
                    }
                }
            }

            return tree;
        }

        // Legacy simple structure (kept for compatibility, currently unused in outputs)
        function generateTreeStructure(paths) {
            const tree = [];
            const structure = {};
            for (const path of paths) {
                const parts = path.split('/');
                let current = structure;
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (i === parts.length - 1) {
                        current[part] = 'file';
                    } else {
                        if (!current[part]) current[part] = {};
                        current = current[part];
                    }
                }
            }
            function render(node, prefix = '') {
                const entries = Object.entries(node);
                entries.forEach(([name, value], index) => {
                    const isLastEntry = index === entries.length - 1;
                    const connector = isLastEntry ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
                    const extension = isLastEntry ? '    ' : '‚îÇ   ';
                    if (value === 'file') {
                        tree.push(prefix + connector + 'üìÑ ' + name);
                    } else {
                        tree.push(prefix + connector + 'üìÅ ' + name);
                        render(value, prefix + extension);
                    }
                });
            }
            render(structure);
            return tree.join('\n');
        }

        // Patch Operations
        function showPatchModal() {
            elements.patchModal.classList.add('active');
            elements.patchInput.focus();
        }

        function closePatchModal() {
            elements.patchModal.classList.remove('active');
            elements.patchInput.value = '';
        }

        function applyPatches() {
            const patchText = elements.patchInput.value.trim();
            if (!patchText) {
                showNotification('No patches to apply', 'error');
                return;
            }
            try {
                const patches = parsePatchText(patchText);
                let appliedCount = 0;
                let failedCount = 0;
                for (const patch of patches) {
                    if (applyPatch(patch)) appliedCount++; else failedCount++;
                }
                if (appliedCount > 0) {
                    if (state.currentFile && patches.some(p => p.file === state.currentFile)) {
                        elements.editor.value = state.files.get(state.currentFile);
                        updateLineNumbers();
                        state.hasUnsavedChanges = false;
                        elements.saveButton.disabled = true;
                        elements.currentFile.textContent = state.currentFile;
                    }
                    const message = failedCount > 0 
                        ? `Applied ${appliedCount} patches (${failedCount} failed)`
                        : `Applied ${appliedCount} patches successfully!`;
                    showNotification(message, failedCount > 0 ? 'warning' : 'success');
                } else {
                    showNotification('No patches could be applied', 'error');
                }
                closePatchModal();
            } catch (error) {
                showNotification(`Error: ${error.message}`, 'error');
            }
        }

        function parsePatchText(text) {
            const patches = [];
            const lines = text.split('\n');
            let i = 0;
            while (i < lines.length) {
                if (lines[i].startsWith('FILE:')) {
                    const filename = lines[i].substring(5).trim();
                    i++;
                    while (i < lines.length && !lines[i].match(/^\\d+-\\d+:/)) i++;
                    if (i < lines.length) {
                        const rangeMatch = lines[i].match(/^(\\d+)-(\\d+):/);
                        if (rangeMatch) {
                            const startLine = parseInt(rangeMatch[1]);
                            const endLine = parseInt(rangeMatch[2]);
                            i++;
                            const replacementLines = [];
                            while (i < lines.length && !lines[i].startsWith('FILE:') && !lines[i].match(/^\\d+-\\d+:/)) {
                                let line = lines[i];
                                line = line.replace(/^\\s*\\d+:\\s?/, '');
                                replacementLines.push(line);
                                i++;
                            }
                            patches.push({ file: filename, startLine, endLine, replacement: replacementLines.join('\n') });
                        }
                    }
                } else {
                    i++;
                }
            }
            return patches;
        }

        function applyPatch(patch) {
            if (!state.files.has(patch.file)) {
                console.warn(`File not found: ${patch.file}`);
                return false;
            }
            const content = state.files.get(patch.file);
            const lines = content.split('\n');
            if (patch.startLine < 1 || patch.endLine > lines.length) {
                console.warn(`Invalid line range for ${patch.file}: ${patch.startLine}-${patch.endLine}`);
                return false;
            }
            const newLines = [
                ...lines.slice(0, patch.startLine - 1),
                ...patch.replacement.split('\n'),
                ...lines.slice(patch.endLine)
            ];
            state.files.set(patch.file, newLines.join('\n'));
            return true;
        }

        // Filters (reapply by reloading from lastLoadedFiles if available)
        function applyFilters() {
            state.filters.include = elements.includeFilter.value;
            state.filters.exclude = elements.excludeFilter.value;
            state.filters.showHidden = elements.showHidden.checked;

            if (state.lastLoadedFiles.length > 0) {
                loadFiles(state.lastLoadedFiles);
            } else {
                // No source to reload from; just rebuild views with existing files
                buildFileTree();
                updateCommittedTreeView();
                updateStatus();
            }
        }

        // Status
        function updateStatus() {
            elements.statusFiles.textContent = `${state.files.size} files`;
            elements.statusSelected.textContent = `${state.selectedFiles.size} selected`;
            
            let totalSize = 0;
            const filesToCount = state.committedFiles.size > 0 
                ? state.committedFiles 
                : state.files.keys();
            for (const path of filesToCount) {
                const content = state.files.get(path);
                if (content) totalSize += content.length;
            }
            elements.statusSize.textContent = formatSize(totalSize);

            if (state.committedFiles.size > 0) {
                elements.statusMessage.textContent = `${state.committedFiles.size} files committed`;
            }
        }

        function showNotification(message, type = 'info') {
            elements.notification.textContent = message;
            elements.notification.className = `notification active ${type}`;
            elements.statusMessage.textContent = message;
            setTimeout(() => {
                elements.notification.classList.remove('active');
                elements.statusMessage.textContent = 'Ready';
            }, 3000);
        }

        // Placeholder helpers
        function getPlaceholderLabel(folderName) {
            const map = {
                'node_modules': 'Node modules installed',
                '.next': 'Next.js build output',
                'out': 'Next.js static export',
                'dist': 'Compiled build output',
                'build': 'Compiled build output',
                '.parcel-cache': 'Parcel cache',
                '.cache': 'Tool cache',
                '.nuxt': 'Nuxt build',
                '.svelte-kit': 'SvelteKit build',
                '.angular': 'Angular build',
                '.vercel': 'Vercel build cache',
                '.turbo': 'Turborepo cache',
                'coverage': 'Coverage reports',
                '.git': 'Git internals',
                '.vscode': 'VS Code settings',
                '.idea': 'JetBrains settings',
                'target': 'Target build output',
                'bin': 'Binary output',
                'obj': 'Build objects'
            };
            return map[folderName] || 'Standard build/cache present';
        }

        // Utilities
        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        function getReportText(committedOnly) {
            const lines = [];
            lines.push('//--- DIRANALYSE MATRIX REPORT (v2.1) ---//');
            lines.push(`// Timestamp: ${new Date().toISOString()}`);
            lines.push(`// Root Path: DirAnalyze2`);
            lines.push(`// Scope: ${committedOnly ? 'Committed (staged) files + placeholders' : 'Full scanned directory'}`);
            lines.push('// Note: File sizes reflect original scanned values.');
            lines.push('//');
            lines.push('//--- DIRECTORY STRUCTURE ---');
            lines.push(generateDetailedTreeStructure(committedOnly));
            lines.push('//');
            lines.push('//--- SUMMARY (Current View) ---');

            const fileSet = committedOnly ? state.committedFiles : new Set(state.files.keys());
            const fileCount = committedOnly ? state.committedFiles.size : state.files.size;

            const structure = buildTreeStructureWithPlaceholders(committedOnly);
            function countFoldersInTree(node) {
                if (node.type === 'file') return 0;
                let c = 0;
                if (node.type !== 'file') c += 1;
                for (const child of Object.values(node.children || {})) c += countFoldersInTree(child);
                return c;
            }
            let folderCount = 0;
            for (const node of Object.values(structure)) folderCount += countFoldersInTree(node);

            let totalSize = 0;
            for (const path of fileSet) {
                const content = state.files.get(path);
                if (content) totalSize += content.length;
            }

            lines.push(`Total Files in View    : ${fileCount}`);
            lines.push(`Total Folders in View  : ${folderCount}`);
            lines.push(`Total Size (Original)  : ${formatSize(totalSize)}`);
            lines.push('//');
            lines.push('//--- END OF REPORT ---//');

            return lines.join('\n');
        }

        // Keyboard Shortcuts
        function handleKeyboard(e) {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 's') {
                    e.preventDefault();
                    saveCurrentFile();
                } else if (e.shiftKey && e.key === 'C') {
                    e.preventDefault();
                    copyWithLineNumbers();
                } else if (e.shiftKey && e.key === 'V') {
                    e.preventDefault();
                    showPatchModal();
                } else if (e.key === 'a' && !e.target.matches('input, textarea')) {
                    e.preventDefault();
                    selectAll(true);
                }
            }
        }

        // Initialize the application
        init();
    </script>
</body>
</html>
