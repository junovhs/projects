<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dream Series Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            line-height: 1.6;
            user-select: none;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3rem;
            border-bottom: 1px solid #333;
            padding-bottom: 2rem;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 300;
            color: #fff;
            letter-spacing: -0.5px;
        }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .upload-area {
            border: 2px dashed #444;
            border-radius: 12px;
            padding: 3rem;
            text-align: center;
            margin-bottom: 3rem;
            transition: all 0.3s ease;
            cursor: pointer;
            background: #111;
        }

        .upload-area:hover, .upload-area.dragover {
            border-color: #666;
            background: #1a1a1a;
            transform: scale(1.02);
        }

        .upload-area svg {
            width: 48px;
            height: 48px;
            opacity: 0.6;
            margin-bottom: 1rem;
            stroke: #666;
        }

        .browse-text {
            color: #666;
            text-decoration: underline;
        }

        .series-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .series-title {
            font-size: 1.8rem;
            font-weight: 600;
            color: #fff;
        }

        .series-actions {
            display: flex;
            gap: 1rem;
        }

        .series-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .post-container {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 1.5rem;
            position: relative;
            transition: all 0.3s ease;
        }

        .post-container:hover {
            border-color: #555;
            background: #1f1f1f;
        }

        .post-container.drag-over-post {
            border-color: #888;
            background: #252525;
            transform: scale(1.02);
        }

        .post-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #333;
            gap: 1rem;
        }

        .post-info {
            flex: 1;
        }

        .post-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #fff;
            background: transparent;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            width: 100%;
            margin-bottom: 0.5rem;
            resize: none;
            min-height: 1.5rem;
        }

        .post-title:focus {
            outline: 1px solid #666;
            background: #222;
        }

        .post-date {
            color: #888;
            background: transparent;
            border: none;
            font-size: 0.85rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            width: 100%;
        }

        .post-date:focus {
            outline: 1px solid #666;
            background: #222;
            color: #ccc;
        }

        .post-actions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .post-count {
            color: #888;
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .delete-post {
            background: #331a1a;
            border: 1px solid #554444;
            color: #ffaaaa;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            cursor: pointer;
        }

        .delete-post:hover {
            background: #442222;
        }

        .image-slots {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 0.5rem;
            min-height: 90px;
        }

        .image-slot {
            aspect-ratio: 1;
            border: 2px dashed #444;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #0f0f0f;
        }

        .image-slot:hover {
            border-color: #666;
            background: #1a1a1a;
        }

        .image-slot.occupied {
            border-style: solid;
            border-color: #555;
            padding: 0;
            background: transparent;
        }

        .image-slot.occupied:hover {
            border-color: #777;
        }

        .image-slot.occupied img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
            cursor: pointer;
        }

        .image-slot.drag-over {
            border-color: #aaa;
            background: #333;
            transform: scale(1.05);
        }

        .image-slot .add-icon {
            color: #666;
            font-size: 1.5rem;
            transition: all 0.3s ease;
        }

        .image-slot:hover .add-icon {
            color: #888;
            transform: scale(1.2);
        }

        .image-slot .remove-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .image-slot.occupied:hover .remove-btn {
            display: flex;
        }

        .image-item {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            cursor: grab;
            user-select: none;
            background: #1a1a1a;
            border: 1px solid #333;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .image-item:hover {
            transform: translateY(-4px);
            border-color: #555;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .image-item.dragging {
            opacity: 0.8;
            transform: scale(0.95) rotate(3deg);
            z-index: 1000;
            cursor: grabbing;
            box-shadow: 0 15px 35px rgba(0,0,0,0.5);
        }

        .image-item.drag-disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .image-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            pointer-events: none;
        }

        .image-info {
            padding: 1rem;
        }

        .image-name {
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: #fff;
        }

        .image-prompt {
            color: #888;
            font-size: 0.8rem;
            font-style: italic;
            margin-bottom: 0.5rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-height: 1.3;
        }

        .image-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .tag {
            background: #333;
            color: #ccc;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
        }

        .image-actions {
            display: flex;
            gap: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid #333;
        }

        .image-actions button {
            flex: 1;
            padding: 0.4rem;
            font-size: 0.8rem;
            border-radius: 4px;
        }

        .unassigned-section {
            margin-top: 4rem;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 2rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #333;
        }

        .unassigned-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(4px);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            position: relative;
            margin: 2% auto;
            padding: 2rem;
            width: 95%;
            max-width: 900px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            color: #e0e0e0;
            animation: slideIn 0.3s ease;
            max-height: 95vh;
            overflow-y: auto;
        }

        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateY(-50px) scale(0.95);
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1);
            }
        }

        .close {
            position: absolute;
            right: 1rem;
            top: 1rem;
            font-size: 2rem;
            cursor: pointer;
            color: #888;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .close:hover {
            color: #fff;
            background: #333;
        }

        #modalImage {
            width: 100%;
            max-height: 50vh;
            object-fit: contain;
            border-radius: 8px;
            margin-bottom: 1rem;
            background: #111;
        }

        .modal-info {
            display: grid;
            gap: 1rem;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        input, textarea {
            padding: 0.75rem;
            border: 1px solid #444;
            border-radius: 8px;
            font-size: 1rem;
            background: #0f0f0f;
            color: #e0e0e0;
            transition: all 0.3s ease;
        }

        input:focus, textarea:focus {
            outline: none;
            border-color: #666;
            background: #1a1a1a;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
            grid-column: 1 / -1;
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        button {
            padding: 0.75rem 1.5rem;
            border: 1px solid #444;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        button:hover {
            border-color: #666;
            background: #222;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: #2d2d2d;
            color: #fff;
        }

        .btn-primary:hover {
            background: #3d3d3d;
        }

        .btn-danger {
            background: #331a1a;
            border-color: #554444;
            color: #ffaaaa;
        }

        .btn-danger:hover {
            background: #442222;
        }

        .btn-success {
            background: #1a331a;
            border-color: #445544;
            color: #aaffaa;
        }

        .btn-success:hover {
            background: #224422;
        }

        .create-post-modal {
            width: 90%;
            max-width: 600px;
        }

        .batch-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .drag-indicator {
            position: fixed;
            pointer-events: none;
            z-index: 1500;
            background: rgba(255,255,255,0.9);
            color: #000;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            transform: translate(-50%, -50%);
            display: none;
        }

        .drop-zone-indicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(136, 136, 136, 0.2);
            border: 2px dashed #888;
            border-radius: 8px;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            color: #ccc;
            z-index: 100;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .series-grid {
                grid-template-columns: 1fr;
            }
            
            .unassigned-grid {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            }
            
            header {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }
            
            .controls {
                justify-content: center;
                gap: 0.5rem;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .batch-controls {
                grid-template-columns: 1fr;
            }

            .modal-buttons {
                flex-direction: column;
            }

            button {
                width: 100%;
            }
        }

        .drag-ghost {
            opacity: 0.5;
            transform: rotate(5deg) scale(0.9);
            pointer-events: none;
        }

        .no-transition {
            transition: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Dream Series Manager</h1>
            <div class="controls">
                <button onclick="showCreatePostModal()" class="btn-primary">New Post</button>
                <button onclick="showBatchCreateModal()" class="btn-success">Batch Create</button>
                <button onclick="exportSeries()" class="btn-primary">Export Series</button>
                <button onclick="clearAll()" class="btn-danger">Clear All</button>
            </div>
        </header>

        <div class="upload-area" id="uploadArea">
            <div class="upload-content">
                <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7,10 12,15 17,10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
                <p>Drop your dream images here or <span class="browse-text">browse files</span></p>
                <input type="file" id="fileInput" multiple accept="image/*" hidden>
            </div>
        </div>

        <div class="series-header">
            <h2 class="series-title">Post Series</h2>
            <div class="series-actions">
                <span id="seriesCount">0 posts</span>
            </div>
        </div>

        <div class="series-grid" id="seriesGrid">
            <!-- Posts will be generated here -->
        </div>

        <div class="unassigned-section">
            <h2 class="section-title">Unassigned Images (<span id="unassignedCount">0</span>)</h2>
            <div class="unassigned-grid" id="unassignedGrid">
                <!-- Unassigned images will appear here -->
            </div>
        </div>

        <!-- Image Modal -->
        <div class="modal" id="imageModal">
            <div class="modal-content">
                <span class="close" onclick="closeModal()">&times;</span>
                <img id="modalImage" src="" alt="">
                <div class="modal-info">
                    <div class="form-row">
                        <input type="text" id="modalName" placeholder="Image name">
                        <input type="text" id="modalTags" placeholder="Tags (comma separated)">
                    </div>
                    <textarea id="modalPrompt" placeholder="AI prompt used to generate this image"></textarea>
                    <div class="modal-buttons">
                        <button onclick="downloadOriginal()" class="btn-success">Download Original</button>
                        <button onclick="saveImage()" class="btn-primary">Save Changes</button>
                        <button onclick="deleteImage()" class="btn-danger">Delete Image</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Create Post Modal -->
        <div class="modal" id="createPostModal">
            <div class="modal-content create-post-modal">
                <span class="close" onclick="closeCreatePostModal()">&times;</span>
                <h2>Create New Post</h2>
                <div class="modal-info">
                    <input type="text" id="newPostTitle" placeholder="Post title">
                    <input type="date" id="newPostDate">
                    <input type="number" id="newPostSlots" placeholder="Number of image slots" value="8" min="1" max="20">
                    <div class="modal-buttons">
                        <button onclick="createPost()" class="btn-primary">Create Post</button>
                        <button onclick="closeCreatePostModal()">Cancel</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Batch Create Modal -->
        <div class="modal" id="batchCreateModal">
            <div class="modal-content create-post-modal">
                <span class="close" onclick="closeBatchCreateModal()">&times;</span>
                <h2>Batch Create Posts</h2>
                <div class="modal-info">
                    <div class="batch-controls">
                        <input type="number" id="batchCount" placeholder="Number of posts" value="10" min="1" max="50">
                        <input type="number" id="batchSlots" placeholder="Slots per post" value="8" min="1" max="20">
                        <input type="date" id="batchStartDate">
                    </div>
                    <input type="text" id="batchTitleTemplate" placeholder="Title template (use {n} for number)" value="Post {n}: Ascending">
                    <div class="modal-buttons">
                        <button onclick="batchCreatePosts()" class="btn-primary">Create Posts</button>
                        <button onclick="closeBatchCreateModal()">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="drag-indicator" id="dragIndicator">Moving image...</div>

    <script>
        // State management
        let images = JSON.parse(localStorage.getItem('dreamImages') || '[]');
        let posts = JSON.parse(localStorage.getItem('dreamPosts') || '[]');
        let currentImageId = null;
        let draggedImageId = null;
        let draggedFromPost = null;
        let draggedFromSlot = null;

        // Drag state tracking
        let isDragging = false;
        let dragStartPos = { x: 0, y: 0 };
        let currentDragElement = null;

        // Generate unique ID
        function generateId() {
            return Date.now() + Math.random().toString(36).substr(2, 9);
        }

        // Save data to localStorage
        function saveData() {
            localStorage.setItem('dreamImages', JSON.stringify(images));
            localStorage.setItem('dreamPosts', JSON.stringify(posts));
        }

        // File handling
        function setupUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

            let dragCounter = 0;

            uploadArea.addEventListener('dragenter', (e) => {
                e.preventDefault();
                dragCounter++;
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dragCounter--;
                if (dragCounter === 0) {
                    uploadArea.classList.remove('dragover');
                }
            });

            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dragCounter = 0;
                uploadArea.classList.remove('dragover');
                
                if (e.dataTransfer.files.length > 0) {
                    handleFiles(e.dataTransfer.files);
                }
            });
        }

        function handleFiles(files) {
            Array.from(files).forEach(file => {
                if (file.type.startsWith('image/')) {
                    processImage(file);
                }
            });
        }

        async function processImage(file) {
            try {
                const formData = new FormData();
                formData.append('image', file);

                const response = await fetch('/api/images', {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) throw new Error('Upload failed');

                const result = await response.json();

                const image = {
                    id: generateId(),
                    name: file.name,
                    originalName: file.name,
                    data: result.url, // server URL (Vercel Blob)
                    prompt: '',
                    tags: [],
                    uploadDate: new Date().toISOString(),
                    fileSize: file.size
                };

                images.push(image);
                saveData();
                render();
            } catch (error) {
                console.error('Upload failed:', error);
                alert('Failed to upload image. Please try again.');
            }
        }

        // Post management
        function createPost() {
            const title = document.getElementById('newPostTitle').value.trim();
            const date = document.getElementById('newPostDate').value;
            const slots = parseInt(document.getElementById('newPostSlots').value) || 8;

            if (!title) {
                alert('Please enter a post title');
                return;
            }

            const post = {
                id: generateId(),
                title: title,
                date: date || new Date().toISOString().split('T')[0],
                slots: Math.min(Math.max(slots, 1), 20),
                images: new Array(slots).fill(null)
            };

            posts.push(post);
            saveData();
            render();
            closeCreatePostModal();
        }

        function batchCreatePosts() {
            const count = parseInt(document.getElementById('batchCount').value) || 10;
            const slots = parseInt(document.getElementById('batchSlots').value) || 8;
            const startDate = document.getElementById('batchStartDate').value;
            const titleTemplate = document.getElementById('batchTitleTemplate').value || 'Post {n}';

            const baseDate = startDate ? new Date(startDate) : new Date();

            for (let i = 1; i <= Math.min(count, 50); i++) {
                const postDate = new Date(baseDate);
                postDate.setDate(baseDate.getDate() + (i - 1));

                const post = {
                    id: generateId(),
                    title: titleTemplate.replace('{n}', i),
                    date: postDate.toISOString().split('T')[0],
                    slots: Math.min(Math.max(slots, 1), 20),
                    images: new Array(slots).fill(null)
                };

                posts.push(post);
            }

            saveData();
            render();
            closeBatchCreateModal();
        }

        function deletePost(postId) {
            if (confirm('Are you sure you want to delete this post? Images will be moved back to unassigned.')) {
                posts = posts.filter(post => post.id !== postId);
                saveData();
                render();
            }
        }

        function updatePostTitle(postId, newTitle) {
            const post = posts.find(p => p.id === postId);
            if (post) {
                post.title = newTitle;
                saveData();
            }
        }

        function updatePostDate(postId, newDate) {
            const post = posts.find(p => p.id === postId);
            if (post) {
                post.date = newDate;
                saveData();
            }
        }

        // Robust drag and drop system
        function setupDragAndDrop() {
            document.addEventListener('dragstart', handleDragStart, false);
            document.addEventListener('dragend', handleDragEnd, false);
            document.addEventListener('dragover', handleDragOver, false);
            document.addEventListener('drop', handleDrop, false);
            document.addEventListener('dragenter', handleDragEnter, false);
            document.addEventListener('dragleave', handleDragLeave, false);

            // Mouse tracking for drag indicator
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const indicator = document.getElementById('dragIndicator');
                    indicator.style.left = e.clientX + 'px';
                    indicator.style.top = e.clientY - 30 + 'px';
                }
            });
        }

        function handleDragStart(e) {
            const imageItem = e.target.closest('.image-item');
            if (!imageItem) return;

            isDragging = true;
            draggedImageId = imageItem.dataset.imageId;
            draggedFromPost = imageItem.dataset.fromPost || null;
            draggedFromSlot = imageItem.dataset.fromSlot ? parseInt(imageItem.dataset.fromSlot) : null;
            currentDragElement = imageItem;

            // Visual feedback
            imageItem.classList.add('dragging');
            
            // Show drag indicator
            const indicator = document.getElementById('dragIndicator');
            indicator.style.display = 'block';
            indicator.textContent = `Moving: ${images.find(img => img.id === draggedImageId)?.name || 'Image'}`;

            // Disable other images during drag
            document.querySelectorAll('.image-item').forEach(item => {
                if (item !== imageItem) {
                    item.classList.add('drag-disabled');
                }
            });

            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedImageId);
        }

        function handleDragEnd(e) {
            isDragging = false;
            draggedImageId = null;
            draggedFromPost = null;
            draggedFromSlot = null;
            currentDragElement = null;

            // Hide drag indicator
            document.getElementById('dragIndicator').style.display = 'none';

            // Clean up visual states
            document.querySelectorAll('.image-item').forEach(item => {
                item.classList.remove('dragging', 'drag-disabled');
            });

            document.querySelectorAll('.image-slot').forEach(slot => {
                slot.classList.remove('drag-over');
            });

            document.querySelectorAll('.post-container').forEach(container => {
                container.classList.remove('drag-over-post');
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            
            const slot = e.target.closest('.image-slot');
            const postContainer = e.target.closest('.post-container');
            
            if (slot && !slot.classList.contains('occupied')) {
                slot.classList.add('drag-over');
            } else if (postContainer) {
                postContainer.classList.add('drag-over-post');
            }
        }

        function handleDragLeave(e) {
            // Use a small timeout to prevent flickering
            setTimeout(() => {
                const slot = e.target.closest('.image-slot');
                const postContainer = e.target.closest('.post-container');
                
                if (slot) {
                    slot.classList.remove('drag-over');
                }
                if (postContainer) {
                    postContainer.classList.remove('drag-over-post');
                }
            }, 50);
        }

        function handleDrop(e) {
            e.preventDefault();
            
            const slot = e.target.closest('.image-slot');
            const postContainer = e.target.closest('.post-container');
            
            if (!draggedImageId) return;

            if (slot) {
                const postId = slot.closest('.post-container').dataset.postId;
                const slotIndex = parseInt(slot.dataset.slot);
                moveImageToSlot(draggedImageId, postId, slotIndex);
            } else if (postContainer) {
                // Drop anywhere on post container - add to first available slot
                const postId = postContainer.dataset.postId;
                addImageToPost(draggedImageId, postId);
            }

            // Clean up
            document.querySelectorAll('.image-slot').forEach(s => s.classList.remove('drag-over'));
            document.querySelectorAll('.post-container').forEach(p => p.classList.remove('drag-over-post'));
        }

        function moveImageToSlot(imageId, postId, slotIndex) {
            // Remove from previous location
            if (draggedFromPost) {
                const fromPost = posts.find(p => p.id === draggedFromPost);
                if (fromPost && draggedFromSlot !== null) {
                    fromPost.images[draggedFromSlot] = null;
                }
            }

            // Add to new location
            const toPost = posts.find(p => p.id === postId);
            if (toPost) {
                // If slot is occupied, move that image back to unassigned
                if (toPost.images[slotIndex]) {
                    // Image is displaced, no need to do anything special
                }
                toPost.images[slotIndex] = imageId;
            }

            saveData();
            render();
        }

        function addImageToPost(imageId, postId) {
            // Remove from previous location
            if (draggedFromPost) {
                const fromPost = posts.find(p => p.id === draggedFromPost);
                if (fromPost && draggedFromSlot !== null) {
                    fromPost.images[draggedFromSlot] = null;
                }
            }

            // Find first available slot
            const post = posts.find(p => p.id === postId);
            if (post) {
                const emptySlot = post.images.findIndex(slot => slot === null);
                if (emptySlot !== -1) {
                    post.images[emptySlot] = imageId;
                }
            }

            saveData();
            render();
        }

        function removeImageFromSlot(postId, slotIndex) {
            const post = posts.find(p => p.id === postId);
            if (post) {
                post.images[slotIndex] = null;
                saveData();
                render();
            }
        }

        // Rendering
        function render() {
            renderPosts();
            renderUnassigned();
            updateCounts();
        }

        function renderPosts() {
            const grid = document.getElementById('seriesGrid');
            grid.innerHTML = '';

            posts.forEach(post => {
                const postDiv = document.createElement('div');
                postDiv.className = 'post-container';
                postDiv.dataset.postId = post.id;
                
                const occupiedSlots = post.images.filter(img => img !== null).length;
                
                postDiv.innerHTML = `
                    <div class="post-header">
                        <div class="post-info">
                            <textarea 
                                class="post-title" 
                                onblur="updatePostTitle('${post.id}', this.value)"
                                onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();this.blur();}"
                            >${post.title}</textarea>
                            <input 
                                type="date" 
                                class="post-date" 
                                value="${post.date}"
                                onchange="updatePostDate('${post.id}', this.value)"
                            >
                        </div>
                        <div class="post-actions">
                            <div class="post-count">${occupiedSlots}/${post.slots} images</div>
                            <button class="delete-post" onclick="deletePost('${post.id}')">Delete</button>
                        </div>
                    </div>
                    <div class="image-slots">
                        ${post.images.map((imageId, slotIndex) => {
                            const image = imageId ? images.find(img => img.id === imageId) : null;
                            
                            if (image) {
                                return `
                                    <div class="image-slot occupied" data-slot="${slotIndex}">
                                        <img src="${image.data}" alt="${image.name}" onclick="openModal('${image.id}')">
                                        <button class="remove-btn" onclick="removeImageFromSlot('${post.id}', ${slotIndex})" title="Remove from slot">×</button>
                                    </div>
                                `;
                            } else {
                                return `
                                    <div class="image-slot" data-slot="${slotIndex}">
                                        <span class="add-icon">+</span>
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>
                `;

                grid.appendChild(postDiv);
            });
        }

        function renderUnassigned() {
            const grid = document.getElementById('unassignedGrid');
            grid.innerHTML = '';

            const assignedIds = new Set();
            posts.forEach(post => {
                post.images.forEach(id => {
                    if (id) assignedIds.add(id);
                });
            });

            const unassignedImages = images.filter(img => !assignedIds.has(img.id));

            unassignedImages.forEach(image => {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'image-item';
                imageDiv.draggable = true;
                imageDiv.dataset.imageId = image.id;

                const sizeText = image.fileSize ? ` (${(image.fileSize / 1024 / 1024).toFixed(2)}MB)` : '';

                imageDiv.innerHTML = `
                    <img src="${image.data}" alt="${image.name}">
                    <div class="image-info">
                        <div class="image-name">${image.name}${sizeText}</div>
                        <div class="image-prompt">${image.prompt || 'No prompt saved'}</div>
                        <div class="image-tags">
                            ${image.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                        </div>
                        <div class="image-actions">
                            <button onclick="openModal('${image.id}')" class="btn-primary">Edit</button>
                            <button onclick="downloadOriginal('${image.id}')" class="btn-success">Download</button>
                            <button onclick="deleteImage('${image.id}')" class="btn-danger">Delete</button>
                        </div>
                    </div>
                `;

                grid.appendChild(imageDiv);
            });
        }

        function updateCounts() {
            document.getElementById('seriesCount').textContent = `${posts.length} posts`;
            
            const assignedIds = new Set();
            posts.forEach(post => {
                post.images.forEach(id => {
                    if (id) assignedIds.add(id);
                });
            });
            
            const unassignedCount = images.length - assignedIds.size;
            document.getElementById('unassignedCount').textContent = unassignedCount;
        }

        // Modal functions
        function openModal(imageId) {
            const image = images.find(img => img.id === imageId);
            if (!image) return;

            currentImageId = imageId;
            
            document.getElementById('modalImage').src = image.data;
            document.getElementById('modalName').value = image.name;
            document.getElementById('modalPrompt').value = image.prompt || '';
            document.getElementById('modalTags').value = image.tags.join(', ');
            
            document.getElementById('imageModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('imageModal').style.display = 'none';
            currentImageId = null;
        }

        function showCreatePostModal() {
            document.getElementById('newPostTitle').value = '';
            document.getElementById('newPostDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('newPostSlots').value = '8';
            document.getElementById('createPostModal').style.display = 'block';
        }

        function closeCreatePostModal() {
            document.getElementById('createPostModal').style.display = 'none';
        }

        function showBatchCreateModal() {
            document.getElementById('batchCount').value = '10';
            document.getElementById('batchSlots').value = '8';
            document.getElementById('batchStartDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('batchTitleTemplate').value = 'Post {n}: Ascending';
            document.getElementById('batchCreateModal').style.display = 'block';
        }

        function closeBatchCreateModal() {
            document.getElementById('batchCreateModal').style.display = 'none';
        }

        function saveImage() {
            if (!currentImageId) return;

            const image = images.find(img => img.id === currentImageId);
            if (!image) return;

            image.name = document.getElementById('modalName').value.trim() || image.originalName;
            image.prompt = document.getElementById('modalPrompt').value.trim();
            image.tags = document.getElementById('modalTags').value
                .split(',')
                .map(tag => tag.trim())
                .filter(tag => tag);

            saveData();
            render();
            closeModal();
        }

        async function deleteImage(imageId = currentImageId) {
            if (!imageId) return;

            const image = images.find(img => img.id === imageId);
            if (!image) return;

            if (confirm(`Are you sure you want to delete "${image.name}"? This cannot be undone.`)) {
                try {
                    // Best-effort server delete by URL (backend should ignore if not found)
                    if (image.data && typeof image.data === 'string') {
                        await fetch(`/api/images?url=${encodeURIComponent(image.data)}`, { method: 'DELETE' });
                    }
                } catch (err) {
                    console.warn('Server delete failed or not configured; proceeding with local cleanup.', err);
                }

                // Remove from all posts
                posts.forEach(post => {
                    post.images = post.images.map(id => id === imageId ? null : id);
                });

                // Remove from images array
                images = images.filter(img => img.id !== imageId);

                saveData();
                render();

                if (currentImageId === imageId) {
                    closeModal();
                }
            }
        }

        function downloadOriginal(imageId = currentImageId) {
            if (!imageId) return;
            
            const image = images.find(img => img.id === imageId);
            if (!image) return;

            // Create download link
            const link = document.createElement('a');
            link.href = image.data;
            link.download = image.originalName || image.name || 'image.jpg';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Export functionality
        function exportSeries() {
            const exportData = {
                posts: posts.map(post => ({
                    ...post,
                    images: post.images.map(imageId => {
                        if (!imageId) return null;
                        const image = images.find(img => img.id === imageId);
                        return image ? {
                            id: image.id,
                            name: image.name,
                            prompt: image.prompt,
                            tags: image.tags
                        } : null;
                    })
                })),
                totalImages: images.length,
                exportDate: new Date().toISOString(),
                version: '2.0'
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                type: 'application/json'
            });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dream-series-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all data? This will delete all images and posts permanently.')) {
                if (confirm('This action cannot be undone. Are you absolutely sure?')) {
                    images = [];
                    posts = [];
                    localStorage.removeItem('dreamImages');
                    localStorage.removeItem('dreamPosts');
                    render();
                }
            }
        }

        // Close modals on outside click
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                if (e.target.id === 'imageModal') closeModal();
                if (e.target.id === 'createPostModal') closeCreatePostModal();
                if (e.target.id === 'batchCreateModal') closeBatchCreateModal();
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
                closeCreatePostModal();
                closeBatchCreateModal();
            }
        });

        // Initialize app
        async function init() {
            setupUpload();
            setupDragAndDrop();
            await initialSync();
            render();
        }

        async function initialSync() {
            // 1) Migrate any leftover base64 images to the server
            const needsMigration = images.filter(img => typeof img.data === 'string' && img.data.startsWith('data:image/'));
            for (const legacy of needsMigration) {
                try {
                    const blob = dataURLtoBlob(legacy.data);
                    const file = new File([blob], legacy.originalName || legacy.name || 'image.jpg', { type: blob.type || 'image/jpeg' });
                    const formData = new FormData();
                    formData.append('image', file);

                    const res = await fetch('/api/images', { method: 'POST', body: formData });
                    if (!res.ok) throw new Error('Migration upload failed');

                    const out = await res.json();
                    legacy.data = out.url; // swap base64 for server URL
                } catch (e) {
                    console.warn('Migration of one image failed; skipping.', e);
                }
            }
            if (needsMigration.length) saveData();

            // 2) Pull server list and merge any images we don’t know about (by URL)
            try {
                const res = await fetch('/api/images', { method: 'GET' });
                if (res.ok) {
                    const payload = await res.json();
                    const serverImages = Array.isArray(payload) ? payload : (payload.images || []);
                    const known = new Set(images.map(i => i.data));
                    serverImages.forEach(item => {
                        if (!item?.url || known.has(item.url)) return;
                        images.push({
                            id: generateId(),
                            name: item.name || item.filename || 'image.jpg',
                            originalName: item.originalName || item.name || item.filename || 'image.jpg',
                            data: item.url,
                            prompt: item.prompt || '',
                            tags: item.tags || [],
                            uploadDate: item.uploadDate || new Date().toISOString(),
                            fileSize: item.size || null
                        });
                    });
                    if (serverImages.length) saveData();
                }
            } catch (e) {
                console.warn('Initial server sync skipped:', e);
            }

            function dataURLtoBlob(dataURL) {
                const parts = dataURL.split(',');
                const meta = parts[0];
                const base64 = parts[1];
                const mime = (meta.match(/data:(.*?);/) || [])[1] || 'image/jpeg';
                const binary = atob(base64);
                const len = binary.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
                return new Blob([bytes], { type: mime });
            }
        }

        init();
    </script>
</body>
</html>