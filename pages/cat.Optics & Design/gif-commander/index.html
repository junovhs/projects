<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Images ‚Üí WebM (Client-Only, GIF via ffmpeg.wasm)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family:"Segoe UI", Roboto, Arial, sans-serif; background:linear-gradient(135deg,#e0eafc,#cfdef3);
      margin:0; min-height:100vh; display:flex; justify-content:center; align-items:flex-start; padding:36px 14px; }
    .container { background:#fff; padding:28px 34px; border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,.1);
      max-width:860px; width:100%; }
    h1 { margin:0 0 8px; text-align:center; color:#2c3e50; font-size:1.8rem; }
    p  { margin:0 0 16px; text-align:center; color:#555; }
    label { display:block; margin:12px 0 6px; font-weight:600; color:#333; }
    input[type="number"], input[type="text"], select {
      width:100%; padding:10px 12px; font-size:1rem; border:1px solid #ccc; border-radius:8px; box-sizing:border-box;
    }
    input[type="range"] { width:100%; }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .row > div { flex:1 1 180px; min-width:180px; }
    .btn { display:inline-block; padding:12px 16px; border:none; border-radius:8px; cursor:pointer;
      background:linear-gradient(135deg,#3498db,#2ecc71); color:#fff; font-weight:600; }
    .btn.secondary { background:linear-gradient(135deg,#6c757d,#495057); }
    .btn.warn { background:linear-gradient(135deg,#f39c12,#d35400); }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .btn-row{ display:flex; gap:10px; flex-wrap:wrap; margin-bottom:8px; }
    .small{ font-size:.9rem; color:#666; }
    .note{ background:#d1ecf1; border:1px solid #bee5eb; padding:12px; border-radius:8px; margin:12px 0; color:#0c5460; }
    .warnbox{ background:#fff3cd; border:1px solid #ffeaa7; padding:12px; border-radius:8px; margin:12px 0; color:#856404; }
    .list{ font-family:ui-monospace,Menlo,Consolas,monospace; background:#f8f9fa; border:1px solid #e1e5ea; border-radius:8px;
      padding:10px; max-height:160px; overflow:auto; }
    video{ width:100%; margin-top:12px; border-radius:8px; background:#000; }
    progress{ width:100%; height:12px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üñºÔ∏è Image Sequence ‚Üí WebM (and GIF)</h1>
    <p>Pick a folder or files, tweak quality, export a loopable WebM, and optionally convert to GIF ‚Äî all client-side.</p>

    <div class="btn-row">
      <button class="btn" id="pickFolder">üìÅ Pick Folder</button>
      <input type="file" id="folderCompat" webkitdirectory directory multiple accept="image/*" style="display:none" />
      <button class="btn secondary" id="pickFolderCompat">üìÅ Pick Folder (compat)</button>
      <input type="file" id="pickFiles" accept="image/*" multiple style="display:none" />
      <button class="btn secondary" id="pickFilesBtn">üñºÔ∏è Select Images</button>
    </div>

    <div class="note small">
      Folder Picker needs a top-level HTTPS page (Vercel/GitHub Pages are fine). Use the ‚Äúcompat‚Äù button if it‚Äôs blocked.
    </div>

    <div class="row">
      <div>
        <label for="fps">‚è±Ô∏è FPS</label>
        <input type="number" id="fps" min="1" value="3" />
      </div>
      <div>
        <label for="bitrate">üîß Bitrate (kbps)</label>
        <input type="number" id="bitrate" min="64" value="6000" />
      </div>
      <div>
        <label for="codec">üéõÔ∏è Codec</label>
        <select id="codec">
          <option value="video/webm;codecs=vp9">VP9 (better)</option>
          <option value="video/webm;codecs=vp8">VP8 (compat)</option>
          <option value="video/webm">Auto</option>
        </select>
      </div>
      <div>
        <label for="smoothing">üñåÔ∏è Image Smoothing</label>
        <select id="smoothing">
          <option value="on">On (smooth)</option>
          <option value="off">Off (pixel-sharp)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label for="width">üìê Width (px, blank = source)</label>
        <input type="number" id="width" min="1" placeholder="(auto)">
      </div>
      <div>
        <label for="height">üìè Height (px, blank = auto)</label>
        <input type="number" id="height" min="1" placeholder="(auto)">
      </div>
      <div>
        <label for="fit">üß© Fit</label>
        <select id="fit">
          <option value="contain">Contain (letterbox)</option>
          <option value="cover">Cover (crop)</option>
          <option value="stretch">Stretch</option>
        </select>
      </div>
      <div>
        <label for="bg">üé® Background</label>
        <input type="text" id="bg" value="#000000" />
      </div>
    </div>

    <div class="row">
      <div>
        <label for="mode">üîÅ Play Order</label>
        <select id="mode">
          <option value="forward">Forward</option>
          <option value="boomerang">Boomerang</option>
          <option value="reverse">Reverse</option>
        </select>
      </div>
      <div>
        <label for="hold">üïí Extra hold per frame (ms)</label>
        <input type="number" id="hold" min="0" value="0">
      </div>
    </div>

    <label>Selected Images</label>
    <div id="list" class="list">None yet.</div>

    <div class="btn-row" style="margin-top:10px;">
      <button class="btn" id="make">‚ö° Make WebM</button>
      <button class="btn warn" id="makeGif" disabled>‚ú® Convert WebM ‚Üí GIF (ffmpeg.wasm)</button>
    </div>

    <label>Progress</label>
    <progress id="prog" max="100" value="0"></progress>
    <div id="status" class="small" style="margin-top:6px;">Idle.</div>

    <video id="preview" autoplay loop muted playsinline controls style="display:none"></video>
    <div id="dlWrap" style="display:none; margin-top:10px;"><a id="download" class="btn">‚¨áÔ∏è Download WebM</a></div>
  </div>

  <script>
    // Elements
    const pickFolderBtn = document.getElementById('pickFolder');
    const pickFolderCompat = document.getElementById('pickFolderCompat');
    const folderCompatInput = document.getElementById('folderCompat');
    const pickFilesHidden = document.getElementById('pickFiles');
    const pickFilesBtn = document.getElementById('pickFilesBtn');
    const listEl = document.getElementById('list');
    const fpsEl = document.getElementById('fps');
    const bitrateEl = document.getElementById('bitrate');
    const codecEl = document.getElementById('codec');
    const wEl = document.getElementById('width');
    const hEl = document.getElementById('height');
    const fitEl = document.getElementById('fit');
    const bgEl = document.getElementById('bg');
    const smoothingEl = document.getElementById('smoothing');
    const modeEl = document.getElementById('mode');
    const holdEl = document.getElementById('hold');
    const makeBtn = document.getElementById('make');
    const makeGifBtn = document.getElementById('makeGif');
    const prog = document.getElementById('prog');
    const statusEl = document.getElementById('status');
    const preview = document.getElementById('preview');
    const downloadA = document.getElementById('download');
    const dlWrap = document.getElementById('dlWrap');

    // State
    let imageFiles = [];   // File[]
    let bitmaps = [];      // ImageBitmap[]
    let naturalW=null, naturalH=null;
    let lastWebMBlob = null;
    let lastCanvasW = null, lastCanvasH = null, lastMime = null;

    function status(msg){ statusEl.textContent = msg; }

    function naturalSort(a, b) {
      const ax=[], bx=[];
      a.name.replace(/(\d+)|(\D+)/g, (_,n,t)=>ax.push([n||Infinity,t||""]));
      b.name.replace(/(\d+)|(\D+)/g, (_,n,t)=>bx.push([n||Infinity,t||""]));
      while (ax.length && bx.length) {
        const an=ax.shift(), bn=bx.shift();
        if (an[0]!==Infinity || bn[0]!==Infinity) {
          const na=parseInt(an[0],10), nb=parseInt(bn[0],10);
          if (na!==nb) return na-nb;
        } else if (an[1]!==bn[1]) return an[1]>bn[1]?1:-1;
      }
      return ax.length-bx.length;
    }

    function setImages(files) {
      imageFiles = files.filter(f => /\.(png|jpe?g|webp)$/i.test(f.name));
      imageFiles.sort(naturalSort);
      bitmaps = []; naturalW=null; naturalH=null;
      showList();
      status(\`Loaded \${imageFiles.length} image(s).\`);
    }

    function showList() {
      if (!imageFiles.length) { listEl.textContent = "None yet."; return; }
      const names = imageFiles.map(f=>f.name);
      const shown = names.slice(0,80).map(n=>\`<div>\${n}</div>\`).join("");
      listEl.innerHTML = shown + (names.length>80? \`<div>‚Ä¶ +\${names.length-80} more</div>\` : "");
    }

    // Pickers
    pickFolderBtn.onclick = async () => {
      try {
        if (!window.showDirectoryPicker) { folderCompatInput.click(); return; }
        const dir = await window.showDirectoryPicker();
        const files=[];
        for await (const entry of dir.values()) {
          if (entry.kind==="file" && /\.(png|jpe?g|webp)$/i.test(entry.name)) {
            files.push(await entry.getFile());
          }
        }
        setImages(files);
      } catch(e){ if(e?.name!=="AbortError") console.error(e); }
    };
    pickFolderCompat.onclick = () => folderCompatInput.click();
    folderCompatInput.onchange = () => setImages(Array.from(folderCompatInput.files));
    pickFilesBtn.onclick = () => pickFilesHidden.click();
    pickFilesHidden.onchange = () => setImages(Array.from(pickFilesHidden.files));

    async function loadBitmaps() {
      if (!imageFiles.length) throw new Error("No images selected.");
      bitmaps = [];
      for (let i=0;i<imageFiles.length;i++){
        const bm = await createImageBitmap(imageFiles[i]);
        bitmaps.push(bm);
        if (!naturalW) { naturalW=bm.width; naturalH=bm.height; wEl.placeholder=String(naturalW); hEl.placeholder="(auto)"; }
        prog.value = Math.round(((i+1)/imageFiles.length)*25); // up to 25%
      }
    }

    function pickMime(preferred) {
      const order = preferred ? [preferred, 'video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm']
                              : ['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
      for (const t of order) { if (MediaRecorder.isTypeSupported(t)) return t; }
      return 'video/webm';
    }

    function drawFit(ctx, bm, W, H, mode, bg, smoothing) {
      ctx.save();
      ctx.imageSmoothingEnabled = (smoothing !== "off");
      if (mode === "stretch") {
        ctx.fillStyle = bg; ctx.fillRect(0,0,W,H);
        ctx.drawImage(bm, 0, 0, W, H);
      } else {
        const sContain = Math.min(W/bm.width, H/bm.height);
        const sCover   = Math.max(W/bm.width, H/bm.height);
        const s = (mode==="cover")? sCover : sContain;
        const dw = Math.round(bm.width*s), dh = Math.round(bm.height*s);
        const dx = Math.floor((W - dw)/2), dy = Math.floor((H - dh)/2);
        ctx.fillStyle = bg; ctx.fillRect(0,0,W,H);
        ctx.drawImage(bm, dx, dy, dw, dh);
      }
      ctx.restore();
    }

    function buildFrameOrder(mode, count) {
      if (mode === "reverse") return Array.from({length:count}, (_,i)=>count-1-i);
      if (mode === "boomerang") {
        const fwd = Array.from({length:count}, (_,i)=>i);
        const rev = Array.from({length:count-2}, (_,i)=>count-2-i);
        return fwd.concat(rev);
      }
      return Array.from({length:count}, (_,i)=>i);
    }

    async function makeWebM() {
      try {
        prog.value = 0; preview.style.display="none"; dlWrap.style.display="none";
        lastWebMBlob=null; makeGifBtn.disabled = true;

        status("Preparing‚Ä¶");
        await loadBitmaps();

        const fps = Math.max(1, parseInt(fpsEl.value||"3",10));
        const kbps = Math.max(64, parseInt(bitrateEl.value||"6000",10));
        const mime = pickMime(codecEl.value);
        const fit = fitEl.value;
        const bg = bgEl.value || "#000";
        const smoothing = smoothingEl.value;
        const holdMs = Math.max(0, parseInt(holdEl.value||"0",10));
        let W = parseInt(wEl.value, 10), H = parseInt(hEl.value,10);
        if (!W && !H) { W = naturalW; H = naturalH; }
        else if (W && !H) { H = Math.round(naturalH * (W / naturalW)); }
        else if (!W && H) { W = Math.round(naturalW * (H / naturalH)); }

        lastCanvasW = W; lastCanvasH = H; lastMime = mime;

        const canvas = document.createElement('canvas'); canvas.width=W; canvas.height=H;
        const ctx = canvas.getContext('2d');

        const stream = canvas.captureStream(fps);
        const rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: kbps*1000 });
        const chunks=[]; let stopped=false;
        rec.ondataavailable = e => { if (e.data?.size) chunks.push(e.data); };
        rec.onstop = ()=>{ stopped=true; };

        rec.start(200);
        status(\`Encoding \${bitmaps.length} frame(s) @ \${fps} fps, ~\${kbps} kbps, \${W}√ó\${H}‚Ä¶\`);

        const order = buildFrameOrder(modeEl.value, bitmaps.length);
        const frameDur = 1000 / fps;

        for (let idx=0; idx<order.length; idx++) {
          drawFit(ctx, bitmaps[order[idx]], W, H, fit, bg, smoothing);
          prog.value = 25 + Math.round(((idx+1)/order.length)*60); // 25‚Üí85
          await new Promise(r => setTimeout(r, frameDur));

          if (holdMs>0) {
            const repeats = Math.floor(holdMs / frameDur);
            for (let r=0; r<repeats; r++) { await new Promise(res => setTimeout(res, frameDur)); }
          }
        }

        await new Promise(r => setTimeout(r, 250));
        rec.stop();
        await new Promise(res => { const t=setInterval(()=>{ if(stopped){clearInterval(t); res();}},50); });

        const blob = new Blob(chunks, { type: mime });
        const url = URL.createObjectURL(blob);
        preview.src = url; preview.style.display="block";
        downloadA.href = url; downloadA.download = "out.webm";
        dlWrap.style.display = "block";
        prog.value = 100;
        status(\`Done. \${(blob.size/1024/1024).toFixed(2)} MB (\${mime})\`);
        lastWebMBlob = blob;
        makeGifBtn.disabled = false;
      } catch (err) {
        console.error(err);
        status("Error: " + (err && err.message ? err.message : err));
      }
    }

    // --- Lazy-load ffmpeg.wasm (UMD) only when needed
    let ffmpegPromise = null;
    function loadScript(src){
      return new Promise((res,rej)=>{
        const s=document.createElement('script');
        s.src = src; s.onload=()=>res(); s.onerror=()=>rej(new Error('Failed to load '+src));
        document.head.appendChild(s);
      });
    }
    async function getFFmpeg() {
      if (ffmpegPromise) return ffmpegPromise;
      ffmpegPromise = (async () => {
        status("Loading ffmpeg.wasm‚Ä¶");
        // Pin versions and keep corePath in sync with @ffmpeg/ffmpeg version
        await loadScript('https://unpkg.com/@ffmpeg/ffmpeg@0.12.15/dist/ffmpeg.min.js');
        const { createFFmpeg } = window.FFmpeg; // UMD global
        const ff = createFFmpeg({
          log: true,
          corePath: 'https://unpkg.com/@ffmpeg/core@0.12.15/dist/ffmpeg-core.js',
          progress: ({ ratio }) => { prog.value = Math.min(95, 5 + Math.round(ratio*80)); }
        });
        await ff.load();
        status("ffmpeg ready");
        return ff;
      })();
      return ffmpegPromise;
    }

    async function convertToGif() {
      if (!lastWebMBlob) { alert("Make a WebM first."); return; }
      try {
        makeGifBtn.disabled = true;
        prog.value = 5;
        const ff = await getFFmpeg();

        // Write input
        const buf = new Uint8Array(await lastWebMBlob.arrayBuffer());
        ff.FS('writeFile', 'in.webm', buf);

        const fps = Math.max(1, parseInt(fpsEl.value || "3", 10));
        const W = lastCanvasW || 480;
        const H = lastCanvasH || -1;

        status("Generating GIF palette‚Ä¶");
        await ff.run(
          '-i','in.webm',
          '-vf', `fps=${fps},scale=${W}:${H===-1?-1:H}:flags=lanczos,palettegen`,
          '-y','pal.png'
        );

        status("Applying palette (dither)‚Ä¶");
        await ff.run(
          '-i','in.webm','-i','pal.png',
          '-lavfi','[0:v][1:v]paletteuse=dither=bayer:bayer_scale=3',
          '-loop','0',
          '-y','out.gif'
        );

        const data = ff.FS('readFile','out.gif');
        const gifBlob = new Blob([data.buffer], { type: 'image/gif' });
        const url = URL.createObjectURL(gifBlob);

        // Offer download next to WebM
        const a = document.createElement('a');
        a.href = url; a.download = 'out.gif'; a.className='btn secondary'; a.textContent='‚¨áÔ∏è Download GIF';
        dlWrap.appendChild(document.createTextNode(' '));
        dlWrap.appendChild(a);
        dlWrap.style.display = "block";

        prog.value = 100;
        status(`GIF ready. ${(gifBlob.size/1024/1024).toFixed(2)} MB`);
        makeGifBtn.disabled = false;
      } catch (e) {
        console.error(e);
        status("GIF Error: " + (e?.message || e));
        makeGifBtn.disabled = false;
      }
    }

    // Wire up buttons
    makeBtn.onclick = makeWebM;
    makeGifBtn.onclick = convertToGif;
  </script>
</body>
</html>
