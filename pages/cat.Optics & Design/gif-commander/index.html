<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Images/Video ‚Üí WebM (Browser-Only)</title>
  <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.min.js"></script>
  <link rel="manifest" href="data:application/manifest+json,{
    'name': 'WebM/GIF Maker',
    'short_name': 'ClipMaker',
    'start_url': '.',
    'display': 'standalone',
    'background_color': '#e0eafc',
    'theme_color': '#3498db',
    'icons': [{'src': 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiBmaWxsPSIjMzQ5OGRiIi8+CjxwYXRoIGQ9Ik0zMiA0MEw2NCA0MEwxNjAgNDBMNzYgMTYwTDMyIDQwWiIgZmlsbD0iI2ZmZiIvPgo8L3N2Zz4K', 'sizes': '192x192', 'type': 'image/svg+xml'}]
  }">
  <meta name="theme-color" content="#3498db">
  <style>
    body {
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #e0eafc, #cfdef3);
      margin: 0; padding: 0; min-height: 100vh;
      display: flex; justify-content: center; align-items: flex-start; padding-top: 40px;
    }
    .container {
      background: #fff; padding: 30px 40px; border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.1);
      max-width: 760px; width: 92%; animation: fadeIn 0.6s ease-in-out;
    }
    h1 { text-align: center; margin: 0 0 10px; font-size: 1.8rem; color: #2c3e50; }
    p  { text-align: center; color: #555; margin: 0 0 18px; }
    label { display:block; margin: 14px 0 6px; font-weight:600; color:#333; }
    input[type="number"], input[type="text"], select {
      width:100%; padding:12px 14px; font-size:1rem; border:1px solid #ccc; border-radius:8px; box-sizing:border-box;
      transition: border .3s ease, box-shadow .3s ease;
    }
    input[type="range"] { width:100%; margin: 8px 0; }
    input:focus, select:focus { border-color:#3498db; box-shadow:0 0 6px rgba(52,152,219,.4); outline:none; }
    .row { display:flex; gap:12px; }
    .row > div { flex:1; }
    .btn {
      display:inline-block; padding:12px 16px; border:none; border-radius:8px; cursor:pointer;
      background: linear-gradient(135deg, #3498db, #2ecc71); color:#fff; font-weight:600;
      transition: transform .15s ease, box-shadow .2s ease;
    }
    .btn:hover { transform: translateY(-2px); box-shadow:0 6px 12px rgba(0,0,0,.15); }
    .btn.secondary { background: linear-gradient(135deg, #6c757d, #495057); }
    .btn-row { display:flex; gap:10px; flex-wrap:wrap; }
    .small { color:#666; font-size:.9rem; }
    .note, .warn {
      border-radius:8px; padding:12px 14px; margin:14px 0; font-size:.95rem;
    }
    .note  { background:#d1ecf1; border:1px solid #bee5eb; color:#0c5460; }
    .warn  { background:#fff3cd; border:1px solid #ffeaa7; color:#856404; }
    video, img { width:100%; margin-top:14px; border-radius:8px; background:#000; }
    progress { width:100%; height:12px; }
    .list { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#f8f9fa; border:1px solid #e1e5ea; border-radius:8px; padding:10px; max-height:120px; overflow:auto; }
    .preset-btn { padding: 8px 12px; font-size: 0.9rem; margin: 2px; border-radius: 6px; background: #f8f9fa; border: 1px solid #ddd; color: #333; cursor: pointer; }
    .preset-btn:hover { background: #e9ecef; }
    .cancel-btn { background: #dc3545; flex: none; padding: 8px 16px; font-size: 0.9rem; }
    .caps-banner { text-align: center; margin: 10px 0; font-size: 0.85rem; color: #666; }
    @keyframes fadeIn { from {opacity:0; transform:translateY(10px);} to {opacity:1; transform:translateY(0);} }
  </style>
</head>
<body>
  <div class="container">
    <h1>üñºÔ∏è Images/Video ‚Üí WebM</h1>
    <p>Pick a folder/files/video, set <strong>FPS</strong> (default 3 for images, source for video), and make a looping WebM (GIF replacement). All client-side!</p>

    <div class="btn-row">
      <button class="btn" id="pickFolderBtn">üìÅ Pick Folder</button>
      <input type="file" id="fileInput" accept="image/*" multiple style="display:none" />
      <button class="btn secondary" id="pickFilesBtn">üñºÔ∏è Select Images</button>
      <input type="file" id="folderCompat" webkitdirectory directory multiple accept="image/*" style="display:none" />
      <button class="btn secondary" id="pickFolderCompat">üìÅ Pick Folder (compat)</button>
      <input type="file" id="videoInput" accept="video/*" style="display:none" />
      <button class="btn secondary" id="pickVideoBtn">üé• Upload Video</button>
    </div>

    <div class="caps-banner" id="capsBanner"></div>

    <div class="note small">
      Tip: Files sorted naturally. Videos auto-extract frames at FPS. Mixed OK‚Äîresized consistently.
    </div>

    <div class="row">
      <div>
        <label for="fps">‚è±Ô∏è Frame Rate (fps)</label>
        <input type="number" id="fps" min="1" value="" placeholder="(auto)" />
      </div>
      <div>
        <label for="duration">‚è≥ Duration (s, blank = full)</label>
        <input type="number" id="duration" min="0.1" step="0.1" placeholder="(auto)" />
      </div>
      <div>
        <label><input type="checkbox" id="loop" checked> üîÑ Loop</label>
      </div>
    </div>

    <div class="row">
      <div style="flex:2">
        <label>Quick Presets</label>
        <div class="btn-row">
          <button class="preset-btn" data-preset="tiny">Tiny (480p, 6fps)</button>
          <button class="preset-btn" data-preset="balanced">Balanced (720p, 10fps)</button>
          <button class="preset-btn" data-preset="hq">HQ (1080p, 15fps)</button>
        </div>
      </div>
      <div>
        <label for="scaleMode">üñºÔ∏è Scale Mode</label>
        <select id="scaleMode">
          <option value="crop">Crop (preserve aspect, no bars)</option>
          <option value="fit">Fit (letterbox)</option>
          <option value="stretch">Stretch (fill, may distort)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label for="width">üìê Output Width (px, blank = source)</label>
        <input type="number" id="width" min="1" placeholder="(auto)" />
      </div>
      <div>
        <label for="height">üìè Output Height (px, blank = auto)</label>
        <input type="number" id="height" min="1" placeholder="(auto)" />
      </div>
    </div>

    <div class="row">
      <div>
        <label for="quality">üé® WebM Quality (kbps)</label>
        <input type="range" id="quality" min="500" max="8000" value="4000" />
        <small id="qualityVal">4000 kbps</small>
      </div>
      <div>
        <label for="codec">üéõÔ∏è Codec</label>
        <select id="codec">
          <option value="video/webm;codecs=vp9">VP9 (better)</option>
          <option value="video/webm;codecs=vp8">VP8 (compat)</option>
          <option value="video/webm">Auto</option>
        </select>
      </div>
    </div>

    <div class="row" id="gifRow" style="display:flex;">
      <div>
        <label for="gifQuality">üéûÔ∏è GIF Quality (1=best/large, 30=small/lossy)</label>
        <input type="range" id="gifQuality" min="1" max="30" value="10" />
        <small id="gifQualityVal">10 (default)</small>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Selected Files</label>
        <div id="list" class="list">None yet.</div>
      </div>
    </div>

    <div class="btn-row">
      <button class="btn" id="makeBtn" style="flex:1;">‚ö° Make WebM</button>
      <button class="btn secondary" id="makeGifBtn" style="flex:1;">üéûÔ∏è Make GIF</button>
      <button class="btn cancel-btn" id="cancelBtn" style="display:none;">‚èπÔ∏è Stop</button>
    </div>

    <label>Progress</label>
    <progress id="prog" max="100" value="0"></progress>
    <div id="status" class="small" style="margin-top:6px;">Idle.</div>

    <video id="preview" autoplay muted playsinline controls style="display:none"></video>
    <img id="gifPreview" style="display:none;" alt="GIF Preview" />
    <div id="dlWrap" style="margin-top:10px; display:none;">
      <div class="btn-row">
        <a id="download" class="btn" download="out.webm">‚¨áÔ∏è Download</a>
      </div>
    </div>
  </div>

  <script>
    // PWA Service Worker (stub for offline/install)
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('data:text/javascript;base64,' + btoa(`
        self.addEventListener('install', e => e.waitUntil(caches.open('v1').then(c => c.addAll(['/', 'index.html']))));
        self.addEventListener('fetch', e => e.respondWith(caches.match(e.request).then(r => r || fetch(e.request))));
      `));
    }

    const pickFolderBtn = document.getElementById('pickFolderBtn');
    const pickFilesBtn  = document.getElementById('pickFilesBtn');
    const pickFolderCompatBtn = document.getElementById('pickFolderCompat');
    const folderCompat = document.getElementById('folderCompat');
    const fileInput     = document.getElementById('fileInput');
    const videoInput    = document.getElementById('videoInput');
    const pickVideoBtn  = document.getElementById('pickVideoBtn');
    const listEl        = document.getElementById('list');
    const makeBtn       = document.getElementById('makeBtn');
    const makeGifBtn    = document.getElementById('makeGifBtn');
    const cancelBtn     = document.getElementById('cancelBtn');
    const gifRow        = document.getElementById('gifRow');
    const fpsEl         = document.getElementById('fps');
    const durationEl    = document.getElementById('duration');
    const loopEl        = document.getElementById('loop');
    const wEl           = document.getElementById('width');
    const hEl           = document.getElementById('height');
    const scaleModeEl   = document.getElementById('scaleMode');
    const qualityEl     = document.getElementById('quality');
    const qualityValEl  = document.getElementById('qualityVal');
    const gifQualityEl  = document.getElementById('gifQuality');
    const gifQualityValEl = document.getElementById('gifQualityVal');
    const codecEl       = document.getElementById('codec');
    const prog          = document.getElementById('prog');
    const statusEl      = document.getElementById('status');
    const preview       = document.getElementById('preview');
    const gifPreview    = document.getElementById('gifPreview');
    const downloadA     = document.getElementById('download');
    const dlWrap        = document.getElementById('dlWrap');
    const capsBanner    = document.getElementById('capsBanner');

    let imageFiles = [];     // File[]
    let bitmaps    = [];     // ImageBitmap[]
    let naturalW = null, naturalH = null;
    let lastCanvasW = null, lastCanvasH = null, lastMime = null;
    let isVideoMode = false;
    let videoElement = null; // Hidden video for frame extraction
    let originalVideoFps = 30; // Default fallback
    let lastOutputType = null; // 'webm' or 'gif'
    let lastOutputUrl = null; // For cleanup
    let canceled = false; // For cancel button

    // Device capabilities probe
    const caps = {
      mediaRecorder: !!window.MediaRecorder,
      vp9: window.MediaRecorder?.isTypeSupported?.('video/webm;codecs=vp9'),
      vp8: window.MediaRecorder?.isTypeSupported?.('video/webm;codecs=vp8'),
      deviceMemory: navigator.deviceMemory || 4, // Fallback to 4GB
      hardwareConcurrency: navigator.hardwareConcurrency || 4
    };
    const lowEnd = caps.deviceMemory <= 4;
    capsBanner.innerHTML = `WebM ${caps.vp9 ? 'VP9' : caps.vp8 ? 'VP8' : '‚ùå'} | GIF ‚úÖ | RAM: ${lowEnd ? 'Low (capped for stability)' : 'High'}`;

    // Presets
    const presets = {
      tiny: { width: 480, fps: 6, quality: 1500 },
      balanced: { width: 720, fps: 10, quality: 4000 },
      hq: { width: 1080, fps: 15, quality: 6000 }
    };
    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.onclick = () => {
        const p = presets[btn.dataset.preset];
        if (lowEnd && p.width > 720) p.width = 720; // Cap low-end
        wEl.value = p.width;
        fpsEl.value = p.fps;
        qualityEl.value = p.quality;
        qualityValEl.textContent = `${p.quality} kbps`;
        hEl.value = ''; // Auto-height
      };
    });

    // Helpers
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const once = (el, ev) => new Promise(res => el.addEventListener(ev, res, { once: true }));

    async function seekTo(video, t) {
      const target = Math.min(Math.max(0, t), Math.max(0, video.duration - 0.001));
      if (Math.abs(video.currentTime - target) < 1e-4) return;
      video.currentTime = target;
      await once(video, 'seeked');
      await new Promise(requestAnimationFrame);
    }

    function pickMime(preferred) {
      if (preferred === 'video/webm;codecs=vp9' && caps.vp9) return 'video/webm;codecs=vp9';
      if (preferred === 'video/webm;codecs=vp8' && caps.vp8) return 'video/webm;codecs=vp8';
      return 'video/webm';
    }

    function drawFrame(ctx, source, outW, outH, mode) {
      if (mode === 'fit') {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, outW, outH);
      }

      const iw = source.width || source.videoWidth;
      const ih = source.height || source.videoHeight;
      let sx = 0, sy = 0, sw = iw, sh = ih;
      let dx = 0, dy = 0, dw = outW, dh = outH;

      if (mode === 'fit') {
        const ratio = Math.min(outW / iw, outH / ih);
        dw = iw * ratio;
        dh = ih * ratio;
        dx = (outW - dw) / 2;
        dy = (outH - dh) / 2;
      } else if (mode === 'crop') {
        const ratio = Math.max(outW / iw, outH / ih);
        sx = (iw - (outW / ratio)) / 2;
        sy = (ih - (outH / ratio)) / 2;
        sw = outW / ratio;
        sh = outH / ratio;
        dw = outW;
        dh = outH;
      } else if (mode === 'stretch') {
        // Full stretch
      }

      ctx.drawImage(source, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    function getEffectiveFps() {
      const val = parseInt(fpsEl.value);
      if (isNaN(val) || val < 1 || val > 30) return isVideoMode ? originalVideoFps : 3; // Clamp 1-30
      return val;
    }

    function showPreview(type, url) {
      if (lastOutputUrl) URL.revokeObjectURL(lastOutputUrl);
      lastOutputUrl = url;
      preview.style.display = 'none';
      gifPreview.style.display = 'none';
      if (type === 'webm') {
        preview.src = url;
        preview.loop = loopEl.checked;
        preview.style.display = 'block';
      } else if (type === 'gif') {
        gifPreview.src = url;
        gifPreview.style.display = 'block';
      }
      dlWrap.style.display = 'block';
      downloadA.href = url;
      downloadA.download = `out.${type}`;
    }

    function cleanupBitmaps() {
      bitmaps.forEach(bm => bm.close?.());
      bitmaps = [];
    }

    function cancel() {
      canceled = true;
      status('Stopped.');
      prog.value = 0;
      cancelBtn.style.display = 'none';
    }

    qualityEl.oninput = () => qualityValEl.textContent = qualityEl.value + ' kbps';
    gifQualityEl.oninput = () => gifQualityValEl.textContent = gifQualityEl.value + ' (lower = better quality)';

    function naturalSort(a, b) {
      const ax = [], bx = [];
      a.name.replace(/(\d+)|(\D+)/g, (_, $1, $2) => ax.push([$1 || Infinity, $2 || ""]));
      b.name.replace(/(\d+)|(\D+)/g, (_, $1, $2) => bx.push([$1 || Infinity, $2 || ""]));
      while (ax.length && bx.length) {
        const an = ax.shift(), bn = bx.shift();
        const nA = parseInt(an[0], 10), nB = parseInt(bn[0], 10);
        if (an[0] !== Infinity || bn[0] !== Infinity) {
          if (nA !== nB) return nA - nB;
        } else if (an[1] !== bn[1]) {
          return an[1] > bn[1] ? 1 : -1;
        }
      }
      return ax.length - bx.length;
    }

    function showList() {
      if (!imageFiles.length) { listEl.textContent = "None yet."; return; }
      const lines = imageFiles.map(f => f.name).slice(0, 50);
      listEl.innerHTML = lines.map(s => `<div>${s}</div>`).join("") + (imageFiles.length>50 ? `<div>‚Ä¶ +${imageFiles.length-50} more</div>`:"");
    }

    async function pickFolder() {
      try {
        const dir = await window.showDirectoryPicker();
        const files = [];
        for await (const entry of dir.values()) {
          if (entry.kind === "file" && /\.(png|jpe?g|webp)$/i.test(entry.name)) {
            files.push(await entry.getFile());
          }
        }
        files.sort(naturalSort);
        setImages(files);
      } catch (e) {
        if (e && e.name !== 'AbortError') console.error(e);
      }
    }

    function setImages(files) {
      imageFiles = files;
      isVideoMode = false;
      if (videoElement) {
        if (videoElement.__objectURL) URL.revokeObjectURL(videoElement.__objectURL);
        videoElement.remove();
        videoElement = null;
      }
      showList();
      bitmaps = []; naturalW = null; naturalH = null;
      gifRow.style.display = 'flex';
      fpsEl.placeholder = '(auto: 3)';
      status(`Loaded ${files.length} image(s).`);
    }

    pickFolderBtn.onclick = pickFolder;
    pickFilesBtn.onclick = () => fileInput.click();
    pickFolderCompatBtn.onclick = () => folderCompat.click();
    fileInput.onchange = () => {
      const files = Array.from(fileInput.files).filter(f => /\.(png|jpe?g|webp)$/i.test(f.name));
      files.sort(naturalSort);
      setImages(files);
    };
    folderCompat.onchange = () => {
      const files = Array.from(folderCompat.files).filter(f => /\.(png|jpe?g|webp)$/i.test(f.name));
      files.sort(naturalSort);
      setImages(files);
    };

    pickVideoBtn.onclick = () => videoInput.click();
    videoInput.onchange = async () => {
      const file = videoInput.files[0];
      if (!file) return;
      if (videoElement) {
        if (videoElement.__objectURL) URL.revokeObjectURL(videoElement.__objectURL);
        videoElement.remove();
      }
      imageFiles = [file];
      isVideoMode = true;
      showList();
      bitmaps = []; naturalW = null; naturalH = null;
      gifRow.style.display = 'flex';
      fpsEl.placeholder = '(auto: source)';
      status(`Loaded video: ${file.name} (${(file.size/1024/1024).toFixed(1)} MB)`);

      const videoUrl = URL.createObjectURL(file);
      videoElement = document.createElement('video');
      videoElement.preload = 'auto';
      videoElement.muted = true;
      videoElement.playsInline = true;
      videoElement.src = videoUrl;
      videoElement.style.display = 'none';
      document.body.appendChild(videoElement);

      await once(videoElement, 'loadedmetadata');
      naturalW = videoElement.videoWidth;
      naturalH = videoElement.videoHeight;
      wEl.placeholder = String(naturalW);
      hEl.placeholder = String(naturalH);

      originalVideoFps = 30;
      if ('webkitDecodedFrameCount' in videoElement) {
        await videoElement.play();
        await sleep(1000);
        const frames = videoElement.webkitDecodedFrameCount || 30;
        originalVideoFps = Math.round(frames);
        videoElement.pause();
        videoElement.currentTime = 0;
      }

      videoElement.__objectURL = videoUrl;
    };

    function status(msg) { statusEl.textContent = msg; }

    async function loadBitmaps() {
      if (!imageFiles.length) throw new Error("No files selected.");
      bitmaps = [];
      canceled = false;
      cancelBtn.style.display = 'inline-block';
      const effectiveFps = getEffectiveFps();
      const inputDuration = parseFloat(durationEl.value);
      let extractDuration = inputDuration;
      if (isVideoMode && videoElement && !inputDuration) {
        extractDuration = videoElement.duration;
      }
      if (isVideoMode && videoElement) {
        const frameInterval = 1 / effectiveFps;
        const totalFrames = Math.min(Math.ceil(extractDuration / frameInterval), 1500); // Hard limit
        let tip = '';
        if (totalFrames > 300) {
          tip = ' (Tip: For long videos, try lower FPS or shorter duration to save RAM)';
        }
        status(`Extracting ${totalFrames} frames from video @ ${effectiveFps} fps (duration: ${extractDuration.toFixed(1)}s)${tip}‚Ä¶`);

        const grab = document.createElement('canvas');
        grab.width = videoElement.videoWidth;
        grab.height = videoElement.videoHeight;
        const gctx = grab.getContext('2d', { willReadFrequently: true });

        for (let i = 0; i < totalFrames; i++) {
          if (canceled) throw new Error('Canceled');
          if (i % 30 === 0) await new Promise(requestAnimationFrame); // Micro-break
          await seekTo(videoElement, i * frameInterval);
          gctx.drawImage(videoElement, 0, 0);
          const bm = await createImageBitmap(grab);
          bitmaps.push(bm);
          prog.value = Math.round(((i + 1) / totalFrames) * 30);
        }

        if (videoElement.__objectURL) {
          URL.revokeObjectURL(videoElement.__objectURL);
          delete videoElement.__objectURL;
        }
      } else {
        for (let i=0; i<imageFiles.length; i++) {
          if (canceled) throw new Error('Canceled');
          const bm = await createImageBitmap(imageFiles[i]);
          bitmaps.push(bm);
          if (!naturalW) { naturalW = bm.width; naturalH = bm.height; wEl.placeholder = String(naturalW); hEl.placeholder = "(auto)"; }
          prog.value = Math.round(((i+1)/imageFiles.length)*30);
        }
        extractDuration = inputDuration || (bitmaps.length / effectiveFps);
      }
      cancelBtn.style.display = 'none';
    }

    async function makeWebM() {
      try {
        prog.value = 0; 
        canceled = false;
        cancelBtn.style.display = 'inline-block';
        status("Preparing‚Ä¶");
        await loadBitmaps();
        const fps = getEffectiveFps();
        const inputDuration = parseFloat(durationEl.value);
        let duration = inputDuration;
        if (!duration) duration = isVideoMode ? videoElement?.duration || (bitmaps.length / fps) : bitmaps.length / fps;
        let totalFrames;
        if (isVideoMode) {
          totalFrames = bitmaps.length;
        } else {
          totalFrames = Math.ceil(fps * duration);
        }
        const loop = loopEl.checked;
        let outW = parseInt(wEl.value, 10);
        let outH = parseInt(hEl.value, 10);
        if (!outW && !outH) { outW = naturalW; outH = naturalH; }
        else if (outW && !outH) { outH = Math.round(naturalH * (outW / naturalW)); }
        else if (!outW && outH) { outW = Math.round(naturalW * (outH / naturalH)); }

        const canvas = document.createElement('canvas');
        canvas.width = outW; canvas.height = outH;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        lastCanvasW = outW;
        lastCanvasH = outH;

        const stream = canvas.captureStream(fps);
        const preferred = codecEl.value;
        const mime = pickMime(preferred);
        lastMime = mime;
        const bitrate = parseInt(qualityEl.value);
        const rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: bitrate * 1000 });
        const chunks = [];
        rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };

        rec.start(200);
        status(`Rendering ${totalFrames} frame(s) @ ${fps} fps‚Ä¶`);
        const frameDur = 1000 / fps;
        let i = 0;
        const timer = setInterval(() => {
          if (canceled || i >= totalFrames) {
            clearInterval(timer);
            if (rec.state === 'recording') rec.stop();
            return;
          }
          if (i % 30 === 0) requestAnimationFrame(() => {}); // Yield
          const frameIdx = loop ? (i % bitmaps.length) : Math.min(i, bitmaps.length - 1);
          ctx.clearRect(0, 0, outW, outH);
          drawFrame(ctx, bitmaps[frameIdx], outW, outH, scaleModeEl.value);
          prog.value = 30 + Math.round((i / totalFrames) * 70);
          i++;
        }, frameDur);

        await new Promise(resolve => rec.addEventListener('stop', resolve, { once: true }));

        const webmBlob = new Blob(chunks, { type: mime });
        const url = URL.createObjectURL(webmBlob);
        showPreview('webm', url);
        lastOutputType = 'webm';
        cleanupBitmaps();
        prog.value = 100;
        status(`WebM done (${mime}) @ ${fps} fps. ${(webmBlob.size/1024/1024).toFixed(2)} MB`);
      } catch (err) {
        if (err.message === 'Canceled') return;
        console.error(err);
        status("Error: " + (err && err.message ? err.message : err));
      } finally {
        cancelBtn.style.display = 'none';
        canceled = false;
      }
    }

    async function makeGIF() {
      prog.value = 0;
      canceled = false;
      cancelBtn.style.display = 'inline-block';
      if (!bitmaps.length) await loadBitmaps();
      if (typeof GIF === 'undefined') { alert('GIF library failed to load.'); return; }
      try {
        status("Loading GIF worker‚Ä¶");
        const workerResponse = await fetch('https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js');
        if (!workerResponse.ok) throw new Error('Worker fetch failed');
        const workerBlob = await workerResponse.blob();
        const workerURL = URL.createObjectURL(workerBlob);

        const fps = getEffectiveFps();
        const inputDuration = parseFloat(durationEl.value);
        let duration = inputDuration;
        if (!duration) duration = bitmaps.length / fps;
        const totalFrames = Math.ceil(fps * duration);
        const loop = loopEl.checked;
        let outW = parseInt(wEl.value, 10);
        let outH = parseInt(hEl.value, 10);
        if (!outW && !outH) { outW = naturalW; outH = naturalH; }
        else if (outW && !outH) { outH = Math.round(naturalH * (outW / naturalW)); }
        else if (!outW && outH) { outW = Math.round(naturalW * (outH / naturalH)); }
        const gifQual = Math.max(1, parseInt(gifQualityEl.value, 10) || 10);

        const framesToUse = Math.min(totalFrames, bitmaps.length);
        const frameDelay = Math.round(1000 / fps);

        status(`Generating GIF‚Ä¶ (quality=${gifQual}, ${framesToUse} frames @ ${fps} fps, duration: ${duration.toFixed(1)}s)`);
        const gif = new GIF({
          workers: Math.min(4, caps.hardwareConcurrency),
          quality: gifQual,
          width: outW,
          height: outH,
          workerScript: workerURL,
          background: '#000000',
          repeat: loop ? 0 : -1,
          optimize: true
        });

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = outW; tempCanvas.height = outH;
        const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

        for (let i = 0; i < framesToUse; i++) {
          if (canceled) throw new Error('Canceled');
          if (i % 30 === 0) await new Promise(requestAnimationFrame);
          const frameIdx = loop ? (i % bitmaps.length) : i;
          tempCtx.clearRect(0, 0, outW, outH);
          drawFrame(tempCtx, bitmaps[frameIdx], outW, outH, scaleModeEl.value);
          gif.addFrame(tempCanvas, { delay: frameDelay, copy: true });
          prog.value = Math.round((i / framesToUse) * 70);
        }

        gif.on('finished', blob => {
          const url = URL.createObjectURL(blob);
          showPreview('gif', url);
          lastOutputType = 'gif';
          URL.revokeObjectURL(workerURL);
          cleanupBitmaps();
          prog.value = 100;
          status(`GIF done (q=${gifQual}) @ ${fps} fps. ${(blob.size/1024/1024).toFixed(2)} MB`);
        });

        gif.on('progress', p => { 
          prog.value = 70 + Math.round(p * 30); 
        });
        gif.render();
      } catch (err) {
        if (err.message === 'Canceled') return;
        console.error(err);
        status("GIF Error: " + (err && err.message ? err.message : err));
      } finally {
        cancelBtn.style.display = 'none';
        canceled = false;
      }
    }

    makeBtn.onclick = makeWebM;
    makeGifBtn.onclick = makeGIF;
    cancelBtn.onclick = cancel;
  </script>
</body>
</html>