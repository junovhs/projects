<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Images/Video ‚Üí WebM (Browser-Only)</title>
  <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.min.js"></script>
  <style>
    body {
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #e0eafc, #cfdef3);
      margin: 0; padding: 0; min-height: 100vh;
      display: flex; justify-content: center; align-items: flex-start; padding-top: 40px;
    }
    .container {
      background: #fff; padding: 30px 40px; border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.1);
      max-width: 760px; width: 92%; animation: fadeIn 0.6s ease-in-out;
    }
    h1 { text-align: center; margin: 0 0 10px; font-size: 1.8rem; color: #2c3e50; }
    p  { text-align: center; color: #555; margin: 0 0 18px; }
    label { display:block; margin: 14px 0 6px; font-weight:600; color:#333; }
    input[type="number"], input[type="text"], select {
      width:100%; padding:12px 14px; font-size:1rem; border:1px solid #ccc; border-radius:8px; box-sizing:border-box;
      transition: border .3s ease, box-shadow .3s ease;
    }
    input[type="range"] { width:100%; margin: 8px 0; }
    input:focus, select:focus { border-color:#3498db; box-shadow:0 0 6px rgba(52,152,219,.4); outline:none; }
    .row { display:flex; gap:12px; }
    .row > div { flex:1; }
    .btn {
      display:inline-block; padding:12px 16px; border:none; border-radius:8px; cursor:pointer;
      background: linear-gradient(135deg, #3498db, #2ecc71); color:#fff; font-weight:600;
      transition: transform .15s ease, box-shadow .2s ease;
    }
    .btn:hover { transform: translateY(-2px); box-shadow:0 6px 12px rgba(0,0,0,.15); }
    .btn.secondary { background: linear-gradient(135deg, #6c757d, #495057); }
    .btn-row { display:flex; gap:10px; flex-wrap:wrap; }
    .small { color:#666; font-size:.9rem; }
    .note, .warn {
      border-radius:8px; padding:12px 14px; margin:14px 0; font-size:.95rem;
    }
    .note  { background:#d1ecf1; border:1px solid #bee5eb; color:#0c5460; }
    .warn  { background:#fff3cd; border:1px solid #ffeaa7; color:#856404; }
    video { width:100%; margin-top:14px; border-radius:8px; background:#000; }
    progress { width:100%; height:12px; }
    .list { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#f8f9fa; border:1px solid #e1e5ea; border-radius:8px; padding:10px; max-height:120px; overflow:auto; }
    @keyframes fadeIn { from {opacity:0; transform:translateY(10px);} to {opacity:1; transform:translateY(0);} }
  </style>
</head>
<body>
  <div class="container">
    <h1>üñºÔ∏è Images/Video ‚Üí WebM</h1>
    <p>Pick a folder/files/video, set <strong>FPS</strong> (default 3 for images, source for video), and make a looping WebM (GIF replacement). All client-side!</p>

    <div class="btn-row">
      <button class="btn" id="pickFolderBtn">üìÅ Pick Folder</button>
      <input type="file" id="fileInput" accept="image/*" multiple style="display:none" />
      <button class="btn secondary" id="pickFilesBtn">üñºÔ∏è Select Images</button>
      <input type="file" id="folderCompat" webkitdirectory directory multiple accept="image/*" style="display:none" />
      <button class="btn secondary" id="pickFolderCompat">üìÅ Pick Folder (compat)</button>
      <input type="file" id="videoInput" accept="video/*" style="display:none" />
      <button class="btn secondary" id="pickVideoBtn">üé• Upload Video</button>
    </div>

    <div class="note small">
      Tip: Files sorted naturally. Videos auto-extract frames at FPS. Mixed OK‚Äîresized consistently.
    </div>

    <div class="row">
      <div>
        <label for="fps">‚è±Ô∏è Frame Rate (fps)</label>
        <input type="number" id="fps" min="1" value="" placeholder="(auto)" />
      </div>
      <div>
        <label for="duration">‚è≥ Duration (s, blank = full)</label>
        <input type="number" id="duration" min="0.1" step="0.1" placeholder="(auto)" />
      </div>
      <div>
        <label><input type="checkbox" id="loop" checked> üîÑ Loop</label>
      </div>
    </div>

    <div class="row">
      <div>
        <label for="width">üìê Output Width (px, blank = source)</label>
        <input type="number" id="width" min="1" placeholder="(auto)" />
      </div>
      <div>
        <label for="height">üìè Output Height (px, blank = auto)</label>
        <input type="number" id="height" min="1" placeholder="(auto)" />
      </div>
      <div>
        <label for="scaleMode">üñºÔ∏è Scale Mode</label>
        <select id="scaleMode">
          <option value="fit">Fit (letterbox)</option>
          <option value="crop">Crop</option>
          <option value="stretch">Stretch</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label for="quality">üé® WebM Quality (kbps)</label>
        <input type="range" id="quality" min="500" max="8000" value="4000" />
        <small id="qualityVal">4000 kbps</small>
      </div>
      <div>
        <label for="filter">üåà Filter</label>
        <select id="filter">
          <option value="none">None</option>
          <option value="grayscale">B&W</option>
          <option value="sepia">Vintage</option>
        </select>
      </div>
      <div>
        <label for="codec">üéõÔ∏è Codec</label>
        <select id="codec">
          <option value="video/webm;codecs=vp9">VP9 (better)</option>
          <option value="video/webm;codecs=vp8">VP8 (compat)</option>
          <option value="video/webm">Auto</option>
        </select>
      </div>
    </div>

    <div class="row" id="gifRow" style="display:flex;">
      <div>
        <label for="gifQuality">üéûÔ∏è GIF Quality (1=best/large, 30=small/lossy)</label>
        <input type="range" id="gifQuality" min="1" max="30" value="5" />
        <small id="gifQualityVal">5 (lower = better quality)</small>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Selected Files</label>
        <div id="list" class="list">None yet.</div>
      </div>
    </div>

    <div class="btn-row">
      <button class="btn" id="makeBtn" style="flex:1;">‚ö° Make WebM</button>
      <button class="btn secondary" id="makeGifBtn" style="flex:1;">üéûÔ∏è Make GIF</button>
    </div>

    <label>Progress</label>
    <progress id="prog" max="100" value="0"></progress>
    <div id="status" class="small" style="margin-top:6px;">Idle.</div>

    <video id="preview" autoplay muted playsinline controls style="display:none"></video>
    <div id="dlWrap" style="margin-top:10px; display:none;">
      <div class="btn-row">
        <a id="download" class="btn" download="out.webm">‚¨áÔ∏è Download WebM</a>
        <button class="btn secondary" id="toGifFromWebmBtn">üéûÔ∏è To GIF</button>
      </div>
    </div>
  </div>

  <script>
    const pickFolderBtn = document.getElementById('pickFolderBtn');
    const pickFilesBtn  = document.getElementById('pickFilesBtn');
    const pickFolderCompatBtn = document.getElementById('pickFolderCompat');
    const folderCompat = document.getElementById('folderCompat');
    const fileInput     = document.getElementById('fileInput');
    const videoInput    = document.getElementById('videoInput');
    const pickVideoBtn  = document.getElementById('pickVideoBtn');
    const listEl        = document.getElementById('list');
    const makeBtn       = document.getElementById('makeBtn');
    const makeGifBtn    = document.getElementById('makeGifBtn');
    const toGifFromWebmBtn = document.getElementById('toGifFromWebmBtn');
    const gifRow        = document.getElementById('gifRow');
    const fpsEl         = document.getElementById('fps');
    const durationEl    = document.getElementById('duration');
    const loopEl        = document.getElementById('loop');
    const wEl           = document.getElementById('width');
    const hEl           = document.getElementById('height');
    const scaleModeEl   = document.getElementById('scaleMode');
    const qualityEl     = document.getElementById('quality');
    const qualityValEl  = document.getElementById('qualityVal');
    const gifQualityEl  = document.getElementById('gifQuality');
    const gifQualityValEl = document.getElementById('gifQualityVal');
    const filterEl      = document.getElementById('filter');
    const codecEl       = document.getElementById('codec');
    const prog          = document.getElementById('prog');
    const statusEl      = document.getElementById('status');
    const preview       = document.getElementById('preview');
    const downloadA     = document.getElementById('download');
    const dlWrap        = document.getElementById('dlWrap');

    let imageFiles = [];     // File[]
    let bitmaps    = [];     // ImageBitmap[]
    let naturalW = null, naturalH = null;
    let lastCanvasW = null, lastCanvasH = null, lastMime = null;
    let isVideoMode = false;
    let videoElement = null; // Hidden video for frame extraction
    let originalVideoFps = 30; // Default fallback

    // Helpers
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const once = (el, ev) => new Promise(res => el.addEventListener(ev, res, { once: true }));

    async function seekTo(video, t) {
      const target = Math.min(Math.max(0, t), Math.max(0, video.duration - 0.001));
      if (Math.abs(video.currentTime - target) < 1e-4) return;
      video.currentTime = target;
      await once(video, 'seeked');
      await new Promise(requestAnimationFrame); // ensure the frame is actually painted
    }

    function pickMime(preferred) {
      if (preferred === 'video/webm;codecs=vp9' && MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
        return 'video/webm;codecs=vp9';
      }
      if (preferred === 'video/webm;codecs=vp8' && MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
        return 'video/webm;codecs=vp8';
      }
      return 'video/webm';
    }

    function drawFrame(ctx, bitmap, outW, outH, mode) {
      // Fill background black for letterboxing
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, outW, outH);

      const iw = bitmap.width;
      const ih = bitmap.height;
      let sx = 0, sy = 0, sw = iw, sh = ih;
      let dx = 0, dy = 0, dw = outW, dh = outH;

      if (mode === 'fit') {
        const ratio = Math.min(outW / iw, outH / ih);
        dw = iw * ratio;
        dh = ih * ratio;
        dx = (outW - dw) / 2;
        dy = (outH - dh) / 2;
      } else if (mode === 'crop') {
        const ratio = Math.max(outW / iw, outH / ih);
        sw = iw;
        sh = ih;
        sx = (iw - (outW / ratio)) / 2;
        sy = (ih - (outH / ratio)) / 2;
        sw = outW / ratio;
        sh = outH / ratio;
        dw = outW;
        dh = outH;
      } else if (mode === 'stretch') {
        // Full stretch, no change to sx/sy/sw/sh
      }

      ctx.drawImage(bitmap, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    function applyFilter(ctx, w, h, filter) {
      const imageData = ctx.getImageData(0, 0, w, h);
      const data = imageData.data;

      if (filter === 'grayscale') {
        for (let i = 0; i < data.length; i += 4) {
          const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
          data[i] = data[i + 1] = data[i + 2] = avg;
        }
      } else if (filter === 'sepia') {
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i], g = data[i + 1], b = data[i + 2];
          data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
          data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
          data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
        }
      }

      ctx.putImageData(imageData, 0, 0);
    }

    function getEffectiveFps() {
      const val = parseInt(fpsEl.value);
      if (isNaN(val) || val < 1) {
        return isVideoMode ? originalVideoFps : 3;
      }
      return val;
    }

    qualityEl.oninput = () => qualityValEl.textContent = qualityEl.value + ' kbps';
    gifQualityEl.oninput = () => gifQualityValEl.textContent = gifQualityEl.value + ' (lower = better quality)';

    function naturalSort(a, b) {
      const ax = [], bx = [];
      a.name.replace(/(\d+)|(\D+)/g, (_, $1, $2) => ax.push([$1 || Infinity, $2 || ""]));
      b.name.replace(/(\d+)|(\D+)/g, (_, $1, $2) => bx.push([$1 || Infinity, $2 || ""]));
      while (ax.length && bx.length) {
        const an = ax.shift(), bn = bx.shift();
        const nA = parseInt(an[0], 10), nB = parseInt(bn[0], 10);
        if (an[0] !== Infinity || bn[0] !== Infinity) {
          if (nA !== nB) return nA - nB;
        } else if (an[1] !== bn[1]) {
          return an[1] > bn[1] ? 1 : -1;
        }
      }
      return ax.length - bx.length;
    }

    function showList() {
      if (!imageFiles.length) { listEl.textContent = "None yet."; return; }
      const lines = imageFiles.map(f => f.name).slice(0, 50);
      listEl.innerHTML = lines.map(s => `<div>${s}</div>`).join("") + (imageFiles.length>50 ? `<div>‚Ä¶ +${imageFiles.length-50} more</div>`:"");
    }

    async function pickFolder() {
      try {
        const dir = await window.showDirectoryPicker();
        const files = [];
        for await (const entry of dir.values()) {
          if (entry.kind === "file" && /\.(png|jpe?g|webp)$/i.test(entry.name)) {
            files.push(await entry.getFile());
          }
        }
        files.sort(naturalSort);
        setImages(files);
      } catch (e) {
        if (e && e.name !== 'AbortError') console.error(e);
      }
    }

    function setImages(files) {
      imageFiles = files;
      isVideoMode = false;
      if (videoElement) {
        if (videoElement.__objectURL) URL.revokeObjectURL(videoElement.__objectURL);
        videoElement.remove();
        videoElement = null;
      }
      showList();
      bitmaps = []; naturalW = null; naturalH = null;
      gifRow.style.display = 'flex';
      fpsEl.placeholder = '(auto: 3)';
      status(`Loaded ${files.length} image(s).`);
    }

    pickFolderBtn.onclick = pickFolder;
    pickFilesBtn.onclick = () => fileInput.click();
    pickFolderCompatBtn.onclick = () => folderCompat.click();
    fileInput.onchange = () => {
      const files = Array.from(fileInput.files).filter(f => /\.(png|jpe?g|webp)$/i.test(f.name));
      files.sort(naturalSort);
      setImages(files);
    };
    folderCompat.onchange = () => {
      const files = Array.from(folderCompat.files).filter(f => /\.(png|jpe?g|webp)$/i.test(f.name));
      files.sort(naturalSort);
      setImages(files);
    };

    pickVideoBtn.onclick = () => videoInput.click();
    videoInput.onchange = async () => {
      const file = videoInput.files[0];
      if (!file) return;
      if (videoElement) {
        if (videoElement.__objectURL) URL.revokeObjectURL(videoElement.__objectURL);
        videoElement.remove();
      }
      imageFiles = [file];
      isVideoMode = true;
      showList();
      bitmaps = []; naturalW = null; naturalH = null;
      gifRow.style.display = 'flex';
      fpsEl.placeholder = '(auto: source)';
      status(`Loaded video: ${file.name} (${(file.size/1024/1024).toFixed(1)} MB)`);

      // Hidden video element
      const videoUrl = URL.createObjectURL(file);
      videoElement = document.createElement('video');
      videoElement.preload = 'auto';
      videoElement.muted = true;
      videoElement.playsInline = true;
      videoElement.src = videoUrl;
      videoElement.style.display = 'none';
      document.body.appendChild(videoElement);

      await once(videoElement, 'loadedmetadata');
      naturalW = videoElement.videoWidth;
      naturalH = videoElement.videoHeight;
      wEl.placeholder = String(naturalW);
      hEl.placeholder = String(naturalH);

      // Approximate original FPS (fallback to 30; real detection is complex)
      originalVideoFps = 30; // Could enhance with webkitDecodedFrameCount if available
      if ('webkitDecodedFrameCount' in videoElement) {
        // Play briefly to count frames (hacky but works for approx)
        await videoElement.play();
        await sleep(1000);
        const frames = videoElement.webkitDecodedFrameCount || 30;
        originalVideoFps = Math.round(frames);
        videoElement.pause();
        videoElement.currentTime = 0;
      }

      videoElement.__objectURL = videoUrl;
    };

    function status(msg) { statusEl.textContent = msg; }

    async function loadBitmaps() {
      if (!imageFiles.length) throw new Error("No files selected.");
      bitmaps = [];
      const effectiveFps = getEffectiveFps();
      if (isVideoMode && videoElement) {
        const frameInterval = 1 / effectiveFps;
        const duration = parseFloat(durationEl.value) || videoElement.duration;
        const totalFrames = Math.ceil(duration / frameInterval);
        status(`Extracting ${totalFrames} frames from video @ ${effectiveFps} fps‚Ä¶`);

        // One offscreen canvas is enough
        const grab = document.createElement('canvas');
        grab.width = videoElement.videoWidth;
        grab.height = videoElement.videoHeight;
        const gctx = grab.getContext('2d', { willReadFrequently: true });

        for (let i = 0; i < totalFrames; i++) {
          await seekTo(videoElement, i * frameInterval);
          gctx.drawImage(videoElement, 0, 0);
          const bm = await createImageBitmap(grab);
          bitmaps.push(bm);
          prog.value = Math.round(((i + 1) / totalFrames) * 30);
        }

        // Clean up the video object URL now that frames are extracted
        if (videoElement.__objectURL) {
          URL.revokeObjectURL(videoElement.__objectURL);
          delete videoElement.__objectURL;
        }
      } else {
        // Original image load
        for (let i=0; i<imageFiles.length; i++) {
          const bm = await createImageBitmap(imageFiles[i]);
          bitmaps.push(bm);
          if (!naturalW) { naturalW = bm.width; naturalH = bm.height; wEl.placeholder = String(naturalW); hEl.placeholder = "(auto)"; }
          prog.value = Math.round(((i+1)/imageFiles.length)*30);
        }
      }
    }

    async function makeWebM() {
      try {
        prog.value = 0; 
        if (preview.src) URL.revokeObjectURL(preview.src);
        preview.style.display = "none"; 
        dlWrap.style.display = "none";
        status("Preparing‚Ä¶");
        await loadBitmaps();
        const fps = getEffectiveFps();
        let duration = parseFloat(durationEl.value);
        if (!duration) duration = isVideoMode ? videoElement?.duration || (bitmaps.length / fps) : bitmaps.length / fps;
        const totalFrames = Math.ceil(fps * duration);
        const loop = loopEl.checked;
        let outW = parseInt(wEl.value, 10);
        let outH = parseInt(hEl.value, 10);
        if (!outW && !outH) { outW = naturalW; outH = naturalH; }
        else if (outW && !outH) { outH = Math.round(naturalH * (outW / naturalW)); }
        else if (!outW && outH) { outW = Math.round(naturalW * (outH / naturalH)); }

        const canvas = document.createElement('canvas');
        canvas.width = outW; canvas.height = outH;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        lastCanvasW = outW;
        lastCanvasH = outH;

        const stream = canvas.captureStream(fps);
        const preferred = codecEl.value;
        const mime = pickMime(preferred);
        lastMime = mime;
        const bitrate = parseInt(qualityEl.value);
        const rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: bitrate * 1000 });
        const chunks = [];
        rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
        let stopped = false;
        rec.onstop = () => { stopped = true; };

        rec.start(200);
        status(`Rendering ${totalFrames} frame(s) @ ${fps} fps‚Ä¶`);
        // Remove manual sleep; rely on captureStream(fps) for timing
        // Use requestAnimationFrame for smooth drawing
        let frameI = 0;
        function renderLoop() {
          if (frameI >= totalFrames || rec.state !== 'recording') return;
          const frameIdx = loop ? (frameI % bitmaps.length) : frameI;
          if (frameIdx >= bitmaps.length) {
            rec.stop();
            return;
          }
          ctx.clearRect(0, 0, outW, outH);
          drawFrame(ctx, bitmaps[frameIdx], outW, outH, scaleModeEl.value);
          applyFilter(ctx, outW, outH, filterEl.value);
          prog.value = 30 + Math.round((frameI / totalFrames) * 70);
          frameI++;
          requestAnimationFrame(renderLoop);
        }
        renderLoop();

        const waitStop = () => new Promise(res => {
          const check = () => stopped ? res() : setTimeout(check, 50);
          check();
        });

        // Wait a bit for final chunks
        await new Promise(r => setTimeout(r, Math.max(500, (totalFrames / fps) * 1000 + 500)));
        if (rec.state === 'recording') rec.stop();
        await waitStop();

        const webmBlob = new Blob(chunks, { type: mime });
        const url = URL.createObjectURL(webmBlob);
        preview.src = url;
        preview.loop = loop;
        preview.style.display = "block";
        downloadA.href = url;
        downloadA.download = "out.webm";
        dlWrap.style.display = "block";
        prog.value = 100;
        status(`WebM done (${mime}) @ ${fps} fps. ${(webmBlob.size/1024/1024).toFixed(2)} MB`);
      } catch (err) {
        console.error(err);
        status("Error: " + (err && err.message ? err.message : err));
      }
    }

    async function makeGIF(standalone = false) {
      if (!standalone && !bitmaps.length) { alert('Load files and generate WebM first for frame data.'); return; }
      if (typeof GIF === 'undefined') { alert('GIF library failed to load. Check console and refresh.'); return; }
      try {
        if (standalone) {
          prog.value = 0; 
          await loadBitmaps();
        }
        status("Loading GIF worker‚Ä¶");
        const workerResponse = await fetch('https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js');
        if (!workerResponse.ok) throw new Error('Worker fetch failed');
        const workerBlob = await workerResponse.blob();
        const workerURL = URL.createObjectURL(workerBlob);

        const fps = getEffectiveFps();
        let duration = parseFloat(durationEl.value);
        if (!duration) duration = bitmaps.length / fps;
        const totalFrames = Math.ceil(fps * duration);
        const loop = loopEl.checked;
        const outW = lastCanvasW || (parseInt(wEl.value,10) || naturalW || 480);
        const outH = lastCanvasH || (parseInt(hEl.value,10) || naturalH || 240);
        const gifQual = Math.max(1, parseInt(gifQualityEl.value, 10) || 5);

        status(`Generating GIF‚Ä¶ (quality=${gifQual}, ${totalFrames} frames @ ${fps} fps)`);
        const gif = new GIF({
          workers: 4,
          quality: gifQual,
          width: outW,
          height: outH,
          workerScript: workerURL,
          background: '#000000',
          repeat: loop ? 0 : -1
        });

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = outW; tempCanvas.height = outH;
        const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
        const frameDelay = Math.round(1000 / fps);

        for (let i = 0; i < totalFrames; i++) {
          const frameIdx = loop ? (i % bitmaps.length) : i;
          if (frameIdx >= bitmaps.length) break;
          tempCtx.clearRect(0, 0, outW, outH);
          drawFrame(tempCtx, bitmaps[frameIdx], outW, outH, scaleModeEl.value);
          applyFilter(tempCtx, outW, outH, filterEl.value);
          gif.addFrame(tempCanvas, { delay: frameDelay, copy: true });
          if (standalone) prog.value = Math.round((i / totalFrames) * 100);
        }

        gif.on('finished', blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = 'out.gif'; a.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(workerURL);
          status(`GIF done (q=${gifQual}) @ ${fps} fps. ${(blob.size/1024/1024).toFixed(2)} MB`);
          if (standalone) prog.value = 100;
        });

        gif.on('progress', p => { 
          if (standalone) prog.value = Math.round(p * 100); 
        });
        gif.render();
      } catch (err) {
        console.error(err);
        status("GIF Error: " + (err && err.message ? err.message : err));
      }
    }

    makeBtn.onclick = makeWebM;
    makeGifBtn.onclick = () => makeGIF(true); // Standalone mode
    toGifFromWebmBtn.onclick = () => makeGIF(false); // Reuse bitmaps
  </script>
</body>
</html>