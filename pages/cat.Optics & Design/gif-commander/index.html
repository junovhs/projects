<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Images/Video ‚Üí WebM (Browser-Only)</title>
  <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.min.js"></script>
  <meta name="theme-color" content="#3498db">
  <style>
    body {
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #e0eafc, #cfdef3);
      margin: 0; padding: 0; min-height: 100vh;
      display: flex; justify-content: center; align-items: flex-start; padding-top: 40px;
    }
    .container {
      background: #fff; padding: 30px 40px; border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.1);
      max-width: 760px; width: 92%; animation: fadeIn 0.6s ease-in-out;
    }
    h1 { text-align: center; margin: 0 0 10px; font-size: 1.8rem; color: #2c3e50; }
    p  { text-align: center; color: #555; margin: 0 0 18px; }
    label { display:block; margin: 14px 0 6px; font-weight:600; color:#333; }
    input[type="number"], input[type="text"], select {
      width:100%; padding:12px 14px; font-size:1rem; border:1px solid #ccc; border-radius:8px; box-sizing:border-box;
      transition: border .3s ease, box-shadow .3s ease;
    }
    input[type="range"] { width:100%; margin: 8px 0; }
    input:focus, select:focus { border-color:#3498db; box-shadow:0 0 6px rgba(52,152,219,.4); outline:none; }
    .row { display:flex; gap:12px; }
    .row > div { flex:1; }
    .btn {
      display:inline-block; padding:12px 16px; border:none; border-radius:8px; cursor:pointer;
      background: linear-gradient(135deg, #3498db, #2ecc71); color:#fff; font-weight:600;
      transition: transform .15s ease, box-shadow .2s ease;
    }
    .btn:hover { transform: translateY(-2px); box-shadow:0 6px 12px rgba(0,0,0,.15); }
    .btn.secondary { background: linear-gradient(135deg, #6c757d, #495057); }
    .btn-row { display:flex; gap:10px; flex-wrap:wrap; }
    .small { color:#666; font-size:.9rem; }
    .note, .warn {
      border-radius:8px; padding:12px 14px; margin:14px 0; font-size:.95rem;
    }
    .note  { background:#d1ecf1; border:1px solid #bee5eb; color:#0c5460; }
    .warn  { background:#fff3cd; border:1px solid #ffeaa7; color:#856404; }
    video, img { width:100%; margin-top:14px; border-radius:8px; background:#000; }
    progress { width:100%; height:12px; }
    .list { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#f8f9fa; border:1px solid #e1e5ea; border-radius:8px; padding:10px; max-height:120px; overflow:auto; }
    .preset-btn { padding: 8px 12px; font-size: 0.9rem; margin: 2px; border-radius: 6px; background: #f8f9fa; border: 1px solid #ddd; color: #333; cursor: pointer; }
    .preset-btn:hover { background: #e9ecef; }
    .cancel-btn { background: #dc3545; flex: none; padding: 8px 16px; font-size: 0.9rem; }
    .caps-banner { text-align: center; margin: 10px 0; font-size: 0.85rem; color: #666; }
    @keyframes fadeIn { from {opacity:0; transform:translateY(10px);} to {opacity:1; transform:translateY(0);} }
  </style>
</head>
<body>
  <div class="container">
    <h1>üñºÔ∏è Images/Video ‚Üí WebM</h1>
    <p>Pick a folder/files/video, set <strong>FPS</strong> (default 3 for images, source for video), and make a looping WebM (GIF replacement). All client-side!</p>

    <div class="btn-row">
      <button class="btn" id="pickFolderBtn">üìÅ Pick Folder</button>
      <input type="file" id="fileInput" accept="image/*" multiple style="display:none" />
      <button class="btn secondary" id="pickFilesBtn">üñºÔ∏è Select Images</button>
      <input type="file" id="folderCompat" webkitdirectory directory multiple accept="image/*" style="display:none" />
      <button class="btn secondary" id="pickFolderCompat">üìÅ Pick Folder (compat)</button>
      <input type="file" id="videoInput" accept="video/*" style="display:none" />
      <button class="btn secondary" id="pickVideoBtn">üé• Upload Video</button>
    </div>

    <div class="caps-banner" id="capsBanner"></div>

    <div class="note small">
      Tip: Files sorted naturally. Videos auto-extract frames at FPS. Mixed OK‚Äîresized consistently.
    </div>

    <div class="row">
      <div>
        <label for="fps">‚è±Ô∏è Frame Rate (fps)</label>
        <input type="number" id="fps" min="1" value="" placeholder="(auto)" />
      </div>
      <div>
        <label for="duration">‚è≥ Duration (s, blank = full)</label>
        <input type="number" id="duration" min="0.1" step="0.1" placeholder="(auto)" />
      </div>
      <div>
        <label><input type="checkbox" id="loop" checked> üîÑ Loop</label>
      </div>
    </div>

    <div class="row">
      <div style="flex:2">
        <label>Quick Presets</label>
        <div class="btn-row">
          <button class="preset-btn" data-preset="tiny">Tiny (480p, 6fps)</button>
          <button class="preset-btn" data-preset="balanced">Balanced (720p, 10fps)</button>
          <button class="preset-btn" data-preset="hq">HQ (1080p, 15fps)</button>
        </div>
      </div>
      <div>
        <label for="scaleMode">üñºÔ∏è Scale Mode</label>
        <select id="scaleMode">
          <option value="crop">Crop (preserve aspect, no bars)</option>
          <option value="fit">Fit (letterbox)</option>
          <option value="stretch">Stretch (fill, may distort)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label for="width">üìê Output Width (px, blank = source)</label>
        <input type="number" id="width" min="1" placeholder="(auto)" />
      </div>
      <div>
        <label for="height">üìè Output Height (px, blank = auto)</label>
        <input type="number" id="height" min="1" placeholder="(auto)" />
      </div>
    </div>

    <div class="row">
      <div>
        <label for="quality">üé® WebM Quality (kbps)</label>
        <input type="range" id="quality" min="500" max="8000" value="4000" />
        <small id="qualityVal">4000 kbps</small>
      </div>
      <div>
        <label for="codec">üéõÔ∏è Codec</label>
        <select id="codec">
          <option value="video/webm;codecs=vp9">VP9 (better)</option>
          <option value="video/webm;codecs=vp8">VP8 (compat)</option>
          <option value="video/webm">Auto</option>
        </select>
      </div>
    </div>

    <div class="row" id="gifRow" style="display:flex;">
      <div>
        <label for="gifQuality">üéûÔ∏è GIF Quality (1=best/large, 30=small/lossy)</label>
        <input type="range" id="gifQuality" min="1" max="30" value="10" />
        <small id="gifQualityVal">10 (higher=smaller file)</small>
      </div>
      <div>
        <label for="reduceColors">üé® Reduce Colors (2-256, like FFmpeg palette; blank=auto)</label>
        <input type="range" id="reduceColors" min="2" max="256" value="64" />
        <small id="reduceColorsVal">64 colors</small>
      </div>
    </div>

    <div class="row" id="gifAdvancedRow" style="display:flex;">
      <div>
        <label><input type="checkbox" id="gifOptimize" checked> üîß Optimize (remove duplicates)</label>
      </div>
      <div>
        <label for="gifDither">üñåÔ∏è Dither</label>
        <select id="gifDither">
          <option value="false">None (smaller, crisp)</option>
          <option value="floyd-steinberg">Floyd-Steinberg (smoother, larger)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Selected Files</label>
        <div id="list" class="list">None yet.</div>
      </div>
    </div>

    <div class="btn-row">
      <button class="btn" id="makeBtn" style="flex:1;">‚ö° Make WebM</button>
      <button class="btn secondary" id="makeGifBtn" style="flex:1;">üéûÔ∏è Make GIF</button>
      <button class="btn cancel-btn" id="cancelBtn" style="display:none;">‚èπÔ∏è Stop</button>
    </div>

    <label>Progress</label>
    <progress id="prog" max="100" value="0"></progress>
    <div id="status" class="small" style="margin-top:6px;">Idle.</div>

    <video id="preview" autoplay muted playsinline controls style="display:none"></video>
    <img id="gifPreview" style="display:none;" alt="GIF Preview" />
    <div id="dlWrap" style="margin-top:10px; display:none;">
      <div class="btn-row">
        <a id="download" class="btn" download="out.webm">‚¨áÔ∏è Download</a>
      </div>
    </div>
  </div>

  <script>
    const pickFolderBtn = document.getElementById('pickFolderBtn');
    const pickFilesBtn  = document.getElementById('pickFilesBtn');
    const pickFolderCompatBtn = document.getElementById('pickFolderCompat');
    const folderCompat = document.getElementById('folderCompat');
    const fileInput     = document.getElementById('fileInput');
    const videoInput    = document.getElementById('videoInput');
    const pickVideoBtn  = document.getElementById('pickVideoBtn');
    const listEl        = document.getElementById('list');
    const makeBtn       = document.getElementById('makeBtn');
    const makeGifBtn    = document.getElementById('makeGifBtn');
    const cancelBtn     = document.getElementById('cancelBtn');
    const gifRow        = document.getElementById('gifRow');
    const gifAdvancedRow = document.getElementById('gifAdvancedRow');
    const fpsEl         = document.getElementById('fps');
    const durationEl    = document.getElementById('duration');
    const loopEl        = document.getElementById('loop');
    const wEl           = document.getElementById('width');
    const hEl           = document.getElementById('height');
    const scaleModeEl   = document.getElementById('scaleMode');
    const qualityEl     = document.getElementById('quality');
    const qualityValEl  = document.getElementById('qualityVal');
    const gifQualityEl  = document.getElementById('gifQuality');
    const gifQualityValEl = document.getElementById('gifQualityVal');
    const reduceColorsEl = document.getElementById('reduceColors');
    const reduceColorsValEl = document.getElementById('reduceColorsVal');
    const gifOptimizeEl = document.getElementById('gifOptimize');
    const gifDitherEl = document.getElementById('gifDither');
    const codecEl       = document.getElementById('codec');
    const prog          = document.getElementById('prog');
    const statusEl      = document.getElementById('status');
    const preview       = document.getElementById('preview');
    const gifPreview    = document.getElementById('gifPreview');
    const downloadA     = document.getElementById('download');
    const dlWrap        = document.getElementById('dlWrap');
    const capsBanner    = document.getElementById('capsBanner');

    let imageFiles = [];     // File[]
    let bitmaps    = [];     // ImageBitmap[]
    let naturalW = null, naturalH = null;
    let lastCanvasW = null, lastCanvasH = null, lastMime = null;
    let isVideoMode = false;
    let videoElement = null; // Hidden video for frame extraction
    let originalVideoFps = 30; // Default fallback
    let lastOutputType = null; // 'webm' or 'gif'
    let lastOutputUrl = null; // For cleanup
    let canceled = false; // For cancel button

    // Global GIF worker cache
    let gifWorkerUrl = null;
    let gifWorkersEnabled = true;

    // Device capabilities probe
    const caps = {
      mediaRecorder: !!window.MediaRecorder,
      vp9: window.MediaRecorder?.isTypeSupported?.('video/webm;codecs=vp9'),
      vp8: window.MediaRecorder?.isTypeSupported?.('video/webm;codecs=vp8'),
      deviceMemory: navigator.deviceMemory || 4, // Fallback to 4GB
      hardwareConcurrency: navigator.hardwareConcurrency || 4
    };
    const lowEnd = caps.deviceMemory <= 4;
    capsBanner.innerHTML = `WebM ${caps.vp9 ? 'VP9' : caps.vp8 ? 'VP8' : '‚ùå'} | GIF ‚úÖ | RAM: ${lowEnd ? 'Low (capped for stability)' : 'High'}`;

    // Pre-fetch GIF worker at startup with timeout
    async function preloadGifWorker() {
      try {
        status('Preloading GIF tools...');
        const controller = new AbortController();
        setTimeout(() => controller.abort(), 10000); // 10s timeout
        const response = await fetch('https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js', { signal: controller.signal });
        if (!response.ok) throw new Error('Fetch failed');
        const blob = await response.blob();
        gifWorkerUrl = URL.createObjectURL(blob);
        status('Ready!');
      } catch (err) {
        console.warn('GIF worker preload failed:', err);
        gifWorkersEnabled = false;
        gifWorkerUrl = null;
        status('GIF workers disabled (using single-thread mode‚Äîslower but stable).');
      }
    }
    preloadGifWorker();

    // Presets
    const presets = {
      tiny: { width: 480, fps: 6, quality: 1500 },
      balanced: { width: 720, fps: 10, quality: 4000 },
      hq: { width: 1080, fps: 15, quality: 6000 }
    };
    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.onclick = () => {
        const p = presets[btn.dataset.preset];
        if (lowEnd && p.width > 720) p.width = 720; // Cap low-end
        wEl.value = p.width;
        fpsEl.value = p.fps;
        qualityEl.value = p.quality;
        qualityValEl.textContent = `${p.quality} kbps`;
        hEl.value = ''; // Auto-height
      };
    });

    // Helpers
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const once = (el, ev) => new Promise(res => el.addEventListener(ev, res, { once: true }));

    async function seekTo(video, t) {
      const target = Math.min(Math.max(0, t), Math.max(0, video.duration - 0.001));
      if (Math.abs(video.currentTime - target) < 1e-4) return;
      video.currentTime = target;
      await once(video, 'seeked');
      await new Promise(requestAnimationFrame);
    }

    function pickMime(preferred) {
      if (preferred === 'video/webm;codecs=vp9' && caps.vp9) return 'video/webm;codecs=vp9';
      if (preferred === 'video/webm;codecs=vp8' && caps.vp8) return 'video/webm;codecs=vp8';
      return 'video/webm';
    }

    function drawFrame(ctx, source, outW, outH, mode) {
      if (mode === 'fit') {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, outW, outH);
      }

      const iw = source.width || source.videoWidth;
      const ih = source.height || source.videoHeight;
      let sx = 0, sy = 0, sw = iw, sh = ih;
      let dx = 0, dy = 0, dw = outW, dh = outH;

      if (mode === 'fit') {
        const ratio = Math.min(outW / iw, outH / ih);
        dw = iw * ratio;
        dh = ih * ratio;
        dx = (outW - dw) / 2;
        dy = (outH - dh) / 2;
      } else if (mode === 'crop') {
        const ratio = Math.max(outW / iw, outH / ih);
        sx = (iw - (outW / ratio)) / 2;
        sy = (ih - (outH / ratio)) / 2;
        sw = outW / ratio;
        sh = outH / ratio;
        dw = outW;
        dh = outH;
      } else if (mode === 'stretch') {
        // Full stretch
      }

      ctx.drawImage(source, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    function getEffectiveFps() {
      const val = parseInt(fpsEl.value);
      if (isNaN(val) || val < 1 || val > 30) return isVideoMode ? originalVideoFps : 3; // Clamp 1-30
      return val;
    }

    function showPreview(type, url) {
      if (lastOutputUrl) URL.revokeObjectURL(lastOutputUrl);
      lastOutputUrl = url;
      preview.style.display = 'none';
      gifPreview.style.display = 'none';
      if (type === 'webm') {
        preview.src = url;
        preview.loop = loopEl.checked;
        preview.style.display = 'block';
      } else if (type === 'gif') {
        gifPreview.src = url;
        gifPreview.style.display = 'block';
      }
      dlWrap.style.display = 'block';
      downloadA.href = url;
      downloadA.download = `out.${type}`;
    }

    function cleanupBitmaps() {
      bitmaps.forEach(bm => bm.close?.());
      bitmaps = [];
    }

    function cancel() {
      canceled = true;
      status('Stopped.');
      prog.value = 0;
      cancelBtn.style.display = 'none';
    }

    qualityEl.oninput = () => qualityValEl.textContent = qualityEl.value + ' kbps';
    gifQualityEl.oninput = () => gifQualityValEl.textContent = gifQualityEl.value + ' (higher=smaller file)';
    reduceColorsEl.oninput = () => reduceColorsValEl.textContent = reduceColorsEl.value + ' colors';

    function naturalSort(a, b) {
      const ax = [], bx = [];
      a.name.replace(/(\d+)|(\D+)/g, (_, $1, $2) => ax.push([$1 || Infinity, $2 || ""]));
      b.name.replace(/(\d+)|(\D+)/g, (_, $1, $2) => bx.push([$1 || Infinity, $2 || ""]));
      while (ax.length && bx.length) {
        const an = ax.shift(), bn = bx.shift();
        const nA = parseInt(an[0], 10), nB = parseInt(bn[0], 10);
        if (an[0] !== Infinity || bn[0] !== Infinity) {
          if (nA !== nB) return nA - nB;
        } else if (an[1] !== bn[1]) {
          return an[1] > bn[1] ? 1 : -1;
        }
      }
      return ax.length - bx.length;
    }

    function showList() {
      if (!imageFiles.length) { listEl.textContent = "None yet."; return; }
      const lines = imageFiles.map(f => f.name).slice(0, 50);
      listEl.innerHTML = lines.map(s => `<div>${s}</div>`).join("") + (imageFiles.length>50 ? `<div>‚Ä¶ +${imageFiles.length-50} more</div>`:"");
    }

    async function pickFolder() {
      try {
        const dir = await window.showDirectoryPicker();
        const files = [];
        for await (const entry of dir.values()) {
          if (entry.kind === "file" && /\.(png|jpe?g|webp)$/i.test(entry.name)) {
            files.push(await entry.getFile());
          }
        }
        files.sort(naturalSort);
        setImages(files);
      } catch (e) {
        if (e && e.name !== 'AbortError') console.error(e);
      }
    }

    function setImages(files) {
      imageFiles = files;
      isVideoMode = false;
      if (videoElement) {
        if (videoElement.__objectURL) URL.revokeObjectURL(videoElement.__objectURL);
        videoElement.remove();
        videoElement = null;
      }
      showList();
      bitmaps = []; naturalW = null; naturalH = null;
      gifRow.style.display = 'flex';
      gifAdvancedRow.style.display = 'flex';
      fpsEl.placeholder = '(auto: 3)';
      status(`Loaded ${files.length} image(s).`);
    }

    pickFolderBtn.onclick = pickFolder;
    pickFilesBtn.onclick = () => fileInput.click();
    pickFolderCompatBtn.onclick = () => folderCompat.click();
    fileInput.onchange = () => {
      const files = Array.from(fileInput.files).filter(f => /\.(png|jpe?g|webp)$/i.test(f.name));
      files.sort(naturalSort);
      setImages(files);
    };
    folderCompat.onchange = () => {
      const files = Array.from(folderCompat.files).filter(f => /\.(png|jpe?g|webp)$/i.test(f.name));
      files.sort(naturalSort);
      setImages(files);
    };

    pickVideoBtn.onclick = () => videoInput.click();
    videoInput.onchange = async () => {
      const file = videoInput.files[0];
      if (!file) return;
      if (videoElement) {
        if (videoElement.__objectURL) URL.revokeObjectURL(videoElement.__objectURL);
        videoElement.remove();
      }
      imageFiles = [file];
      isVideoMode = true;
      showList();
      bitmaps = []; naturalW = null; naturalH = null;
      gifRow.style.display = 'flex';
      gifAdvancedRow.style.display = 'flex';
      fpsEl.placeholder = '(auto: source)';
      status(`Loaded video: ${file.name} (${(file.size/1024/1024).toFixed(1)} MB)`);

      const videoUrl = URL.createObjectURL(file);
      videoElement = document.createElement('video');
      videoElement.preload = 'auto';
      videoElement.muted = true;
      videoElement.playsInline = true;
      videoElement.src = videoUrl;
      videoElement.style.display = 'none';
      document.body.appendChild(videoElement);

      await once(videoElement, 'loadedmetadata');
      naturalW = videoElement.videoWidth;
      naturalH = videoElement.videoHeight;
      wEl.placeholder = String(naturalW);
      hEl.placeholder = String(naturalH);

      originalVideoFps = 30;
      if ('webkitDecodedFrameCount' in videoElement) {
        await videoElement.play();
        await sleep(1000);
        const frames = videoElement.webkitDecodedFrameCount || 30;
        originalVideoFps = Math.round(frames);
        videoElement.pause();
        videoElement.currentTime = 0;
      }

      videoElement.__objectURL = videoUrl;
    };

    function status(msg) { 
      statusEl.textContent = msg; 
      console.log(msg); // For debugging
    }

    // Optimized k-means for global palette (with yielding and sampling)
    async function generatePalette(bitmaps, maxColors) {
      const sampleFrames = lowEnd ? Math.min(20, bitmaps.length) : Math.min(100, bitmaps.length);
      const allPixels = [];
      const maxPixels = lowEnd ? 500000 : 1000000; // Cap to prevent OOM

      status('Sampling pixels for palette...');
      for (let f = 0; f < sampleFrames; f++) {
        if (canceled) throw new Error('Canceled');
        const bm = bitmaps[f];
        const canvas = document.createElement('canvas');
        canvas.width = bm.width; canvas.height = bm.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(bm, 0, 0);
        const imageData = ctx.getImageData(0, 0, bm.width, bm.height);
        const data = imageData.data;
        const step = Math.max(1, Math.floor(data.length / 4 / (maxPixels / sampleFrames))); // Subsample
        for (let i = 0; i < data.length; i += 4 * step) {
          allPixels.push([data[i], data[i+1], data[i+2]]); // RGB only
          if (allPixels.length >= maxPixels) break;
        }
        if (f % 10 === 0) await new Promise(requestAnimationFrame); // Yield
        if (allPixels.length >= maxPixels) break;
      }
      prog.value = 10;

      // Simplified k-means (init random centroids, iterate 3x for speed)
      let centroids = allPixels.slice(0, maxColors).map(p => [...p]);
      for (let iter = 0; iter < 3; iter++) {
        if (canceled) throw new Error('Canceled');
        const clusters = Array(maxColors).fill().map(() => []);
        allPixels.forEach((pixel, idx) => {
          if (idx % 10000 === 0) await new Promise(requestAnimationFrame); // Yield during clustering
          const dists = centroids.map(c => Math.hypot(...pixel.map((v, i) => v - c[i])));
          const closest = dists.indexOf(Math.min(...dists));
          clusters[closest].push(pixel);
        });
        centroids = clusters.map(cluster => {
          if (!cluster.length) return [0,0,0];
          const sums = cluster.reduce((acc, p) => acc.map((s, i) => s + p[i]), [0,0,0]);
          return sums.map(s => Math.round(s / cluster.length));
        });
        status(`Palette iteration ${iter + 1}/3...`);
      }
      prog.value = 15;
      return centroids;
    }

    // Quantize frame to palette (batched with yields)
    async function quantizeFrame(bitmap, palette, outW, outH) {
      const canvas = document.createElement('canvas');
      canvas.width = outW; canvas.height = outH;
      const ctx = canvas.getContext('2d');
      drawFrame(ctx, bitmap, outW, outH, scaleModeEl.value); // Apply scaling first
      const imageData = ctx.getImageData(0, 0, outW, outH);
      const data = imageData.data;
      const batchSize = 10000; // Process in batches
      for (let i = 0; i < data.length; i += 4) {
        if (canceled) throw new Error('Canceled');
        const rgb = [data[i], data[i+1], data[i+2]];
        const closest = palette.reduce((best, p, idx) => {
          const dist = Math.hypot(...rgb.map((v, j) => v - p[j]));
          return dist < best.dist ? { idx, dist } : best;
        }, { idx: 0, dist: Infinity });
        data[i] = palette[closest.idx][0];
        data[i+1] = palette[closest.idx][1];
        data[i+2] = palette[closest.idx][2];
        if (i % batchSize === 0) await new Promise(requestAnimationFrame); // Yield
      }
      ctx.putImageData(imageData, 0, 0);
      return createImageBitmap(canvas);
    }

    async function loadBitmaps() {
      if (!imageFiles.length) throw new Error("No files selected.");
      bitmaps = [];
      canceled = false;
      cancelBtn.style.display = 'inline-block';
      const effectiveFps = getEffectiveFps();
      const inputDuration = parseFloat(durationEl.value);
      let extractDuration = inputDuration;
      if (isVideoMode && videoElement && !inputDuration) {
        extractDuration = videoElement.duration;
      }
      if (isVideoMode && videoElement) {
        const frameInterval = 1 / effectiveFps;
        const totalFrames = Math.min(Math.ceil(extractDuration / frameInterval), lowEnd ? 300 : 1500); // Tighter cap on low-end
        let tip = '';
        if (totalFrames > 300) {
          tip = ' (Tip: For long videos, try lower FPS or shorter duration to save RAM)';
        }
        status(`Extracting ${totalFrames} frames from video @ ${effectiveFps} fps (duration: ${extractDuration.toFixed(1)}s)${tip}‚Ä¶`);

        const grab = document.createElement('canvas');
        grab.width = videoElement.videoWidth;
        grab.height = videoElement.videoHeight;
        const gctx = grab.getContext('2d', { willReadFrequently: true });

        for (let i = 0; i < totalFrames; i++) {
          if (canceled) throw new Error('Canceled');
          if (i % 30 === 0) await new Promise(requestAnimationFrame); // Micro-break
          await seekTo(videoElement, i * frameInterval);
          gctx.drawImage(videoElement, 0, 0);
          const bm = await createImageBitmap(grab);
          bitmaps.push(bm);
          prog.value = Math.round(((i + 1) / totalFrames) * 30);
        }

        if (videoElement.__objectURL) {
          URL.revokeObjectURL(videoElement.__objectURL);
          delete videoElement.__objectURL;
        }
      } else {
        for (let i=0; i<imageFiles.length; i++) {
          if (canceled) throw new Error('Canceled');
          const bm = await createImageBitmap(imageFiles[i]);
          bitmaps.push(bm);
          if (!naturalW) { naturalW = bm.width; naturalH = bm.height; wEl.placeholder = String(naturalW); hEl.placeholder = "(auto)"; }
          prog.value = Math.round(((i+1)/imageFiles.length)*30);
        }
        extractDuration = inputDuration || (bitmaps.length / effectiveFps);
      }
      cancelBtn.style.display = 'none';
    }

    async function makeWebM() {
      try {
        prog.value = 0; 
        canceled = false;
        cancelBtn.style.display = 'inline-block';
        status("Preparing‚Ä¶");
        await loadBitmaps();
        const fps = getEffectiveFps();
        const inputDuration = parseFloat(durationEl.value);
        let duration = inputDuration;
        if (!duration) duration = isVideoMode ? videoElement?.duration || (bitmaps.length / fps) : bitmaps.length / fps;
        let totalFrames;
        if (isVideoMode) {
          totalFrames = bitmaps.length;
        } else {
          totalFrames = Math.ceil(fps * duration);
        }
        const loop = loopEl.checked;
        let outW = parseInt(wEl.value, 10);
        let outH = parseInt(hEl.value, 10);
        if (!outW && !outH) { outW = naturalW; outH = naturalH; }
        else if (outW && !outH) { outH = Math.round(naturalH * (outW / naturalW)); }
        else if (!outW && outH) { outW = Math.round(naturalW * (outH / naturalH)); }

        const canvas = document.createElement('canvas');
        canvas.width = outW; canvas.height = outH;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        lastCanvasW = outW;
        lastCanvasH = outH;

        const stream = canvas.captureStream(fps);
        const preferred = codecEl.value;
        const mime = pickMime(preferred);
        lastMime = mime;
        const bitrate = parseInt(qualityEl.value);
        const rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: bitrate * 1000 });
        const chunks = [];
        rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };

        rec.start(200);
        status(`Rendering ${totalFrames} frame(s) @ ${fps} fps‚Ä¶`);
        const frameDur = 1000 / fps;
        let i = 0;
        const timer = setInterval(() => {
          if (canceled || i >= totalFrames) {
            clearInterval(timer);
            if (rec.state === 'recording') rec.stop();
            return;
          }
          if (i % 30 === 0) requestAnimationFrame(() => {}); // Yield
          const frameIdx = loop ? (i % bitmaps.length) : Math.min(i, bitmaps.length - 1);
          ctx.clearRect(0, 0, outW, outH);
          drawFrame(ctx, bitmaps[frameIdx], outW, outH, scaleModeEl.value);
          prog.value = 30 + Math.round((i / totalFrames) * 70);
          i++;
        }, frameDur);

        await new Promise(resolve => rec.addEventListener('stop', resolve, { once: true }));

        const webmBlob = new Blob(chunks, { type: mime });
        const url = URL.createObjectURL(webmBlob);
        showPreview('webm', url);
        lastOutputType = 'webm';
        cleanupBitmaps();
        prog.value = 100;
        status(`WebM done (${mime}) @ ${fps} fps. ${(webmBlob.size/1024/1024).toFixed(2)} MB`);
      } catch (err) {
        if (err.message === 'Canceled') return;
        console.error(err);
        status("Error: " + (err && err.message ? err.message : err));
      } finally {
        cancelBtn.style.display = 'none';
        canceled = false;
      }
    }

    async function makeGIF() {
      prog.value = 0;
      canceled = false;
      cancelBtn.style.display = 'inline-block';
      if (!bitmaps.length) await loadBitmaps();
      if (typeof GIF === 'undefined') { alert('GIF library failed to load.'); return; }
      try {
        if (!gifWorkerUrl) {
          throw new Error('GIF tools not ready‚Äînetwork issue? Try WebM or refresh page.');
        }

        const fps = getEffectiveFps();
        const inputDuration = parseFloat(durationEl.value);
        let duration = inputDuration;
        if (!duration) duration = bitmaps.length / fps;
        const totalFrames = Math.ceil(fps * duration);
        const loop = loopEl.checked;
        let outW = parseInt(wEl.value, 10);
        let outH = parseInt(hEl.value, 10);
        if (!outW && !outH) { outW = naturalW; outH = naturalH; }
        else if (outW && !outH) { outH = Math.round(naturalH * (outW / naturalW)); }
        else if (!outW && outH) { outW = Math.round(naturalW * (outH / naturalH)); }
        const gifQual = Math.max(1, parseInt(gifQualityEl.value, 10) || 10);
        let maxColors = lowEnd ? Math.min(64, parseInt(reduceColorsEl.value, 10) || 64) : parseInt(reduceColorsEl.value, 10) || 128;
        const optimize = gifOptimizeEl.checked;
        const dither = gifDitherEl.value;

        // Disable palette on low-end + many frames
        const usePalette = maxColors < 256 && !(lowEnd && bitmaps.length > 100);
        if (!usePalette) maxColors = 256;

        const framesToUse = Math.min(totalFrames, bitmaps.length);
        const frameDelay = Math.round(1000 / fps);
        const estSizeKB = Math.round(framesToUse * outW * outH / 10000 / (31 - gifQual)); // Rough heuristic

        let processedFrames = bitmaps.slice(0, framesToUse);
        if (usePalette) {
          status(`Building global palette (${maxColors} colors) for better compression‚Ä¶`);
          const palette = await generatePalette(bitmaps, maxColors);
          status(`Quantizing ${framesToUse} frames to palette‚Ä¶`);
          processedFrames = [];
          for (let i = 0; i < framesToUse; i++) {
            if (canceled) throw new Error('Canceled');
            const quantizedBm = await quantizeFrame(bitmaps[i], palette, outW, outH);
            processedFrames.push(quantizedBm);
            if (i % 5 === 0) await new Promise(requestAnimationFrame);
            prog.value = 15 + Math.round((i / framesToUse) * 5);
          }
        }
        prog.value = usePalette ? 20 : 0;

        status(`Generating GIF‚Ä¶ (q=${gifQual}, ${framesToUse} frames @ ${fps} fps, ~${estSizeKB}KB est, duration: ${duration.toFixed(1)}s)`);
        const gif = new GIF({
          workers: gifWorkersEnabled ? Math.min(4, caps.hardwareConcurrency) : 1,
          quality: gifQual,
          width: outW,
          height: outH,
          workerScript: gifWorkerUrl,
          background: '#000000',
          repeat: loop ? 0 : -1,
          optimize: optimize,
          dither: dither
        });

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = outW; tempCanvas.height = outH;
        const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

        for (let i = 0; i < framesToUse; i++) {
          if (canceled) throw new Error('Canceled');
          if (i % 30 === 0) await new Promise(requestAnimationFrame);
          const frameIdx = loop ? (i % bitmaps.length) : i;
          const frameBm = processedFrames.length ? processedFrames[frameIdx % processedFrames.length] : bitmaps[frameIdx];
          tempCtx.clearRect(0, 0, outW, outH);
          drawFrame(tempCtx, frameBm, outW, outH, scaleModeEl.value);
          gif.addFrame(tempCanvas, { delay: frameDelay, copy: true });
          prog.value = (usePalette ? 20 : 0) + Math.round((i / framesToUse) * 50);
        }

        // Cleanup processed frames
        if (processedFrames.length) processedFrames.forEach(bm => bm.close?.());

        gif.on('finished', blob => {
          const url = URL.createObjectURL(blob);
          showPreview('gif', url);
          lastOutputType = 'gif';
          cleanupBitmaps();
          prog.value = 100;
          status(`GIF done (q=${gifQual}, ${usePalette ? maxColors + ' colors' : 'auto'}) @ ${fps} fps. ${(blob.size/1024/1024).toFixed(2)} MB`);
        });

        gif.on('progress', p => { 
          prog.value = (usePalette ? 70 : 50) + Math.round(p * 30); 
        });
        gif.render();
      } catch (err) {
        if (err.message === 'Canceled') return;
        console.error(err);
        status("GIF Error: " + (err && err.message ? err.message : err) + " (Try WebM?)");
      } finally {
        cancelBtn.style.display = 'none';
        canceled = false;
      }
    }

    makeBtn.onclick = makeWebM;
    makeGifBtn.onclick = makeGIF;
    cancelBtn.onclick = cancel;
  </script>
</body>
</html>