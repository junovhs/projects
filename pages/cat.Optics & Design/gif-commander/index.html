<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Images → WebM (Client-side) + GIF</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- No ffmpeg script here; we lazy-load an ESM module inside JS. -->
  <style>
    body { font-family: "Segoe UI", Roboto, Arial, sans-serif; background: linear-gradient(135deg,#e0eafc,#cfdef3);
      margin:0; min-height:100vh; display:flex; justify-content:center; align-items:flex-start; padding:36px 14px; }
    .container { background:#fff; padding:28px 34px; border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,.1);
      max-width:860px; width:100%; }
    h1 { margin:0 0 8px; text-align:center; color:#2c3e50; font-size:1.8rem; }
    p  { margin:0 0 16px; text-align:center; color:#555; }
    label { display:block; margin:12px 0 6px; font-weight:600; color:#333; }
    input[type="number"], input[type="text"], select {
      width:100%; padding:10px 12px; font-size:1rem; border:1px solid #ccc; border-radius:8px; box-sizing:border-box;
    }
    input[type="range"] { width:100%; }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .row > div { flex:1 1 180px; min-width:180px; }
    .btn { display:inline-block; padding:12px 16px; border:none; border-radius:8px; cursor:pointer;
      background:linear-gradient(135deg,#3498db,#2ecc71); color:#fff; font-weight:600; }
    .btn.secondary { background:linear-gradient(135deg,#6c757d,#495057); }
    .btn.warn { background:linear-gradient(135deg,#f39c12,#d35400); }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .btn-row{ display:flex; gap:10px; flex-wrap:wrap; margin-bottom:8px; }
    .small{ font-size:.9rem; color:#666; }
    .note{ background:#d1ecf1; border:1px solid #bee5eb; padding:12px; border-radius:8px; margin:12px 0; color:#0c5460; }
    .warnbox{ background:#fff3cd; border:1px solid #ffeaa7; padding:12px; border-radius:8px; margin:12px 0; color:#856404; }
    .list{ font-family:ui-monospace,Menlo,Consolas,monospace; background:#f8f9fa; border:1px solid #e1e5ea; border-radius:8px;
      padding:10px; max-height:140px; overflow:auto; }
    video{ width:100%; margin-top:12px; border-radius:8px; background:#000; }
    progress{ width:100%; height:12px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>🖼️ Image Sequence → WebM (Client-side) + GIF</h1>
    <p>Select a folder or files, tweak quality, export WebM, then convert to GIF — all in the browser.</p>

    <div class="btn-row">
      <button class="btn" id="pickFolder">📁 Pick Folder</button>
      <input type="file" id="folderCompat" webkitdirectory directory multiple accept="image/*" style="display:none" />
      <button class="btn secondary" id="pickFolderCompat">📁 Pick Folder (compat)</button>

      <input type="file" id="pickFiles" accept="image/*" multiple style="display:none" />
      <button class="btn secondary" id="pickFilesBtn">🖼️ Select Images</button>
    </div>

    <div class="note small">
      If the Directory Picker is blocked (iframes), use <strong>Pick Folder (compat)</strong>. Hosted on Vercel/GitHub Pages (HTTPS) works.
    </div>

    <div class="row">
      <div>
        <label for="fps">⏱️ FPS</label>
        <input type="number" id="fps" min="1" value="3" />
      </div>
      <div>
        <label for="bitrate">🔧 Bitrate (kbps)</label>
        <input type="number" id="bitrate" min="256" value="4000" />
      </div>
      <div>
        <label for="codec">🎛️ Codec</label>
        <select id="codec">
          <option value="video/webm;codecs=vp9">VP9 (better)</option>
          <option value="video/webm;codecs=vp8">VP8 (compat)</option>
          <option value="video/webm">Auto</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label for="width">📐 Width (px, blank = source)</label>
        <input type="number" id="width" min="1" placeholder="(auto)">
      </div>
      <div>
        <label for="height">📏 Height (px, blank = auto)</label>
        <input type="number" id="height" min="1" placeholder="(auto)">
      </div>
      <div>
        <label for="fit">🧩 Fit</label>
        <select id="fit">
          <option value="contain">Contain (letterbox)</option>
          <option value="cover">Cover (crop)</option>
          <option value="stretch">Stretch</option>
        </select>
      </div>
      <div>
        <label for="bg">🎨 Background</label>
        <input type="text" id="bg" value="#000000" />
      </div>
    </div>

    <div class="row">
      <div>
        <label for="mode">🔁 Play Mode</label>
        <select id="mode">
          <option value="forward">Forward</option>
          <option value="boomerang">Boomerang</option>
          <option value="reverse">Reverse</option>
        </select>
      </div>
      <div>
        <label for="hold">🕒 Hold per frame (ms, optional)</label>
        <input type="number" id="hold" min="0" placeholder="0">
      </div>
      <div>
        <label for="smoothing">🖌️ Image Smoothing</label>
        <select id="smoothing">
          <option value="on">On (smooth)</option>
          <option value="off">Off (pixel-sharp)</option>
        </select>
      </div>
    </div>

    <label>Selected Images</label>
    <div id="list" class="list">None yet.</div>

    <div class="btn-row" style="margin-top:10px;">
      <button class="btn" id="make">⚡ Make WebM</button>
      <button class="btn warn" id="makeGif" disabled>✨ To GIF (client-side)</button>
    </div>

    <div class="warnbox small" id="isolationMsg" style="display:none;">
      To make GIFs client-side, this page must be <strong>cross-origin isolated</strong>. On Vercel, add
      <code>Cross-Origin-Opener-Policy: same-origin</code> and
      <code>Cross-Origin-Embedder-Policy: require-corp</code> (you already did this in <code>vercel.json</code>).
    </div>

    <label>Progress</label>
    <progress id="prog" max="100" value="0"></progress>
    <div id="status" class="small" style="margin-top:6px;">Idle.</div>

    <video id="preview" autoplay loop muted playsinline controls style="display:none"></video>
    <div id="dlWrap" style="display:none; margin-top:10px;">
      <a id="download" class="btn" download="out.webm">⬇️ Download WebM</a>
    </div>
  </div>

  <script>
    // ---------- Elements
    const pickFolderBtn = document.getElementById('pickFolder');
    const pickFolderCompatBtn = document.getElementById('pickFolderCompat');
    const folderCompatInput = document.getElementById('folderCompat');
    const pickFilesHidden = document.getElementById('pickFiles');
    const pickFilesBtn = document.getElementById('pickFilesBtn');

    const fpsEl = document.getElementById('fps');
    const bitrateEl = document.getElementById('bitrate');
    const codecEl = document.getElementById('codec');
    const wEl = document.getElementById('width');
    const hEl = document.getElementById('height');
    const fitEl = document.getElementById('fit');
    const bgEl = document.getElementById('bg');
    const modeEl = document.getElementById('mode');
    const holdEl = document.getElementById('hold');
    const smoothingEl = document.getElementById('smoothing');

    const listEl = document.getElementById('list');
    const makeBtn = document.getElementById('make');
    const makeGifBtn = document.getElementById('makeGif');
    const prog = document.getElementById('prog');
    const statusEl = document.getElementById('status');
    const preview = document.getElementById('preview');
    const downloadA = document.getElementById('download');
    const dlWrap = document.getElementById('dlWrap');
    const isolationMsg = document.getElementById('isolationMsg');

    // ---------- State
    let imageFiles = [];   // File[]
    let bitmaps = [];      // ImageBitmap[]
    let naturalW=null, naturalH=null;
    let lastWebMBlob = null;
    let lastCanvasW=null, lastCanvasH=null, lastMime=null;

    // ---------- Isolation check (enables GIF)
    function checkIsolation() {
      const ok = window.crossOriginIsolated === true;
      makeGifBtn.disabled = !ok;
      isolationMsg.style.display = ok ? 'none' : 'block';
    }
    checkIsolation();

    // ---------- Utils
    function status(msg) { statusEl.textContent = msg; }
    function naturalSort(a, b) {
      const ax=[], bx=[];
      a.name.replace(/(\d+)|(\D+)/g, (_,n,t)=>ax.push([n||Infinity,t||""]));
      b.name.replace(/(\d+)|(\D+)/g, (_,n,t)=>bx.push([n||Infinity,t||""]));
      while (ax.length && bx.length) {
        const an=ax.shift(), bn=bx.shift();
        if (an[0]!==Infinity || bn[0]!==Infinity) {
          const na=parseInt(an[0],10), nb=parseInt(bn[0],10);
          if (na!==nb) return na-nb;
        } else if (an[1]!==bn[1]) return an[1]>bn[1]?1:-1;
      }
      return ax.length-bx.length;
    }
    function showList() {
      if (!imageFiles.length) { listEl.textContent = "None yet."; return; }
      const names = imageFiles.map(f=>f.name);
      const shown = names.slice(0,60).map(n=>`<div>${n}</div>`).join("");
      listEl.innerHTML = shown + (names.length>60?`<div>… +${names.length-60} more</div>`:"");
    }
    function setImages(files) {
      imageFiles = files.filter(f => /\.(png|jpe?g|webp)$/i.test(f.name));
      imageFiles.sort(naturalSort);
      bitmaps = []; naturalW=null; naturalH=null;
      showList();
      status(`Loaded ${imageFiles.length} image(s).`);
    }

    // ---------- Pickers
    pickFolderBtn.onclick = async () => {
      try {
        if (!window.showDirectoryPicker) { folderCompatInput.click(); return; }
        const dir = await window.showDirectoryPicker();
        const files=[];
        for await (const entry of dir.values()) {
          if (entry.kind==="file" && /\.(png|jpe?g|webp)$/i.test(entry.name)) {
            files.push(await entry.getFile());
          }
        }
        setImages(files);
      } catch(e){ if(e?.name!=="AbortError") console.error(e); }
    };
    pickFolderCompatBtn.onclick = () => folderCompatInput.click();
    folderCompatInput.onchange = () => setImages(Array.from(folderCompatInput.files));
    pickFilesBtn.onclick = () => pickFilesHidden.click();
    pickFilesHidden.onchange = () => setImages(Array.from(pickFilesHidden.files));

    // ---------- Loading bitmaps
    async function loadBitmaps() {
      if (!imageFiles.length) throw new Error("No images selected.");
      bitmaps = [];
      for (let i=0;i<imageFiles.length;i++){
        const bm = await createImageBitmap(imageFiles[i]);
        bitmaps.push(bm);
        if (!naturalW) { naturalW=bm.width; naturalH=bm.height; wEl.placeholder=String(naturalW); hEl.placeholder="(auto)"; }
        prog.value = Math.round(((i+1)/imageFiles.length)*25); // up to 25%
      }
    }

    // ---------- Drawing helpers
    function drawFit(ctx, bm, W, H, mode, bg, smoothing) {
      ctx.save();
      ctx.imageSmoothingEnabled = (smoothing !== "off");
      if (mode === "stretch") {
        ctx.fillStyle = bg; ctx.fillRect(0,0,W,H);
        ctx.drawImage(bm, 0, 0, W, H);
      } else {
        const sContain = Math.min(W/bm.width, H/bm.height);
        const sCover   = Math.max(W/bm.width, H/bm.height);
        const s = (mode==="cover")? sCover : sContain;
        const dw = Math.round(bm.width*s), dh = Math.round(bm.height*s);
        const dx = Math.floor((W - dw)/2), dy = Math.floor((H - dh)/2);
        ctx.fillStyle = bg; ctx.fillRect(0,0,W,H);
        ctx.drawImage(bm, dx, dy, dw, dh);
      }
      ctx.restore();
    }
    function buildFrameOrder(mode, count) {
      if (mode === "reverse") return Array.from({length:count}, (_,i)=>count-1-i);
      if (mode === "boomerang") {
        const fwd = Array.from({length:count}, (_,i)=>i);
        const rev = Array.from({length:count-2}, (_,i)=>count-2-i);
        return fwd.concat(rev);
      }
      return Array.from({length:count}, (_,i)=>i);
    }

    function pickMime(preferred) {
      const order = preferred ? [preferred, 'video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm']
                              : ['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
      for (const t of order) { if (MediaRecorder.isTypeSupported(t)) return t; }
      return 'video/webm';
    }

    // ---------- WebM render (MediaRecorder)
    async function makeWebM() {
      prog.value = 0; preview.style.display="none"; dlWrap.style.display="none";
      lastWebMBlob = null;

      await loadBitmaps();

      const fps = Math.max(1, parseInt(fpsEl.value||"3",10));
      const kbps = Math.max(256, parseInt(bitrateEl.value||"4000",10));
      const mime = pickMime(codecEl.value);
      const fit = fitEl.value;
      const bg = bgEl.value || "#000";
      const smoothing = smoothingEl.value;
      const holdMs = Math.max(0, parseInt(holdEl.value||"0",10));
      let W = parseInt(wEl.value, 10), H = parseInt(hEl.value,10);
      if (!W && !H) { W = naturalW; H = naturalH; }
      else if (W && !H) { H = Math.round(naturalH * (W / naturalW)); }
      else if (!W && H) { W = Math.round(naturalW * (H / naturalH)); }

      lastCanvasW = W; lastCanvasH = H; lastMime = mime;

      const canvas = document.createElement('canvas'); canvas.width=W; canvas.height=H;
      const ctx = canvas.getContext('2d');

      const stream = canvas.captureStream(fps);
      const rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: kbps*1000 });
      const chunks=[]; let stopped=false;
      rec.ondataavailable = e => { if (e.data?.size) chunks.push(e.data); };
      rec.onstop = ()=>{ stopped=true; };

      rec.start(200);
      status(`Encoding @ ${fps} fps, ~${kbps} kbps, ${W}×${H}…`);

      const order = buildFrameOrder(modeEl.value, bitmaps.length);
      const frameDur = 1000 / fps;

      for (let idx=0; idx<order.length; idx++) {
        drawFit(ctx, bitmaps[order[idx]], W, H, fit, bg, smoothing);
        prog.value = 25 + Math.round(((idx+1)/order.length)*60); // 25→85
        await new Promise(r => setTimeout(r, frameDur));

        if (holdMs>0) {
          const repeats = Math.floor(holdMs / frameDur);
          for (let r=0; r<repeats; r++) { await new Promise(res => setTimeout(res, frameDur)); }
        }
      }

      await new Promise(r => setTimeout(r, 250));
      rec.stop();
      await new Promise(res => { const t=setInterval(()=>{ if(stopped){clearInterval(t); res();}},50); });

      const blob = new Blob(chunks, { type: mime });
      const url = URL.createObjectURL(blob);
      preview.src = url; preview.style.display="block";
      downloadA.href = url; downloadA.download = "out.webm";
      dlWrap.style.display = "block";
      prog.value = 100;
      status(`WebM ready: ${(blob.size/1024/1024).toFixed(2)} MB (${mime})`);
      lastWebMBlob = blob;

      // If isolated, enable GIF button
      checkIsolation();
    }

    // ---------- Lazy ESM load of ffmpeg.wasm + GIF convert
    let ffmpeg = null, ffmpegLoading = false;
    async function ensureFFmpeg() {
      if (ffmpeg) return ffmpeg;
      if (ffmpegLoading) { await ffmpegLoading; return ffmpeg; }
      ffmpegLoading = (async () => {
        status("Loading FFmpeg.wasm (first time is big) …");
        // ESM build; CORS-fetchable (works with COEP).
        const mod = await import('https://unpkg.com/@ffmpeg/ffmpeg@0.12.15/dist/esm/index.js');
        const { createFFmpeg } = mod;
        ffmpeg = createFFmpeg({
          log: true,
          // Pin the core version to match the JS version:
          corePath: 'https://unpkg.com/@ffmpeg/core@0.12.15/dist/ffmpeg-core.js',
          progress: ({ ratio }) => { prog.value = Math.min(95, 5 + Math.round(ratio*85)); }
        });
        await ffmpeg.load();
        status("FFmpeg ready.");
        return ffmpeg;
      })();
      await ffmpegLoading;
      return ffmpeg;
    }

    async function makeGIF() {
      if (!lastWebMBlob) { alert("Make a WebM first."); return; }
      if (!window.crossOriginIsolated) { alert("This page isn't cross-origin isolated. Keep your vercel.json headers."); return; }

      try {
        prog.value = 0;
        const ff = await ensureFFmpeg();

        // Write input to FS
        const buf = new Uint8Array(await lastWebMBlob.arrayBuffer());
        ff.FS('writeFile', 'in.webm', buf);

        const fps = Math.max(1, parseInt(fpsEl.value || "3", 10));
        const W = lastCanvasW || 480;
        const H = lastCanvasH || -1;

        status("Generating palette…");
        await ff.run(
          '-i','in.webm',
          '-vf', `fps=${fps},scale=${W}:${H === -1 ? -1 : H}:flags=lanczos,palettegen`,
          '-y','pal.png'
        );

        status("Applying palette (dither)…");
        await ff.run(
          '-i','in.webm','-i','pal.png',
          '-lavfi','[0:v][1:v]paletteuse=dither=bayer:bayer_scale=3',
          '-loop','0',             // infinite loop
          '-y','out.gif'
        );

        const data = ff.FS('readFile','out.gif');
        const gifBlob = new Blob([data.buffer], { type:'image/gif' });
        const url = URL.createObjectURL(gifBlob);
        const a = document.createElement('a');
        a.href = url; a.download = 'out.gif'; a.click();
        status(`GIF ready: ${(gifBlob.size/1024/1024).toFixed(2)} MB`);
        prog.value = 100;
        setTimeout(()=>URL.revokeObjectURL(url), 5000);
      } catch (e) {
        console.error(e);
        status("GIF Error: " + (e?.message || e));
      }
    }

    // ---------- Wire up
    document.getElementById('make').onclick = makeWebM;
    document.getElementById('makeGif').onclick = makeGIF;

    // Picker events already wired above
  </script>
</body>
</html>
