<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Ultra-Responsive Film Grain Emulator â€” WebGL</title>
<style>
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: linear-gradient(135deg, #1e1e1e 0%, #2a2a2a 100%);
    color: #fff;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    padding: 20px;
    gap: 16px;
  }
  h1 {
    font-size: 2em; font-weight: 200; letter-spacing: -0.02em;
    margin: 0; background: linear-gradient(90deg, #fff, #888);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
  }
  .main { display: flex; gap: 20px; width: 100%; flex: 1 1 auto; }

  #controls {
    width: 400px; min-width: 320px; max-width: 420px; overflow: auto;
    background: rgba(40,40,40,.95); backdrop-filter: blur(14px);
    border-radius: 16px; padding: 20px; border: 1px solid rgba(255,255,255,.1);
    box-shadow: 0 20px 60px rgba(0,0,0,.5);
  }
  #controls .section { font-size: .95em; color: #7c8ef0; margin: 8px 0 10px; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,.1); }
  .group { display: grid; gap: 8px; margin-bottom: 12px; }
  .row { display: flex; align-items: center; gap: 10px; }
  label { font-size: .82em; color: #aaa; text-transform: uppercase; letter-spacing: .05em; }
  input[type="range"] { flex: 1; appearance: none; height: 5px; border-radius: 3px; background: rgba(255,255,255,.1); outline: none; }
  input[type="range"]::-webkit-slider-thumb { appearance: none; width: 16px; height: 16px; border-radius: 50%; background: linear-gradient(135deg,#667eea,#764ba2); box-shadow: 0 2px 10px rgba(102,126,234,.5); }
  input[type="number"], select { width: 80px; padding: 6px 8px; font-size: .85em; color: #fff; background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.12); border-radius: 6px; }
  button { padding: 10px 14px; font-weight: 600; font-size: .85em; color: #fff; background: linear-gradient(135deg,#667eea,#764ba2); border: 0; border-radius: 8px; cursor: pointer; transition: transform .15s ease, box-shadow .15s ease; }
  button:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(102,126,234,.4); }
  .preset-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .preset-grid .btn { background: rgba(255,255,255,.1); }
  .toggle { display: flex; align-items: center; gap: 10px; }
  .switch { position: relative; width: 44px; height: 24px; }
  .switch input { opacity: 0; width: 0; height: 0; }
  .slider { position: absolute; inset: 0; background: rgba(255,255,255,.1); border-radius: 34px; transition: .3s; }
  .slider:before { content: ""; position: absolute; width: 16px; height: 16px; left: 4px; bottom: 4px; border-radius: 50%; background: #fff; transition: .3s; }
  .switch input:checked + .slider { background: linear-gradient(135deg,#667eea,#764ba2); }
  .switch input:checked + .slider:before { transform: translateX(20px); }

  .stage-wrap {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 300px;
    position: relative;
  }

  #stage {
    position: relative; border-radius: 16px; overflow: hidden; background: #000;
    box-shadow: 0 30px 80px rgba(0,0,0,.6); cursor: move; user-select: none;
  }
  #glcanvas { display: block; }

  .hud { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,.75); border-radius: 8px; padding: 8px 12px; font: 12px/1.2 monospace; z-index: 10; }
  .perf { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,.75); border-radius: 8px; padding: 8px 12px; font: 12px/1.2 monospace; z-index: 10; color: #0f0; }
  .zoom-controls { position: absolute; right: 10px; bottom: 10px; display: flex; gap: 6px; z-index: 10; }
  .zoom-controls button { background: rgba(0,0,0,.8); padding: 8px; border-radius: 8px; }
  .file-label { display: block; padding: 12px; text-align: center; border-radius: 8px; border: 2px dashed rgba(255,255,255,.25); background: rgba(255,255,255,.06); cursor: pointer; }
  .file-label.drag-over { background: rgba(102,126,234,.2); border-color: #667eea; }
  #file { display: none; }

  .size-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
  .size-grid button { background: rgba(255,255,255,.12); }
  .size-grid button.active { background: linear-gradient(135deg,#667eea,#764ba2); }
</style>
</head>
<body>
  <h1>Film Grain Emulator â€” WebGL</h1>
  <div class="main">
    <aside id="controls">
      <div class="section">Preview Size</div>
      <div class="group">
        <div class="size-grid">
          <button id="sizeS">Small<br><small>720Ã—405</small></button>
          <button id="sizeM" class="active">Medium<br><small>960Ã—450</small></button>
          <button id="sizeL">Large<br><small>1280Ã—720</small></button>
        </div>
      </div>

      <div class="section">Core Grain Settings</div>
      <div class="group">
        <label>Intensity: <span id="v-intensity">0.50</span></label>
        <div class="row">
          <input type="range" id="intensity" min="0" max="1" step="0.01" value="0.5" />
          <input type="number" id="intensityN" min="0" max="1" step="0.01" value="0.5" />
        </div>
      </div>
      <div class="group">
        <label>Size: <span id="v-size">2.00</span></label>
        <div class="row">
          <input type="range" id="size" min="0.5" max="10" step="0.1" value="2.0" />
          <input type="number" id="sizeN" min="0.5" max="10" step="0.1" value="2.0" />
        </div>
      </div>
      <div class="group">
        <label>Pattern</label>
        <select id="pattern">
          <option value="0">Organic Film</option>
          <option value="1">Silver Halide</option>
          <option value="2">Digital Noise</option>
          <option value="3">Vintage 35mm</option>
        </select>
      </div>
      <div class="group">
        <label>Blend Mode</label>
        <select id="blend">
          <option value="0">Overlay</option>
          <option value="1">Soft Light</option>
          <option value="2">Screen</option>
          <option value="3">Multiply</option>
        </select>
      </div>
      <div class="group">
        <label>Opacity: <span id="v-opacity">0.50</span></label>
        <div class="row">
          <input type="range" id="opacity" min="0" max="1" step="0.01" value="0.5" />
          <input type="number" id="opacityN" min="0" max="1" step="0.01" value="0.5" />
        </div>
      </div>

      <div class="section">Film Response</div>
      <div class="group">
        <label>Luminance Response: <span id="v-response">0.50</span></label>
        <div class="row">
          <input type="range" id="response" min="0" max="1" step="0.01" value="0.5" />
          <input type="number" id="responseN" min="0" max="1" step="0.01" value="0.5" />
        </div>
      </div>
      <div class="group">
        <label>Edge Preserve: <span id="v-sharp">0.70</span></label>
        <div class="row">
          <input type="range" id="sharp" min="0" max="1" step="0.01" value="0.7" />
          <input type="number" id="sharpN" min="0" max="1" step="0.01" value="0.7" />
        </div>
      </div>
      <div class="group">
        <label>Contrast: <span id="v-contrast">1.00</span></label>
        <div class="row">
          <input type="range" id="contrast" min="0.5" max="2" step="0.01" value="1.0" />
          <input type="number" id="contrastN" min="0.5" max="2" step="0.01" value="1.0" />
        </div>
      </div>

      <div class="section">Color Variation</div>
      <div class="group">
        <label>Color Mode</label>
        <select id="color">
          <option value="0">Monochrome</option>
          <option value="1">Subtle RGB</option>
          <option value="2">Chromatic</option>
        </select>
      </div>
      <div class="group">
        <label>Saturation: <span id="v-sat">1.00</span></label>
        <div class="row">
          <input type="range" id="sat" min="0" max="2" step="0.01" value="1.0" />
          <input type="number" id="satN" min="0" max="2" step="0.01" value="1.0" />
        </div>
      </div>

      <div class="section">Presets</div>
      <div class="preset-grid">
        <button class="btn" id="p35">35mm Film</button>
        <button class="btn" id="p120">Medium Format</button>
        <button class="btn" id="pPush">Pushed ISO</button>
        <button class="btn" id="pMin">Minimal</button>
      </div>

      <div class="section">Options</div>
      <div class="group">
        <div class="toggle">
          <label class="switch"><input type="checkbox" id="toggleOriginal" /><span class="slider"></span></label>
          <span>Show Original</span>
        </div>
      </div>
      <div class="group">
        <div class="toggle">
          <label class="switch"><input type="checkbox" id="toggleAnim" checked /><span class="slider"></span></label>
          <span>Animate Grain</span>
        </div>
      </div>

      <div class="section">Image</div>
      <div class="group">
        <label class="file-label" for="file" id="fileLabel">ðŸ“· Load Image (Click or Drag)</label>
        <input type="file" id="file" accept="image/*" />
      </div>
      <div class="group"><button id="dlWith" style="width:100%">Download Full Image</button></div>
      <div class="group"><button id="dlGrain" style="width:100%">Download Grain Layer</button></div>
    </aside>

    <div class="stage-wrap">
      <section id="stage">
        <canvas id="glcanvas"></canvas>
        <div class="hud">
          <div>Image: <span id="infoImage">-</span></div>
          <div>View: <span id="infoView">-</span></div>
          <div>Zoom: <span id="infoZoom">100%</span></div>
        </div>
        <div class="perf">FPS: <span id="fps">60</span></div>
        <div class="zoom-controls">
          <button id="zoomFit">â¬š</button>
          <button id="zoom100">1:1</button>
        </div>
      </section>
    </div>
  </div>

<script>
(function(){
  const d = (sel) => document.querySelector(sel);
  const glCanvas = d('#glcanvas');
  /** @type {WebGL2RenderingContext} */
  let gl = glCanvas.getContext('webgl2', { premultipliedAlpha: false, alpha: false, antialias: false });
  if (!gl) { alert('WebGL2 not available.'); return; }

  // --- Shaders ---
  const VERT = `#version 300 es
  precision highp float;
  layout(location=0) in vec2 a_pos;
  out vec2 v_uv;
  void main(){ v_uv = a_pos*0.5+0.5; gl_Position = vec4(a_pos,0.0,1.0); }`;

  // FRAGMENT with orientation fix + anti-aliasing improvements
  const FRAG = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  uniform sampler2D u_image;
  uniform vec2  u_imageSize;
  uniform vec2  u_viewSize;
  uniform vec2  u_offset;        // in image pixels (top-left origin)
  uniform float u_scale;         // screen px per image px (1.0 = 1:1)
  uniform float u_time;

  uniform float u_intensity;
  uniform float u_grainSize;
  uniform int   u_pattern;       // 0 organic,1 halide,2 digital,3 vintage
  uniform int   u_blend;         // 0 overlay,1 softlight,2 screen,3 multiply
  uniform float u_opacity;
  uniform float u_response;
  uniform float u_contrast;
  uniform float u_saturation;
  uniform float u_sharpness;
  uniform int   u_colorMode;     // 0 mono,1 subtle,2 chromatic
  uniform bool  u_showOriginal;
  uniform bool  u_grainOnly;
  out vec4 fragColor;

  float luma(vec3 c){ return dot(c, vec3(0.299, 0.587, 0.114)); }
  float hash31(vec3 p){ return fract(sin(dot(p, vec3(12.9898,78.233,37.719))) * 43758.5453); }
  vec3 fade3(vec3 t){ return t*t*t*(t*(t*6.0-15.0)+10.0); }
  float valueNoise(vec3 p){
    vec3 i=floor(p), f=fract(p), u=fade3(f);
    float n000=hash31(i+vec3(0,0,0)), n100=hash31(i+vec3(1,0,0));
    float n010=hash31(i+vec3(0,1,0)), n110=hash31(i+vec3(1,1,0));
    float n001=hash31(i+vec3(0,0,1)), n101=hash31(i+vec3(1,0,1));
    float n011=hash31(i+vec3(0,1,1)), n111=hash31(i+vec3(1,1,1));
    float nx00=mix(n000,n100,u.x), nx10=mix(n010,n110,u.x);
    float nx01=mix(n001,n101,u.x), nx11=mix(n011,n111,u.x);
    float nxy0=mix(nx00,nx10,u.y), nxy1=mix(nx01,nx11,u.y);
    return mix(nxy0,nxy1,u.z);
  }
  float fbm(vec3 p){ float s=0.0,a=0.5; for(int i=0;i<4;i++){ s+=a*valueNoise(p); p*=2.0; a*=0.5; } return s; }

  float blendOverlay(float b,float o){ return b<0.5? 2.0*b*o: 1.0-2.0*(1.0-b)*(1.0-o); }
  float blendSoftLight(float b,float o){ return (o<0.5)? (2.0*b*o + b*b*(1.0-2.0*o)) : (sqrt(max(b,0.0))*(2.0*o-1.0) + 2.0*b*(1.0-o)); }
  float blendScreen(float b,float o){ return 1.0-(1.0-b)*(1.0-o); }
  float blendMultiply(float b,float o){ return b*o; }
  vec3  applyBlend(vec3 B, vec3 O, int m){
    if(m==0) return vec3(blendOverlay(B.r,O.r), blendOverlay(B.g,O.g), blendOverlay(B.b,O.b));
    if(m==1) return vec3(blendSoftLight(B.r,O.r), blendSoftLight(B.g,O.g), blendSoftLight(B.b,O.b));
    if(m==2) return vec3(blendScreen(B.r,O.r), blendScreen(B.g,O.g), blendScreen(B.b,O.b));
    return vec3(blendMultiply(B.r,O.r), blendMultiply(B.g,O.g), blendMultiply(B.b,O.b));
  }
  vec3 satAdjust(vec3 c,float s){ float L=luma(c); return mix(vec3(L),c,s); }

  float edgeMag(vec2 uv){
    vec2 texel=1.0/u_imageSize;
    float tl=luma(texture(u_image, uv + texel*vec2(-1,-1)).rgb);
    float  t=luma(texture(u_image, uv + texel*vec2( 0,-1)).rgb);
    float tr=luma(texture(u_image, uv + texel*vec2( 1,-1)).rgb);
    float l =luma(texture(u_image, uv + texel*vec2(-1, 0)).rgb);
    float r =luma(texture(u_image, uv + texel*vec2( 1, 0)).rgb);
    float bl=luma(texture(u_image, uv + texel*vec2(-1, 1)).rgb);
    float b =luma(texture(u_image, uv + texel*vec2( 0, 1)).rgb);
    float br=luma(texture(u_image, uv + texel*vec2( 1, 1)).rgb);
    float gx = -tl -2.0*l -bl + tr + 2.0*r + br;
    float gy = -tl -2.0*t -tr + bl + 2.0*b + br;
    return clamp(sqrt(gx*gx+gy*gy), 0.0, 1.0);
  }

  void main(){
    // Screen pixel in TOP-LEFT origin (since v_uv is bottom-left, invert Y once)
    vec2 fragTL = vec2(v_uv.x * u_viewSize.x, (1.0 - v_uv.y) * u_viewSize.y);
    vec2 ip = u_offset + fragTL / max(u_scale, 1e-6);      // image pixels (TOP-LEFT origin)

    // Orientation fix: sample in bottom-left uv space (texture is flipped on upload)
    vec2 uv = vec2(ip.x / u_imageSize.x, 1.0 - ip.y / u_imageSize.y);

    if(any(lessThan(uv, vec2(0.0))) || any(greaterThan(uv, vec2(1.0)))){
      fragColor = vec4(0.0,0.0,0.0,1.0); return;
    }

    vec3 base = texture(u_image, uv).rgb;
    if(u_showOriginal && !u_grainOnly){ fragColor = vec4(base,1.0); return; }

    // --- Grain domain (anti-aliasing + decorrelation) ---
    vec2 gp = ip / max(u_grainSize, 0.001);
    // rotate domain (~30Â°) to avoid alignment with the screen lattice
    const mat2 R = mat2(0.8660254, -0.5, 0.5, 0.8660254);
    gp = R * gp;
    // derivative-scaled jitter to break residual lock-in
    vec2 gw = fwidth(gp);
    vec2 j = vec2(hash31(vec3(ip, u_time)) - 0.5,
                  hash31(vec3(ip.yx, u_time + 17.0)) - 0.5) * gw;
    gp += j;

    float t = u_time;
    float g;
    if(u_pattern==0){ g = fbm(vec3(gp, t*0.5)); }
    else if(u_pattern==1){ float n = valueNoise(vec3(gp*1.2, t*0.8)); g = step(0.7, n); }
    else if(u_pattern==2){ g = hash31(vec3(floor(gp), floor(t*60.0))); } // cell-random
    else { g = pow(fbm(vec3(gp*0.5, t*0.3)), 1.5); }

    // Band-limit: when grains are sub-pixel, fade to temporally varying white noise
    float pixelNoise = hash31(vec3(floor(ip), floor(t*60.0)));
    float k = smoothstep(2.0, 0.8, u_grainSize); // 0â†’pattern, 1â†’white noise
    g = mix(g, pixelNoise, k);

    // Film response
    float L = luma(base);
    float resp = 1.0 - L * u_response;
    g = (g - 0.5) * u_intensity * resp + 0.5;

    // Color variation
    float rD=0.0, gD=0.0, bD=0.0;
    if(u_colorMode==1){ float vAmp=0.02;
      rD=(hash31(vec3(gp,t+1.0))-0.5)*2.0*vAmp;
      gD=(hash31(vec3(gp,t+2.0))-0.5)*2.0*vAmp;
      bD=(hash31(vec3(gp,t+3.0))-0.5)*2.0*vAmp;
    }
    vec3 grainRGB = vec3(g + rD, g + gD, g + bD);
    if(u_colorMode==2){ grainRGB.r *= 1.02; grainRGB.b *= 0.98; }

    if(u_grainOnly){ fragColor = vec4(clamp(grainRGB,0.0,1.0),1.0); return; }

    vec3 blended = applyBlend(base, clamp(grainRGB,0.0,1.0), u_blend);
    float att = mix(1.0, 1.0 - edgeMag(uv), clamp(u_sharpness,0.0,1.0));
    vec3 col = mix(base, blended, clamp(u_opacity*att, 0.0, 1.0));
    col = ((col - 0.5) * u_contrast + 0.5);
    col = satAdjust(col, u_saturation);
    fragColor = vec4(clamp(col,0.0,1.0), 1.0);
  }`;

  function makeProgram(gl, vsSrc, fsSrc){
    const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vsSrc); gl.compileShader(vs);
    if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) throw new Error('VS error: '+gl.getShaderInfoLog(vs));
    const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, fsSrc); gl.compileShader(fs);
    if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) throw new Error('FS error: '+gl.getShaderInfoLog(fs));
    const prog = gl.createProgram(); gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error('Link error: '+gl.getProgramInfoLog(prog));
    gl.deleteShader(vs); gl.deleteShader(fs); return prog;
  }

  const program = makeProgram(gl, VERT, FRAG);
  gl.useProgram(program);

  // Fullscreen quad
  const vao = gl.createVertexArray(); gl.bindVertexArray(vao);
  const vbuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

  // Uniform locations
  const U = {
    image: gl.getUniformLocation(program, 'u_image'),
    imageSize: gl.getUniformLocation(program, 'u_imageSize'),
    viewSize: gl.getUniformLocation(program, 'u_viewSize'),
    offset: gl.getUniformLocation(program, 'u_offset'),
    scale: gl.getUniformLocation(program, 'u_scale'),
    time: gl.getUniformLocation(program, 'u_time'),
    intensity: gl.getUniformLocation(program, 'u_intensity'),
    grainSize: gl.getUniformLocation(program, 'u_grainSize'),
    pattern: gl.getUniformLocation(program, 'u_pattern'),
    blend: gl.getUniformLocation(program, 'u_blend'),
    opacity: gl.getUniformLocation(program, 'u_opacity'),
    response: gl.getUniformLocation(program, 'u_response'),
    contrast: gl.getUniformLocation(program, 'u_contrast'),
    saturation: gl.getUniformLocation(program, 'u_saturation'),
    sharpness: gl.getUniformLocation(program, 'u_sharpness'),
    colorMode: gl.getUniformLocation(program, 'u_colorMode'),
    showOriginal: gl.getUniformLocation(program, 'u_showOriginal'),
    grainOnly: gl.getUniformLocation(program, 'u_grainOnly'),
  };

  // State
  const state = {
    imageTex: null,
    imageSize: {w: 0, h: 0},
    viewSize: {w: 960, h: 450}, // default MEDIUM
    offset: {x: 0, y: 0},       // top-left origin
    scale: 1,
    animate: true,
    showOriginal: false,
    params: { intensity: 0.5, grainSize: 2.0, pattern: 0, blend: 0, opacity: 0.5, response: 0.5, sharp: 0.7, contrast: 1.0, color: 0, sat: 1.0 },
    dragging: false, start: {x: 0,y: 0}, startOffset: {x:0,y:0},
    fps: 60, lastRAF: performance.now(),
  };

  // Helpers
  function setCanvasSize(w,h){
    glCanvas.width = w; glCanvas.height = h;
    glCanvas.style.width = w + 'px';
    glCanvas.style.height = h + 'px';
    const stage = d('#stage');
    stage.style.width = w + 'px';
    stage.style.height = h + 'px';
    gl.viewport(0,0,w,h);
    state.viewSize = {w, h};
    d('#infoView').textContent = `${w}Ã—${h}`;
    clampOffsets();
  }
  setCanvasSize(state.viewSize.w, state.viewSize.h);

  function createTexture(img){
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    // Flip on upload so sampling with bottom-left uv keeps the image upright
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
    return tex;
  }

  function setTextureFiltering(){
    gl.bindTexture(gl.TEXTURE_2D, state.imageTex);
    const filter = (Math.abs(state.scale - 1.0) < 1e-4) ? gl.NEAREST : gl.LINEAR;
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
  }

  function setImage(img){
    if (state.imageTex) gl.deleteTexture(state.imageTex);
    state.imageTex = createTexture(img);
    state.imageSize = {w: img.naturalWidth || img.width, h: img.naturalHeight || img.height};
    d('#infoImage').textContent = `${state.imageSize.w}Ã—${state.imageSize.h}`;
    // Center in current view at 1:1
    state.scale = 1;
    state.offset.x = Math.max(0, (state.imageSize.w - state.viewSize.w) * 0.5);
    state.offset.y = Math.max(0, (state.imageSize.h - state.viewSize.h) * 0.5);
    updateZoomInfo();
    setTextureFiltering();
  }

  // Placeholder gradient image
  (function createPlaceholder(){
    const c = document.createElement('canvas'); c.width = 800; c.height = 600;
    const cx = c.getContext('2d');
    const g = cx.createLinearGradient(0,0,800,600); g.addColorStop(0,'#444'); g.addColorStop(0.5,'#666'); g.addColorStop(1,'#888');
    cx.fillStyle = g; cx.fillRect(0,0,c.width,c.height);
    cx.fillStyle = 'rgba(255,255,255,0.2)'; cx.font = '48px sans-serif'; cx.textAlign='center'; cx.fillText('Load an image', 400, 300);
    const img = new Image(); img.onload = ()=> setImage(img); img.src = c.toDataURL();
  })();

  // Controls
  function bindRange(id, key){
    const s = d('#'+id), n = d('#'+id+'N'), v = d('#v-'+(id==='size'?'size': id==='sat'?'sat': id));
    const sync = (val)=>{ s.value = val; n.value = val; if(v) v.textContent = (+val).toFixed(2); };
    s.addEventListener('input', ()=>{ state.params[key] = +s.value; sync(s.value); });
    n.addEventListener('change', ()=>{ state.params[key] = +n.value; sync(n.value); });
    sync(state.params[key]);
  }
  bindRange('intensity','intensity');
  bindRange('size','grainSize');
  bindRange('opacity','opacity');
  bindRange('response','response');
  bindRange('sharp','sharp');
  bindRange('contrast','contrast');
  bindRange('sat','sat');

  d('#pattern').addEventListener('change', e=> state.params.pattern = +e.target.value);
  d('#blend').addEventListener('change', e=> state.params.blend = +e.target.value);
  d('#color').addEventListener('change', e=> state.params.color = +e.target.value);
  d('#toggleOriginal').addEventListener('change', e=> state.showOriginal = !!e.target.checked);
  d('#toggleAnim').addEventListener('change', e=> state.animate = !!e.target.checked);

  // Presets
  d('#p35').addEventListener('click', ()=> applyPreset({ intensity:.6, grainSize:2.5, pattern:0, blend:0, opacity:.7, response:.6, sharp:.6, contrast:1.1, color:1, sat:1.1 }));
  d('#p120').addEventListener('click',()=> applyPreset({ intensity:.3, grainSize:1.5, pattern:0, blend:1, opacity:.5, response:.4, sharp:.8, contrast:1.0, color:0, sat:1.0 }));
  d('#pPush').addEventListener('click',()=> applyPreset({ intensity:.9, grainSize:4.0, pattern:1, blend:0, opacity:.8, response:.8, sharp:.5, contrast:1.3, color:2, sat:.9 }));
  d('#pMin').addEventListener('click', ()=> applyPreset({ intensity:.2, grainSize:1.0, pattern:2, blend:0, opacity:.3, response:.3, sharp:.9, contrast:1.0, color:0, sat:1.0 }));
  function applyPreset(p){ Object.assign(state.params, p);
    [['intensity','intensity'],['size','grainSize'],['opacity','opacity'],['response','response'],['sharp','sharp'],['contrast','contrast'],['sat','sat']].forEach(([id,key])=>{
      const val = state.params[key]; const s=d('#'+id), n=d('#'+id+'N'), v=d('#v-'+(id==='size'?'size': id==='sat'?'sat': id));
      s.value = val; n.value = val; if(v) v.textContent=(+val).toFixed(2);
    });
    d('#pattern').value = p.pattern; d('#blend').value = p.blend; d('#color').value = p.color;
  }

  // Preview size controls
  const btnS = d('#sizeS'), btnM = d('#sizeM'), btnL = d('#sizeL');
  function setActive(b){ [btnS,btnM,btnL].forEach(x=>x.classList.remove('active')); b.classList.add('active'); }
  btnS.addEventListener('click', ()=>{ setActive(btnS); setCanvasSize(720,405); updateZoomInfo(); });
  btnM.addEventListener('click', ()=>{ setActive(btnM); setCanvasSize(960,450); updateZoomInfo(); });
  btnL.addEventListener('click', ()=>{ setActive(btnL); setCanvasSize(1280,720); updateZoomInfo(); });

  // File input & DnD
  const fileInput = d('#file'); const fileLabel = d('#fileLabel');
  ['dragover','drop'].forEach(evt=> document.body.addEventListener(evt, e=>{ e.preventDefault(); e.stopPropagation(); }));
  fileLabel.addEventListener('dragover', e=>{ e.preventDefault(); fileLabel.classList.add('drag-over'); });
  fileLabel.addEventListener('dragleave', ()=> fileLabel.classList.remove('drag-over'));
  fileLabel.addEventListener('drop', e=>{ fileLabel.classList.remove('drag-over'); const f=e.dataTransfer.files?.[0]; if(f && f.type.startsWith('image/')) handleFile(f); });
  fileInput.addEventListener('change', e=>{ const f=e.target.files?.[0]; if(f) handleFile(f); });
  function handleFile(file){ const r=new FileReader(); r.onload = ()=>{ const img = new Image(); img.onload = ()=> setImage(img); img.src = r.result; }; r.readAsDataURL(file); }

  // Pan & Zoom (top-left origin for offsets)
  const stage = d('#stage');
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function clampOffsets(){
    const maxX = Math.max(0, state.imageSize.w - state.viewSize.w / state.scale);
    const maxY = Math.max(0, state.imageSize.h - state.viewSize.h / state.scale);
    state.offset.x = clamp(state.offset.x, 0, maxX);
    state.offset.y = clamp(state.offset.y, 0, maxY);
  }
  stage.addEventListener('mousedown', e=>{ state.dragging = true; state.start.x=e.clientX; state.start.y=e.clientY; state.startOffset.x=state.offset.x; state.startOffset.y=state.offset.y; stage.style.cursor='grabbing'; });
  window.addEventListener('mousemove', e=>{ if(!state.dragging) return; const dx = (e.clientX - state.start.x); const dy = (e.clientY - state.start.y); state.offset.x = state.startOffset.x - dx / state.scale; state.offset.y = state.startOffset.y - dy / state.scale; clampOffsets(); });
  window.addEventListener('mouseup', ()=>{ state.dragging=false; stage.style.cursor='move'; });

  d('#zoom100').addEventListener('click', ()=>{ state.scale = 1; clampOffsets(); setTextureFiltering(); updateZoomInfo(); });
  d('#zoomFit').addEventListener('click', ()=>{
    if(!state.imageSize.w) return;
    const sx = state.viewSize.w / state.imageSize.w;
    const sy = state.viewSize.h / state.imageSize.h;
    state.scale = Math.min(sx, sy);
    state.offset.x=0; state.offset.y=0; clampOffsets(); setTextureFiltering(); updateZoomInfo();
  });
  function updateZoomInfo(){ d('#infoZoom').textContent = `${Math.round(state.scale*100)}%`; }

  // Downloads (render full-res temporarily into the main canvas, then restore)
  function renderToSize(width, height, grainOnly=false){
    const prev = { w: glCanvas.width, h: glCanvas.height, scale: state.scale, offX: state.offset.x, offY: state.offset.y, viewW: state.viewSize.w, viewH: state.viewSize.h };
    glCanvas.width = width; glCanvas.height = height; gl.viewport(0,0,width,height);
    state.viewSize = {w: width, h: height}; state.scale = 1; state.offset.x = 0; state.offset.y = 0;
    drawFrame(performance.now(), grainOnly);
    return function restore(){
      glCanvas.width = prev.w; glCanvas.height = prev.h;
      gl.viewport(0,0,prev.w,prev.h);
      setCanvasSize(prev.viewW, prev.viewH);
      state.scale = prev.scale; state.offset.x = prev.offX; state.offset.y = prev.offY;
    };
  }
  d('#dlWith').addEventListener('click', ()=>{
    if(!state.imageSize.w) return;
    const restore = renderToSize(state.imageSize.w, state.imageSize.h, false);
    glCanvas.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='image_with_grain.png'; a.click(); URL.revokeObjectURL(a.href); restore(); });
  });
  d('#dlGrain').addEventListener('click', ()=>{
    if(!state.imageSize.w) return;
    const restore = renderToSize(state.imageSize.w, state.imageSize.h, true);
    glCanvas.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='grain_layer.png'; a.click(); URL.revokeObjectURL(a.href); restore(); });
  });

  // Draw loop
  function drawFrame(now, grainOnly=false){
    const tSec = now * 0.001;
    gl.useProgram(program); gl.bindVertexArray(vao);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, state.imageTex); gl.uniform1i(U.image, 0);
    gl.uniform2f(U.imageSize, state.imageSize.w, state.imageSize.h);
    gl.uniform2f(U.viewSize, state.viewSize.w, state.viewSize.h);
    gl.uniform2f(U.offset, state.offset.x, state.offset.y);
    gl.uniform1f(U.scale, state.scale);
    gl.uniform1f(U.time, state.animate ? tSec : 0.0);
    gl.uniform1f(U.intensity, state.params.intensity);
    gl.uniform1f(U.grainSize, state.params.grainSize);
    gl.uniform1i(U.pattern, state.params.pattern);
    gl.uniform1i(U.blend, state.params.blend);
    gl.uniform1f(U.opacity, state.params.opacity);
    gl.uniform1f(U.response, state.params.response);
    gl.uniform1f(U.contrast, state.params.contrast);
    gl.uniform1f(U.saturation, state.params.sat);
    gl.uniform1f(U.sharpness, state.params.sharp);
    gl.uniform1i(U.colorMode, state.params.color);
    gl.uniform1i(U.showOriginal, state.showOriginal?1:0);
    gl.uniform1i(U.grainOnly, grainOnly?1:0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  function loop(now){
    drawFrame(now, false);
    const dt = now - state.lastRAF; state.fps = Math.round(1000 / (dt||1)); state.lastRAF = now; d('#fps').textContent = state.fps;
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Handle context loss
  glCanvas.addEventListener('webglcontextlost', (e)=>{ e.preventDefault(); });
  glCanvas.addEventListener('webglcontextrestored', ()=>{ gl.useProgram(program); gl.bindVertexArray(vao); gl.viewport(0,0,glCanvas.width,glCanvas.height); });
})();
</script>
</body>
</html>
