<style>
  :root {
    --primary: #2563eb;
    --primary-hover: #1d4ed8;
    --secondary: #64748b;
    --success: #059669;
    --warning: #d97706;
    --danger: #dc2626;
    --info: #0891b2;
    
    --bg-primary: #ffffff;
    --bg-secondary: #f8fafc;
    --bg-tertiary: #f1f5f9;
    --surface: #ffffff;
    --surface-hover: #f8fafc;
    
    --text-primary: #0f172a;
    --text-secondary: #475569;
    --text-muted: #94a3b8;
    
    --border: #e2e8f0;
    --border-hover: #cbd5e1;
    
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
    
    --radius: 8px;
    --radius-lg: 12px;
    --radius-xl: 16px;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: var(--bg-secondary);
    color: var(--text-primary);
    line-height: 1.6;
    min-height: 100vh;
    overflow-x: hidden;
}

/* Header */
.header {
    position: relative;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 2rem 0;
    text-align: center;
    overflow: hidden;
}

.header-bg {
    display: none;
}

.header-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 2rem;
    text-align: center;
    position: relative;
    z-index: 2;
}

.logo {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    margin-bottom: 0.75rem;
}

.logo-icon {
    font-size: 1.5rem;
    animation: none;
}

.header h1 {
    font-size: 2.25rem;
    font-weight: 700;
    margin: 0;
    color: var(--text-primary);
}

.subtitle {
    font-size: 1rem;
    opacity: 0.9;
    font-weight: 400;
    text-shadow: none;
    margin-top: 0.5rem;
}

/* Container */
.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
}

/* Upload Zone */
.upload-zone {
    position: relative;
    background: var(--surface);
    border: 2px dashed var(--border);
    border-radius: var(--radius-xl);
    padding: 3rem 2rem;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-bottom: 2rem;
    overflow: hidden;
}

.upload-zone::before {
    display: none;
}

.upload-zone:hover {
    border-color: var(--primary);
    background: var(--bg-tertiary);
    transform: none;
    box-shadow: var(--shadow-md);
}

.upload-zone.dragover {
    border-color: var(--primary);
    background: var(--bg-tertiary);
    transform: none;
    box-shadow: var(--shadow-lg);
}

.upload-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
    color: var(--text-muted);
}

.upload-title {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    color: var(--text-primary);
}

.upload-subtitle {
    font-size: 0.875rem;
    color: var(--text-secondary);
    font-weight: 400;
}

/* Controls */
.controls {
    background: var(--surface);
    padding: 2rem;
    border-radius: var(--radius-xl);
    margin-bottom: 2rem;
    border: 1px solid var(--border);
    box-shadow: var(--shadow-sm);
    display: none;
    animation: slideIn 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.controls.active {
    display: block;
}

@keyframes slideIn {
    0% {
        opacity: 0;
        transform: translateY(10px);
    }
    100% {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Stats Grid */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 2rem;
}

.stat-card {
    background: var(--surface);
    padding: 1.5rem;
    border-radius: var(--radius-lg);
    text-align: left;
    position: relative;
    border: 1px solid var(--border);
    transition: all 0.2s ease;
}

.stat-card:hover {
    border-color: var(--border-hover);
    box-shadow: var(--shadow-md);
    transform: none;
}

.stat-value {
    font-size: 2rem;
    font-weight: 700;
    color: var(--primary);
    margin-bottom: 0.25rem;
    background: none;
    -webkit-text-fill-color: unset;
}

.stat-label {
    font-size: 0.875rem;
    color: var(--text-secondary);
    font-weight: 500;
    margin-bottom: 0.5rem;
}

.stat-icon {
    position: absolute;
    top: 1rem;
    right: 1rem;
    font-size: 1.25rem;
    color: var(--text-muted);
    opacity: 0.6;
}

/* Progress */
.progress {
    position: relative;
    background: var(--bg-tertiary);
    height: 12px;
    border-radius: 6px;
    overflow: hidden;
    margin-bottom: 2rem;
    display: none;
    border: 1px solid var(--border);
}

.progress.active {
    display: block;
    animation: slideIn 0.4s ease;
}

.progress-bar {
    background: var(--primary);
    height: 100%;
    width: 0%;
    transition: width 0.3s ease;
    border-radius: 6px;
    position: relative;
}

.progress-text {
    position: absolute;
    top: -2rem;
    left: 0;
    right: 0;
    color: var(--text-secondary);
    font-weight: 500;
    font-size: 0.875rem;
    text-shadow: none;
}

.progress-glow {
    display: none;
}

/* Buttons */
.action-buttons {
    display: flex;
    gap: 0.75rem;
    justify-content: center;
    flex-wrap: wrap;
}

.btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.5rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    cursor: pointer;
    font-weight: 500;
    font-size: 0.875rem;
    transition: all 0.2s ease;
    text-decoration: none;
    position: relative;
    overflow: visible;
}

.btn::before {
    display: none;
}

.btn-primary {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
    box-shadow: var(--shadow-sm);
}

.btn-primary:hover {
    background: var(--primary-hover);
    border-color: var(--primary-hover);
    box-shadow: var(--shadow-md);
    transform: none;
}

.btn-secondary {
    background: var(--surface);
    color: var(--text-primary);
    border-color: var(--border);
    box-shadow: var(--shadow-sm);
}

.btn-secondary:hover {
    background: var(--surface-hover);
    border-color: var(--border-hover);
    box-shadow: var(--shadow-md);
    transform: none;
}

.btn-danger {
    background: var(--danger);
    color: white;
    border-color: var(--danger);
    box-shadow: var(--shadow-sm);
}

.btn-danger:hover {
    background: #b91c1c;
    border-color: #b91c1c;
    box-shadow: var(--shadow-md);
    transform: none;
}

.btn:active {
    transform: scale(0.98);
}

/* Log */
.log-container {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius-xl);
    margin-bottom: 2rem;
    display: none;
    overflow: hidden;
    box-shadow: var(--shadow-sm);
    animation: slideIn 0.4s ease;
}

.log-container.active {
    display: block;
}

.log-header {
    background: var(--bg-tertiary);
    padding: 1rem 1.5rem;
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.log-header h3 {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
}

.log-toggle {
    background: none;
    border: none;
    color: var(--text-muted);
    font-size: 1.25rem;
    cursor: pointer;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--radius);
    transition: all 0.2s ease;
}

.log-toggle:hover {
    background: var(--bg-secondary);
    color: var(--text-primary);
}

.log {
    padding: 1rem;
    height: 300px;
    overflow-y: auto;
    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    font-size: 0.8125rem;
    line-height: 1.4;
    background: var(--bg-tertiary);
}

.log-entry {
    margin-bottom: 0.25rem;
    padding: 0.25rem 0.5rem;
    border-radius: var(--radius);
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    0% { opacity: 0; }
    100% { opacity: 1; }
}

.log-success { color: var(--success); background: rgba(5, 150, 105, 0.1); }
.log-error { color: var(--danger); background: rgba(220, 38, 38, 0.1); }
.log-warning { color: var(--warning); background: rgba(217, 119, 6, 0.1); }
.log-info { color: var(--info); background: rgba(8, 145, 178, 0.1); }

/* Images Grid */
.images-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 1.5rem;
    animation: fadeIn 0.6s ease;
}

.image-card {
    background: var(--surface);
    border-radius: var(--radius-xl);
    overflow: hidden;
    border: 1px solid var(--border);
    transition: all 0.2s ease;
    box-shadow: var(--shadow-sm);
    animation: scaleIn 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes scaleIn {
    0% { opacity: 0; transform: scale(0.95); }
    100% { opacity: 1; transform: scale(1); }
}

.image-card:hover {
    box-shadow: var(--shadow-lg);
    border-color: var(--border-hover);
    transform: translateY(-2px);
}

.image-preview {
    width: 100%;
    height: 200px;
    background: var(--bg-tertiary);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.image-preview::before {
    display: none;
}

.image-preview img,
.image-preview canvas {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    transition: transform 0.2s ease;
}

.image-preview:hover img,
.image-preview:hover canvas {
    transform: scale(1.02);
}

.image-preview .data-stream {
    color: var(--text-muted);
    text-align: center;
    padding: 1rem;
}

.image-info {
    padding: 1.25rem;
}

.image-details {
    font-size: 0.875rem;
    color: var(--text-secondary);
    margin-bottom: 1rem;
    line-height: 1.5;
}

.image-details strong {
    color: var(--text-primary);
    font-weight: 600;
    background: none;
    -webkit-text-fill-color: unset;
}

/* Modal */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1000;
    align-items: center;
    justify-content: center;
}

.modal.active {
    display: flex;
    animation: fadeIn 0.3s ease;
}

.modal-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(4px);
}

.modal-content {
    position: relative;
    max-width: 90%;
    max-height: 90%;
    z-index: 2;
    border-radius: var(--radius-lg);
    overflow: hidden;
    box-shadow: var(--shadow-lg);
    background: var(--surface);
}

.modal-content img,
.modal-content canvas {
    max-width: 100%;
    max-height: 90vh;
    object-fit: contain;
    display: block;
}

.modal-close {
    position: absolute;
    top: -3rem;
    right: 0;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text-primary);
    font-size: 1.5rem;
    cursor: pointer;
    width: 40px;
    height: 40px;
    border-radius: var(--radius);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    box-shadow: var(--shadow-md);
}

.modal-close:hover {
    background: var(--bg-tertiary);
    transform: none;
}

/* Responsive */
@media (max-width: 768px) {
    .container {
        padding: 1rem;
    }
    
    .header-content {
        padding: 0 1rem;
    }
    
    .upload-zone {
        padding: 2rem 1rem;
    }
    
    .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 1rem;
    }
    
    .action-buttons {
        flex-direction: column;
        align-items: stretch;
    }
    
    .images-grid {
        grid-template-columns: 1fr;
        gap: 1.5rem;
    }
    
    .header {
        padding: 1.5rem 0;
    }
    
    .header h1 {
        font-size: 1.875rem;
    }
    
    .logo {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .logo-icon {
        font-size: 2rem;
    }
}

/* Scrollbar */
.log::-webkit-scrollbar {
    width: 6px;
}

.log::-webkit-scrollbar-track {
    background: var(--bg-secondary);
    border-radius: 3px;
}

.log::-webkit-scrollbar-thumb {
    background: var(--border-hover);
    border-radius: 3px;
}

.log::-webkit-scrollbar-thumb:hover {
    background: var(--text-muted);
}

/* Selection */
::selection {
    background: rgba(37, 99, 235, 0.2);
}
</style>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate PDF Image Extractor</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cal+Sans:wght@400;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="logo">
                <span class="logo-icon">🔥</span>
                <h1>Ultimate PDF Image Extractor</h1>
                <span class="logo-icon">🔥</span>
            </div>
            <p class="subtitle">Extract ALL images at FULL resolution • No dependencies • Maximum extraction power</p>
        </div>
        <div class="header-bg"></div>
    </div>

    <div class="container">
        <div class="upload-zone" id="uploadZone">
            <div class="upload-icon">📄</div>
            <h2 class="upload-title">Drop PDF Here or Click to Upload</h2>
            <p class="upload-subtitle">Advanced multi-method extraction • Full resolution preservation</p>
            <input type="file" id="fileInput" accept=".pdf" hidden>
            <div class="upload-shimmer"></div>
        </div>

        <div class="controls" id="controls">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="statImages">0</div>
                    <div class="stat-label">Images Found</div>
                    <div class="stat-icon">🖼️</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statSize">0</div>
                    <div class="stat-label">Total MB</div>
                    <div class="stat-icon">💾</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statLargest">0</div>
                    <div class="stat-label">Largest (px)</div>
                    <div class="stat-icon">📐</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statFormats">-</div>
                    <div class="stat-label">Formats</div>
                    <div class="stat-icon">🎨</div>
                </div>
            </div>
            
            <div class="progress" id="progress">
                <div class="progress-bar" id="progressBar">
                    <span class="progress-text">0%</span>
                </div>
                <div class="progress-glow"></div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" onclick="downloadAll()">
                    <span class="btn-icon">📥</span>
                    Download All
                </button>
                <button class="btn btn-secondary" onclick="toggleLog()">
                    <span class="btn-icon">📋</span>
                    Show/Hide Log
                </button>
                <button class="btn btn-danger" onclick="clearAll()">
                    <span class="btn-icon">🗑️</span>
                    Clear
                </button>
            </div>
        </div>

        <div class="log-container" id="logContainer">
            <div class="log-header">
                <h3>Extraction Log</h3>
                <button class="log-toggle" onclick="toggleLog()">×</button>
            </div>
            <div class="log" id="log"></div>
        </div>

        <div class="images-grid" id="imagesGrid"></div>
    </div>

    <div class="modal" id="modal">
        <div class="modal-backdrop" onclick="closeModal()"></div>
        <div class="modal-content" id="modalContent">
            <button class="modal-close" onclick="closeModal()">×</button>
        </div>
    </div>

    <script src="app.js"></script>
</body>
</html>

<script>
  // Global variables
let extractedImages = [];
let currentFileName = '';
let logElement, progressElement, progressBar, progressText;

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    logElement = document.getElementById('log');
    progressElement = document.getElementById('progress');
    progressBar = document.getElementById('progressBar');
    progressText = progressBar.querySelector('.progress-text');
    
    const uploadZone = document.getElementById('uploadZone');
    const fileInput = document.getElementById('fileInput');
    
    uploadZone.addEventListener('click', () => fileInput.click());
    
    uploadZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadZone.classList.add('dragover');
    });
    
    uploadZone.addEventListener('dragleave', () => {
        uploadZone.classList.remove('dragover');
    });
    
    uploadZone.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadZone.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file && file.type === 'application/pdf') {
            processPDF(file);
        }
    });
    
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) processPDF(file);
    });
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeModal();
    });
});

function log(message, type = 'info') {
    const entry = document.createElement('div');
    entry.className = `log-entry log-${type}`;
    const timestamp = new Date().toLocaleTimeString();
    entry.textContent = `[${timestamp}] ${message}`;
    logElement.appendChild(entry);
    logElement.scrollTop = logElement.scrollHeight;
}

function updateProgress(percent, text) {
    progressElement.classList.add('active');
    progressBar.style.width = percent + '%';
    progressText.textContent = text || percent + '%';
}

async function processPDF(file) {
    currentFileName = file.name.replace('.pdf', '');
    extractedImages = [];
    
    // Reset UI
    document.getElementById('imagesGrid').innerHTML = '';
    logElement.innerHTML = '';
    document.getElementById('logContainer').classList.add('active');
    document.getElementById('controls').classList.add('active');
    
    log('=== STARTING AGGRESSIVE PDF EXTRACTION ===', 'success');
    log(`File: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`, 'info');
    
    updateProgress(10, 'Reading file...');
    
    const arrayBuffer = await file.arrayBuffer();
    const bytes = new Uint8Array(arrayBuffer);
    
    log(`Loaded ${bytes.length} bytes`, 'info');
    
    // Method 1: Find JPEG markers
    updateProgress(20, 'Scanning for JPEGs...');
    await findJPEGs(bytes);
    
    // Method 2: Find PNG signatures
    updateProgress(40, 'Scanning for PNGs...');
    await findPNGs(bytes);
    
    // Method 3: Find PDF Image XObjects
    updateProgress(60, 'Parsing PDF objects...');
    await findPDFImages(bytes);
    
    // Method 4: Find inline images
    updateProgress(80, 'Finding inline images...');
    await findInlineImages(bytes);
    
    // Method 5: Extract from streams
    updateProgress(90, 'Extracting streams...');
    await extractStreams(bytes);
    
    // Display results
    updateProgress(100, 'Complete!');
    displayResults();
    
    setTimeout(() => {
        progressElement.classList.remove('active');
    }, 2000);
}

async function findJPEGs(bytes) {
    log('Scanning for JPEG images...', 'info');
    let count = 0;
    
    for (let i = 0; i < bytes.length - 10; i++) {
        // JPEG SOI marker
        if (bytes[i] === 0xFF && bytes[i + 1] === 0xD8) {
            // Find EOI marker
            let end = -1;
            for (let j = i + 2; j < bytes.length - 1; j++) {
                if (bytes[j] === 0xFF && bytes[j + 1] === 0xD9) {
                    end = j + 2;
                    break;
                }
            }
            
            if (end > i && end - i > 1000) { // Min 1KB size
                const jpegData = bytes.slice(i, end);
                const blob = new Blob([jpegData], { type: 'image/jpeg' });
                const url = URL.createObjectURL(blob);
                
                // Verify it's a valid image
                const img = new Image();
                await new Promise((resolve) => {
                    img.onload = () => {
                        count++;
                        extractedImages.push({
                            url,
                            blob,
                            width: img.naturalWidth,
                            height: img.naturalHeight,
                            format: 'JPEG',
                            size: jpegData.length,
                            name: `jpeg_${count}`
                        });
                        log(`✓ Found JPEG #${count}: ${img.naturalWidth}x${img.naturalHeight} (${(jpegData.length/1024).toFixed(1)}KB)`, 'success');
                        resolve();
                    };
                    img.onerror = resolve;
                    img.src = url;
                });
                
                i = end - 1; // Skip past this image
            }
        }
    }
    
    log(`Found ${count} JPEG images`, count > 0 ? 'success' : 'warning');
}

async function findPNGs(bytes) {
    log('Scanning for PNG images...', 'info');
    let count = 0;
    const PNG_HEADER = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
    
    for (let i = 0; i < bytes.length - 8; i++) {
        let isPNG = true;
        for (let j = 0; j < 8; j++) {
            if (bytes[i + j] !== PNG_HEADER[j]) {
                isPNG = false;
                break;
            }
        }
        
        if (isPNG) {
            // Find IEND chunk
            let end = -1;
            for (let j = i + 8; j < bytes.length - 8; j++) {
                if (bytes[j] === 0x49 && bytes[j + 1] === 0x45 && 
                    bytes[j + 2] === 0x4E && bytes[j + 3] === 0x44) {
                    end = j + 8; // Include CRC
                    break;
                }
            }
            
            if (end > i) {
                const pngData = bytes.slice(i, end);
                const blob = new Blob([pngData], { type: 'image/png' });
                const url = URL.createObjectURL(blob);
                
                const img = new Image();
                await new Promise((resolve) => {
                    img.onload = () => {
                        count++;
                        extractedImages.push({
                            url,
                            blob,
                            width: img.naturalWidth,
                            height: img.naturalHeight,
                            format: 'PNG',
                            size: pngData.length,
                            name: `png_${count}`
                        });
                        log(`✓ Found PNG #${count}: ${img.naturalWidth}x${img.naturalHeight} (${(pngData.length/1024).toFixed(1)}KB)`, 'success');
                        resolve();
                    };
                    img.onerror = resolve;
                    img.src = url;
                });
                
                i = end - 1;
            }
        }
    }
    
    log(`Found ${count} PNG images`, count > 0 ? 'success' : 'warning');
}

async function findPDFImages(bytes) {
    log('Parsing PDF structure for images...', 'info');
    const text = new TextDecoder('latin1').decode(bytes);
    
    // Find all obj definitions
    const objPattern = /(\d+)\s+\d+\s+obj([\s\S]*?)endobj/g;
    let match;
    let count = 0;
    
    while ((match = objPattern.exec(text)) !== null) {
        const objContent = match[0];
        
        // Check if this is an image XObject
        if ((objContent.includes('/Type /XObject') && objContent.includes('/Subtype /Image')) ||
            objContent.includes('/Filter /DCTDecode') ||
            objContent.includes('/Filter /FlateDecode')) {
            
            count++;
            log(`Found image object ${match[1]}`, 'info');
            
            // Extract width and height
            const widthMatch = objContent.match(/\/Width\s+(\d+)/);
            const heightMatch = objContent.match(/\/Height\s+(\d+)/);
            
            if (widthMatch && heightMatch) {
                const width = parseInt(widthMatch[1]);
                const height = parseInt(heightMatch[1]);
                log(`  Dimensions: ${width}x${height}`, 'info');
            }
            
            // Find stream data
            if (objContent.includes('stream')) {
                const streamStart = objContent.indexOf('stream') + 6;
                const streamEnd = objContent.indexOf('endstream');
                
                if (streamEnd > streamStart) {
                    const absoluteStart = match.index + streamStart;
                    const absoluteEnd = match.index + streamEnd;
                    
                    // Skip whitespace
                    let start = absoluteStart;
                    while (bytes[start] === 0x0A || bytes[start] === 0x0D || bytes[start] === 0x20) {
                        start++;
                    }
                    
                    const streamData = bytes.slice(start, absoluteEnd);
                    
                    if (streamData.length > 100) {
                        // Try to process as image
                        await processImageStream(streamData, `pdf_obj_${match[1]}`);
                    }
                }
            }
        }
    }
    
    log(`Processed ${count} PDF image objects`, 'info');
}

async function findInlineImages(bytes) {
    log('Searching for inline images...', 'info');
    const text = new TextDecoder('latin1').decode(bytes);
    
    // Pattern for inline images: BI ... ID ... EI
    let count = 0;
    let pos = 0;
    
    while (pos < text.length) {
        const biPos = text.indexOf('BI', pos);
        if (biPos === -1) break;
        
        const idPos = text.indexOf('ID', biPos);
        if (idPos === -1 || idPos - biPos > 1000) {
            pos = biPos + 2;
            continue;
        }
        
        const eiPos = text.indexOf('EI', idPos);
        if (eiPos === -1 || eiPos - idPos > 100000) {
            pos = biPos + 2;
            continue;
        }
        
        count++;
        log(`Found inline image #${count}`, 'info');
        
        // Extract image data
        const imageDataStart = idPos + 2;
        const imageData = bytes.slice(imageDataStart, eiPos);
        
        if (imageData.length > 50) {
            await processImageStream(imageData, `inline_${count}`);
        }
        
        pos = eiPos + 2;
    }
    
    log(`Found ${count} inline images`, count > 0 ? 'success' : 'warning');
}

async function extractStreams(bytes) {
    log('Extracting all stream objects...', 'info');
    const text = new TextDecoder('latin1').decode(bytes);
    
    let count = 0;
    let pos = 0;
    
    while (pos < text.length) {
        const streamPos = text.indexOf('stream', pos);
        if (streamPos === -1) break;
        
        const endstreamPos = text.indexOf('endstream', streamPos);
        if (endstreamPos === -1) break;
        
        // Skip whitespace after 'stream'
        let start = streamPos + 6;
        while (bytes[start] === 0x0A || bytes[start] === 0x0D || bytes[start] === 0x20) {
            start++;
        }
        
        const streamData = bytes.slice(start, endstreamPos);
        
        if (streamData.length > 1000) { // Min 1KB
            count++;
            await processImageStream(streamData, `stream_${count}`);
        }
        
        pos = endstreamPos + 9;
    }
    
    log(`Processed ${count} stream objects`, 'info');
}

async function processImageStream(data, name) {
    // Try different interpretations
    let processed = false;
    
    // Check if it's already a JPEG
    if (data[0] === 0xFF && data[1] === 0xD8) {
        const blob = new Blob([data], { type: 'image/jpeg' });
        await addImage(blob, 'JPEG', name);
        processed = true;
    }
    
    // Check if it's a PNG
    else if (data[0] === 0x89 && data[1] === 0x50) {
        const blob = new Blob([data], { type: 'image/png' });
        await addImage(blob, 'PNG', name);
        processed = true;
    }
}

async function addImage(blob, format, name) {
    const url = URL.createObjectURL(blob);
    
    // Try to load as image
    const img = new Image();
    return new Promise((resolve) => {
        img.onload = () => {
            extractedImages.push({
                url,
                blob,
                width: img.naturalWidth,
                height: img.naturalHeight,
                format,
                size: blob.size,
                name
            });
            resolve(true);
        };
        
        img.onerror = () => {
            // Don't save images that fail to load - only keep actual media files
            URL.revokeObjectURL(url); // Clean up the URL since we're not using it
            resolve(false);
        };
        
        img.src = url;
    });
}

function displayResults() {
    const grid = document.getElementById('imagesGrid');
    grid.innerHTML = '';
    
    let totalSize = 0;
    let largestRes = 0;
    const formats = new Set();
    
    extractedImages.forEach((img, idx) => {
        totalSize += img.size;
        formats.add(img.format.split(' ')[0]); // Remove " (data)" suffix
        const res = img.width * img.height;
        if (res > largestRes) largestRes = res;
        
        const card = document.createElement('div');
        card.className = 'image-card';
        card.style.animationDelay = `${idx * 0.1}s`;
        
        const preview = document.createElement('div');
        preview.className = 'image-preview';
        preview.onclick = () => showImage(idx);
        
        if (img.width > 0) {
            const imgEl = document.createElement('img');
            imgEl.src = img.url;
            preview.appendChild(imgEl);
        } else {
            const dataEl = document.createElement('div');
            dataEl.className = 'data-stream';
            dataEl.innerHTML = `<strong>Data Stream</strong><br>${(img.size / 1024).toFixed(1)} KB`;
            preview.appendChild(dataEl);
        }
        
        const info = document.createElement('div');
        info.className = 'image-info';
        info.innerHTML = `
            <div class="image-details">
                <strong>${img.name}</strong><br>
                ${img.width > 0 ? `${img.width}×${img.height} px` : 'Unknown dimensions'}<br>
                ${(img.size / 1024).toFixed(1)} KB • ${img.format}
            </div>
            <button class="btn btn-primary" onclick="downloadImage(${idx})">
                <span class="btn-icon">⬇️</span>
                Download
            </button>
        `;
        
        card.appendChild(preview);
        card.appendChild(info);
        grid.appendChild(card);
    });
    
    // Update stats
    document.getElementById('statImages').textContent = extractedImages.length;
    document.getElementById('statSize').textContent = (totalSize / 1024 / 1024).toFixed(2);
    document.getElementById('statLargest').textContent = 
        largestRes > 0 ? Math.round(Math.sqrt(largestRes)) + '²' : '0';
    document.getElementById('statFormats').textContent = Array.from(formats).join(', ');
    
    log(`=== EXTRACTION COMPLETE ===`, 'success');
    log(`Total images: ${extractedImages.length}`, 'success');
    log(`Total size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`, 'success');
}

function showImage(idx) {
    const img = extractedImages[idx];
    const modal = document.getElementById('modal');
    const content = document.getElementById('modalContent');
    
    if (img.width > 0) {
        content.innerHTML = `
            <button class="modal-close" onclick="closeModal()">×</button>
            <img src="${img.url}" alt="${img.name}">
        `;
    } else {
        content.innerHTML = `
            <button class="modal-close" onclick="closeModal()">×</button>
            <div style="color: white; text-align: center; padding: 4rem;">
                <h2>${img.name}</h2>
                <p>Binary data stream</p>
                <p>${(img.size / 1024).toFixed(1)} KB</p>
            </div>
        `;
    }
    
    modal.classList.add('active');
}

function closeModal() {
    document.getElementById('modal').classList.remove('active');
}

function downloadImage(idx) {
    const img = extractedImages[idx];
    const a = document.createElement('a');
    a.href = img.url;
    a.download = `${currentFileName}_${img.name}.${img.format.toLowerCase().split(' ')[0]}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function downloadAll() {
    extractedImages.forEach((img, idx) => {
        setTimeout(() => downloadImage(idx), idx * 200);
    });
}

function toggleLog() {
    const logContainer = document.getElementById('logContainer');
    logContainer.classList.toggle('active');
}

function clearAll() {
    extractedImages.forEach(img => URL.revokeObjectURL(img.url));
    extractedImages = [];
    document.getElementById('imagesGrid').innerHTML = '';
    document.getElementById('controls').classList.remove('active');
    document.getElementById('logContainer').classList.remove('active');
    document.getElementById('fileInput').value = '';
}
</script>